:ORG-PROPERTIES:
#+LANGUAGE: gr
#+STARTUP: latexpreview showeverything
#+OPTIONS: tags:t toc:nil
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+EXCLUDE_TAGS: noexport
#+TAGS:  noexport(n)
#+INCLUDE: title_page_latex.org
:END:
\clearpage \tableofcontents \clearpage
* Imports :noexport:
#+begin_src jupyter-python :session python3thon3 :async yes :results drawer :tangle ./src/tables_data_process_blocks.py
#%%
import numpy as np
import math
import matplotlib.pyplot as plt
from scipy import signal
from tabulate import tabulate
from pros_noisefiltering.WT_NoiProc import fir_factory_constructor
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :session python3 :async yes :results raw drawer :tangle ./src/tables_data_process_blocks.py

#%%
from pathlib import Path
from nptdms import TdmsFile
from pros_noisefiltering.WT_NoiProc import (WT_NoiseChannelProc,
                                            Graph_data_container,
                                            )
from pros_noisefiltering.gen_functions import plot_spect_comb2

#+end_src
#+RESULTS:
:results:
:end:
** Basic folders and data
#+begin_src jupyter-python :session python3 :async yes :results raw drawer :tangle ./src/tables_data_process_blocks.py
#%%
FOLDER_FOR_DATA = Path(
    '/mnt/data_folder/measurements_12_05_22/new_record_prop_channel/')
if not FOLDER_FOR_DATA.exists():
    FOLDER_FOR_DATA = Path('D:/_data/WEL/WEL20220512/')

# %% CONSTANTS
FIGSIZE_STD = (6, 6)
# Constant directories and names for the .tdms file structure
# Dir name
TDMS_FNAME = 'Data.tdms'
GROUP_NAME = 'Wind Measurement'
CHAN_NAME = 'Wind2'

# %%
# Dir names for the Compressed air measurment
#
# =================================================
#
# Here the Compressed air measurements are imported
#
# =================================================
#
comp_air_dir = 'compressed air'

# %% preparing tdms files
# New renamed folders for rec version information
data_CA_inv_0_WS_0 = 'ca0_0.1'
data_CA_inv_0_WS_5 = 'ca0_5.1'
data_CA_inv_0_WS_11 = 'ca0_10.1'
data_CA_inv_1_WS_0 = 'ca1_0.1'
data_CA_inv_1_WS_5 = 'ca1_5.1'
data_CA_inv_1_WS_10 = 'ca1_10.1'

path_comp = FOLDER_FOR_DATA / comp_air_dir

# CA stands for compressed air

raw_signal_CA = [data_CA_inv_0_WS_0, data_CA_inv_0_WS_5,
                 data_CA_inv_0_WS_11, data_CA_inv_1_WS_0,
                 data_CA_inv_1_WS_5, data_CA_inv_1_WS_10]

l_tdms_CA = []

for item in raw_signal_CA:
    x = TdmsFile(Path(f'{path_comp}/{item}', TDMS_FNAME))
    l_tdms_CA.append(x)

# %%
# [print(x) for x in l_tdms_CA[0][GROUP_NAME].channels()]
# %%
GROUP_NAME = 'Wind Measurement'
CHAN_NAME = 'Wind2'


df_tdms_0_0 = WT_NoiseChannelProc.from_tdms(
    l_tdms_CA[0][GROUP_NAME][CHAN_NAME],
    desc='Inverter off, WS=0')
df_tdms_0_5 = WT_NoiseChannelProc.from_tdms(
    l_tdms_CA[1][GROUP_NAME][CHAN_NAME],
    desc='Inverter off, WS=5')
df_tdms_0_10 = WT_NoiseChannelProc.from_tdms(
    l_tdms_CA[2][GROUP_NAME][CHAN_NAME],
    desc='Inverter off, WS=11')
df_tdms_1_0 = WT_NoiseChannelProc.from_tdms(
    l_tdms_CA[3][GROUP_NAME][CHAN_NAME],
    desc='Inverter on, WS=0')
df_tdms_1_5 = WT_NoiseChannelProc.from_tdms(
    l_tdms_CA[4][GROUP_NAME][CHAN_NAME],
    desc='Inverter on, WS=5')
df_tdms_1_10 = WT_NoiseChannelProc.from_tdms(
    l_tdms_CA[5][GROUP_NAME][CHAN_NAME],
    desc='Inverter on, WS=10')

#
# =================================================
#
# Here the Inverter measurements are imported
#
# =================================================
#
# %%
inv_meas_dir = 'inverter'
# Inverter measurements of interest
data_inv_inv_0_WS_0 = 'in0_0.1'
data_inv_inv_1_WS_0 = 'in1_0.1'
data_inv_inv_1_WS_5 = 'in1_5.1'
data_inv_inv_1_WS10 = 'in1_10.1'
data_inv_inv_1_WS15 = 'in1_15.1'
data_inv_inv_1_WS_20 = 'in1_20.1'


path_comp = FOLDER_FOR_DATA / inv_meas_dir

# suffixes:
# - CA : compressed air
# - Inv : Inverter
# - DEC : decimation

raw_signal_CA = [data_inv_inv_0_WS_0, data_inv_inv_1_WS_0,
                 data_inv_inv_1_WS_5,
                 data_inv_inv_1_WS10, data_inv_inv_1_WS15,
                 data_inv_inv_1_WS_20]

l_tdms_Inv = []

for item in raw_signal_CA:
    x = TdmsFile(Path(f'{path_comp}/{item}', TDMS_FNAME))
    l_tdms_Inv.append(x)

# %%
# [print(x) for x in l_tdms_Inv[0][GROUP_NAME].channels()]
# %%
dfi_i0_w0 = WT_NoiseChannelProc.from_tdms(
    l_tdms_Inv[0][GROUP_NAME][CHAN_NAME],
    desc='Inverter Off, WS=0, 100kHz')
dfi_i1_w0 = WT_NoiseChannelProc.from_tdms(
    l_tdms_Inv[1][GROUP_NAME][CHAN_NAME],
    desc='Inverter On, WS=0, 100kHz')
dfi_i1_w5 = WT_NoiseChannelProc.from_tdms(
    l_tdms_Inv[2][GROUP_NAME][CHAN_NAME],
    desc='Inverter On, WS=5, 100kHz')
dfi_i1_w10 = WT_NoiseChannelProc.from_tdms(
    l_tdms_Inv[3][GROUP_NAME][CHAN_NAME],
    desc='Inverter On, WS=10, 100kHz')
dfi_i1_w15 = WT_NoiseChannelProc.from_tdms(
    l_tdms_Inv[4][GROUP_NAME][CHAN_NAME],
    desc='Inverter On, WS=15, 100kHz')
dfi_i1_w20 = WT_NoiseChannelProc.from_tdms(
    l_tdms_Inv[5][GROUP_NAME][CHAN_NAME],
    desc='Inverter On, WS=20, 100kHz')

#+end_src

#+RESULTS:
:results:
:end:

* Εισαγωγή
#+ODT: <text:p text:style-name="PageBreak"/>
Σε πολλές περιπτώσεις η ανάγκη της επεξεργασίας σημάτων, όπως στις
τηλεπικοινωνίες μετά ή/και πριν την μετάδοση από τον πομπό προς τον
δέκτη, και η εκλογή πληροφοριών από αυτό έθεσαν από νωρίς το πρόβλημα
των παρεμβολών του περιβάλλοντος στις ηλεκτρονικές συσκευές και την
ανάγκη απομόνωσης του φάσματος των συχνοτήτων που χρησιμοποιούνται για
κάθε λειτουργία.

Η απομόνωση αυτή μπορεί να επιτευχθεί είτε μέσω συμβατικών φίλτρων,
δηλαδή αντιστάσεις και πυκνωτές κατάλληλα τοποθετημένα στο κύκλωμα που
συλλέγει την τάση (*ρεύμα μέτρησης*), είτε με την χρήση μεθόδων ψηφιακής
επεξεργασίας σημάτων \(DSP\).
Στις μέρες μας προτιμάται ο 2ος τρόπος λόγω
της ραγδαίας εξέλιξης των Η/Υ με αποτέλεσμα να επιφέρει μεγαλύτερο
κόστος η εγκατάσταση αναλογικών φίλτρων σε κάθε θέση που απαιτείται.

Οι μέθοδοι αλλά και η πληθώρα συστημάτων λήψης και ανάλυσης σημάτων τις
τελευταίες δεκαετίες έχουν, αφενός εξελιχθεί ως προς την υπολογιστική
ισχύ με ταχύτερους επεξεργαστές και αλγόριθμους, αφετέρου δίνουν
πλέον την δυνατότητα διαχείρισης των πληροφοριών απομακρυσμένα με
αποτέλεσμα την ευρύτερη εγκαθίδρυση των ψηφιακών μέσων επεξεργασίας
σημάτων. Στις μέρες μας η ανάγκη διαχείρισης ολοένα και μεγαλύτερων
αρχείων δεδομένων με καλύτερη ακρίβεια οδήγησε την επιστημονική κοινότητα
στην χρήση της μεθόδου *μετα-επεξεργασίας* (\(post-processing\)). Βασικό όφελος
ήταν η δυνατότητα επαναληψιμότητας του πειράματος και σύγκρισης των
αποτελεσμάτων σε όλο τον κόσμο, ουσιαστική αρχή της πειραματικής
διαδικασίας. Έτσι με την χρήση προγραμματισμού δίνεται πλέον η
δυνατότητα στον ερευνητή, να δημιουργεί ένα περιβάλλον προσομοίωσης και
να δοκιμάζει διάφορες λύσεις χωρίς να επισκεφτεί την πειραματική διάταξη
σε πολλές περιπτώσεις μετά την καταγραφή των μετρήσεων.

Στην παρούσα εργασία θα πραγματευτούμε την απομείωση συγκεκριμένων
συχνοτήτων με την χρήση Ψηφιακής Ανάλυσης Σημάτων και φίλτρων, διαφόρων
κατηγοριών. Στο πλαίσιο αυτό θα παρουσιαστεί, μια μελέτη που
πραγματοποιήθηκε σε συνεργασία με το εργαστήριο Αιολικής Ενέργειας του
τμήματος Μηχανολόγων Μηχανικών στο Ελληνικό Μεσογειακό Πανεπιστήμιο με
θέμα την απόρριψη θορύβου από αισθητήριο όργανο για την μέτρηση της
ταχύτητας ανέμου σε περιβάλλον με ενισχυμένες παρεμβολές. Η
_ιδιαιτερότητα_ που παρουσιάστηκε στην εγκατάσταση ήταν παρεμβολές από
ηλεκτρικό μετασχηματιστή, που όμως ήταν αδύνατο να
αφαιρεθεί, και ταυτόχρονα ο σχεδιασμός όπως και η τοποθέτηση ενός
αναλογικού φίλτρου θα ενέτασσαν μεγάλο κόστος και περιπλοκότητα. Θα
αναλυθούν οι δομές σημάτων που επεξεργάστηκαν καθώς και οι τύποι των
φίλτρων που χρησίμευσαν στην απομόνωση των ζητούμενων φασμάτων συχνοτήτων.
Επίσης θα υπάρξει παράθεση των θετικών και αρνητικών που παρατηρήθηκαν κατά την
διάρκεια εκτέλεσης της επεξεργασίας και καταγραφής των δεδομένων.
-----
* Ιστορική αναδρομή
:PROPERTIES:
:ATTR_ODT: :page-break t
:END:
Από την εποχή της ανακάλυψης του Απειροστικού λογισμού \(calculus\)
τον 17ο αιώνα, οι επιστήμονες προσπαθούν να εξηγήσουν τα φυσικά
φαινόμενα με μαθηματικά μοντέλα χρησιμοποιώντας εξισώσεις
συνεχών μεταβλητών και διαφορικές εξισώσεις. Χρησιμοποιήθηκαν
τεχνικές αριθμητικής επίλυσης όταν οι αναλυτικές λύσεις δεν
ήταν εφικτό να καθοριστούν. Αργότερα μαθηματικοί του 18ου αιώνα
όπως οι Ευλερ, Μπερνούλι και Λαγκραντζ κατασκεύασαν μεθόδους
για αριθμητική ολοκλήρωση και την εισαγωγή εξισώσεων συνεχών
μεταβλητών. Μια ιστορική μελέτη από τους \(Heideman,\ Johnson\) και
${Burrus}$ (1984) έδειξε ότι ο ${Gauss}$ είχε ανακαλύψει την βασική
αρχή του γρήγορου μετασχηματισμού ${Fourier}$ ήδη από το 1805, πριν
την δημοσίευση της διατριβής του .... πάνω στην απεικόνιση
αρμονικών σειρών εξισώσεων.
Στις αρχές του 1950, η ανάλυση σημάτων γινόταν κυρίως με
αναλογικά συστήματα κατασκευασμένα από ηλεκτρονικά κυκλώματα
ακόμα και με μηχανικές συσκευές. Ενώ οι Η/Υ είχαν κάνει την
είσοδό τους ήδη σε επιχειρήσεις και επιστημονικά εργαστήρια
ήταν ακόμα ακριβοί με περιορισμένες δυνατότητες. Περίπου εκείνη
την εποχή ξεκίνησε η ανάγκη για πιο εξειδικευμένες μεθόδους
στην ανάλυση σημάτων και στράφηκε η προσοχή στην ανάλυση
διακριτού χρόνου σημάτων. Μια από τις πρώτες εφαρμογές των Η/Υ
ήταν η καταγραφή σεισμικών δονήσεων σε πλατφόρμες εξόρυξης
πετρελαίου, που καταγράφονταν σε μαγνητική ταινία για να επεξεργαστούν
αργότερα. Η διαδικασία αυτή δεν μπορούσε να γίνει σε
πραγματικό χρόνο, καθώς μπορεί να χρειαζόντουσαν κάποια
λεπτά ακόμα και ώρες για την επεξεργασία μερικών δευτερολέπτων
από τις μαγνητικές ταινίες.
    Την ίδια εποχή για όσους είχαν την δυνατότητα να χρησιμοποιήσουν
ψηφιακούς υπολογιστές, ήταν εύκολο να δημιουργήσουν ένα περιβάλλον
προσομοίωσης για να μελετήσουν νέους αλγόριθμους και μεθόδους
ανάλυσης σημάτων πριν χρησιμοποιήσουν πόρους και μηχανικούς για την
κατασκευή της αναλογικής συσκευής που τελικά θα εκτελούσε την
επιθυμητή εργασία. Παραδείγματα τέτοιων προσομοιώσεων ήταν εκείνες
που πραγματοποιήθηκαν στο Εργαστήριο Λίνκολν και στα Εργαστήρια Μπελλ
όπου προσομοιώθηκε ένας κωδικοποιητής φωνής ${vocoder}$. Στην κατασκευή
ενός αναλογικού καναλιού κωδικοποιητής φωνής, τα χαρακτηριστικά του
φίλτρου επηρεάζουν την ποιότητα της φωνής σε βαθμό που ήταν δύσκολο να
διακριθούν αντικειμενικά. Μέσω προγραμματισμένων προσομοιώσεων
κατάφεραν την ρύθμιση των χαρακτηριστικών, ώστε να καθορίσουν το
αποτέλεσμα της αναλογικής συσκευής πριν την κατασκευή της.
    Εδώ αξίζει να σημειωθεί ότι ενώ η χρήση των Η/Υ βοήθησε στην πειραματική
διαδικασία, μπορούσε μόνο να /προσομοιώσει ή προσεγγίσει/ το αναλογικό
σύστημα ανάλυσης σημάτων.

Καθώς τα σήματα ξεκίνησαν να επεξεργάζονται σε ψηφιακούς υπολογιστές, οι
ερευνητές αναγκάστηκαν πολύ γρήγορα να χρησιμοποιούν ολοένα και πιο περίπλοκους
αλγόριθμους επεξεργασίας σημάτων. Πολλοί από τους αλγόριθμους
εξελίχθηκαν λόγω της ευελιξίας που παρείχε το προγραμματιστικό περιβάλλον
σε αντίθεση με την μόνιμη αναλογική κατασκευή, όπου περιορίζεται η δυνατότητα
πειραματισμού. Έτσι η συνεχής εξέλιξη και ευελιξία της ψηφιακής
επεξεργασίας σημάτων έδωσε το έναυσμα για την ολική ψηφιοποίηση των συσκευών
και μεθόδων της επεξεργασίας και διάδοσης σημάτων στην πλειοψηφία των
εγκαταστάσεων. Εκείνη την περίοδο ξεκίνησε ενεργά η δημιουργία ψηφιακών
κωδικοποιητών φωνής, ψηφιακών αναλυτών φάσματος κ.α. συσκευών αμιγώς ψηφιακής
επεξεργασίας σήματος, με την ελπίδα ότι τελικά τέτοια συστήματα θα
αποκτούσαν πρακτικές εφαρμογές.

Μία νέα σκοπιά προς την επεξεργασία σημάτων διακριτού χρόνου επιταχύνθηκε
με την δημοσίευση από τους ${Cooley\ and\ Tukey}$ (1965) ενός αποδοτικού αλγόριθμου
για τον υπολογισμό του μετασχηματισμού ${Fourier}$. Η κλάση αυτή θα γίνει
αργότερα γνωστή ως Ταχύς Μετασχηματισμός ${Fourier\ (F.F.T.\ Fast\ Fourier\ Transform)}$.
Ο $\en{F.F.T.}$ ήταν αρκετά σημαντικός για πολλούς λόγους. Βασικό
πρόβλημα των αλγόριθμων της εποχής ήταν ότι απαιτούσαν χρόνους
επεξεργασίας πολύ μεγαλύτερους από τον πραγματικό χρόνο του
καταγεγραμμένου σήματος. Αυτό συνέβαινε γιατί στις περισσότερες
περιπτώσεις απαιτείται η χρήση ανάλυσης φάσματος του σήματος και μέχρι
τότε δεν υπήρχε κάποιος αποδοτικός αλγόριθμος. Ο ταχύς μετασχηματισμός
προσέφερε την δυνατότητα στους ερευνητές να πειραματίζονται σε
πραγματικούς χρόνους με την εγκατάσταση, καθώς μείωσε δραστικά τον χρόνο
επεξεργασίας κατά πολλές τάξεις μεγέθους. Επιπρόσθετα πολλοί αλγόριθμοι
που δεν είχαν καμία πρακτική εφαρμογή, λόγω του χρόνου επεξεργασίας,
ξεκίνησαν να έχουν πρακτικές εφαρμογές στην βιομηχανία και αργότερα στα
προϊόντα για τον γενικό πληθυσμό.

Άλλη μια σημαντική ιδιότητα του ${F.F.T.}$ που βοήθησε στον σχεδιασμό καλύτερων
συσκευών ήταν ότι προγραμματίστηκε με βάση τα σήματα διακριτού χρόνου.
Δηλαδή εμπεριείχε τις απαιτούμενες ιδιότητες και μαθηματικά ώστε να
διαχειρίζεται ψηφιοποιημένα σήματα -διακριτού χρόνου- και να μην
/προσομοιώνει/ μια αναλογική συμπεριφορά ενός σήματος ή συστήματος.
Έτσι η δυνατότητα σχεδιασμού συστημάτων που προβλεπόταν η ακριβής
συμπεριφορά του βοήθησε στην εξέλιξη της επεξεργασίας σημάτων
διακριτού χρόνου χωρίς την ανάγκη συσχέτισης των αποτελεσμάτων
με ένα σύστημα συνεχούς χρόνου (αναλογικού συστήματος). Έτσι η ένταξη
των διακριτών σημάτων ως ξεχωριστή μέθοδος επεξεργασίας προσέφερε στην
ανάπτυξη τεχνολογίας μειώνοντας, εκτός από τους απαιτούμενους χρόνους,
το κόστος και τον όγκο των εγκαταστάσεων για την επίτευξη του στόχου.

Παράλληλα η επινόηση και εφεύρεση των μικρο-ελεγκτών στον τομέα της
μικροηλεκτρονικής επέφερε περαιτέρω μείωση του κόστους. Ενώ οι
πρώτες συσκευές μικρο-ελεγκτών δεν παρείχαν τις απαιτούμενες δυνατότητες
για την ολοκλήρωση των συστημάτων επεξεργασίας διακριτών σημάτων, από
τις αρχές της δεκαετίας του '80 η ταχύτητα τους αυξάνεται εκθετικά.
Επιπρόσθετα η αρχιτεκτονική και τεχνολογία των ολοκληρωμένων κυκλωμάτων
(${I.C.\ Intergated\ Circuit}$) αναπτύχθηκε προς την κατεύθυνση για την κατασκευή
ολοένα και ταχύτερων υπολογιστών για την διαχείριση ακέραιων και δεκαδικών
αριθμών. Έτσι σήμερα η ανάλυση σημάτων, η καταγραφή όπως και η μετάδοσή τους
γίνεται πολλές φορές εξ' ολοκλήρου από ψηφιακά συστήματα.
-----
* Σήματα
** Εισαγωγή
Ο όρος σήμα ${(signal)}$ δίνεται σε κάτι που εμπεριέχει πληροφορία. Γενικά
τα σήματα χρησιμοποιούνται στην κωδικοποίηση και εξαγωγή πληροφοριών για
την κατάσταση ή/και την συμπεριφορά ενός φυσικού συστήματος. Συχνά
συνδυάζοντας διαφορετικά σήματα υπάρχει η δυνατότητα επικοινωνίας μεταξύ
ανθρώπων αλλά και με μηχανήματα. Άν και αναπαριστούμε τα σήματα με διάφορες
μορφές η πληροφορία που μεταδίδουν, εμπεριέχεται με την μορφή μοτίβων. Η
μαθηματική αναπαράσταση παρέχεται μέσω συνάρτησης μίας ή περισσότερων
ανεξάρτητων μεταβλητών. Ένα παράδειγμα είναι η ανεξάρτητη μεταβλητή της
εξίσωσης που περιγράφει μία ψηφιακή εικόνα, όπου θα αποτελείται από δύο
χωρικές μεταβλητές σε συνάρτηση της φωτεινότητας. Αντίθετα ένα αρχείο ήχου
θα ορίζεται σε συνάρτηση με τον χρόνο. Εδώ καταχρηστικά όταν θα αναφερόμαστε
σε κάποιο σήμα θα χρησιμοποιούμε την 2η περίπτωση, δηλαδή ως προς τον χρόνο.

Η ανεξάρτητη μεταβλητή του χρόνου σε ένα σήμα μπορεί να είναι συνεχής ή
διακριτή ως προς το διάστημα που ορίζεται. Τα σήματα συνεχούς χρόνου
ορίζονται για κάθε τιμή τους στο διάστημα και επομένως αναπαριστώνται
με μία ανεξάρτητη συνεχή μεταβλητή. Στην παραπάνω περίπτωση αναφερόμαστε
σε αυτά ως *αναλογικά σήματα*. Ως *σήματα διακριτού χρόνου* ονομάζουμε όσα η
ανεξάρτητη μεταβλητή του χρόνου μας παρέχει πληροφορία για συγκεκριμένα
διαστήματα ή αλλιώς χρονικές στιγμές. Εδώ η αναπαράσταση του χρόνου γίνεται
με την χρήση ακολουθίας αριθμών, συνήθως ανά συγκεκριμένο διάστημα π.χ.
κάθε 0,1 δευτερόλεπτα. Εκτός του χρόνου την ίδια κατηγοριοποίηση συναντούμε
και στην αναπαράσταση της ισχύος ενός σήματος \((amplitute)\). *Ψηφιακά σήματα*
ονομάζονται όσα έχουν διακριτές τιμές ισχύος και χρόνου.

Τα συστήματα ανάλυσης σημάτων κατηγοριοποιούνται ανάλογα. Συστήματα συνεχούς
χρόνου ονομάζονται εκείνα που τα σήματα εισόδου και εξόδου είναι αναλογικά.
Αντίστοιχα συστήματα διακριτού χρόνου ονομάζονται όσα διαχειρίζονται σήματα
διακριτού χρόνου. Ψηφιακά συστήματα ονομάζονται όσα λαμβάνουν σε είσοδο και
έξοδο ψηφιακά σήματα. Επομένως στην ψηφιακή ανάλυση σημάτων
${(Digital\ signal\ processing)}$ επεξεργάζονται σήματα που εκφράζονται
με ακολουθίες για τον χρόνο και την ισχύ τους.

Σήματα διακριτού χρόνου προκύπτουν καταγράφοντας ένα συνεχές σήμα ή από
διεργασίες που εκτελούνται σε διακριτές τιμές του χρόνου. Ανεξαρτήτου
προέλευσης του σήματος, τα συστήματα επεξεργασίας σημάτων διακριτού χρόνου
παρέχουν πολλές δυνατότητες ελκύοντας το ενδιαφέρον τις τελευταίες
δεκαετίες. Έχουν δυνατότητες προσομοίωσης αναλογικών συστημάτων με
περισσότερη ευελιξία και παρέχουν την δυνατότητα ανακάλυψης τυχών μεταβολών
στα σήματα που δεν είναι δυνατόν να γίνουν αντιληπτά από ένα αναλογικό
σύστημα επεξεργασίας. Επιπρόσθετα η συνεχής ανάπτυξη ψηφιακών συσκευών
όπως είναι οι υπολογιστές γενικής χρήσης και οι μικρο-ελεγκτές προτιμάται
η αναπαράσταση των σημάτων σε διακριτά πεδία χρόνου αν όχι σε ψηφιακή μορφή.

Παρακάτω στο κεφάλαιο θα αναφερθούμε σε βασικές έννοιες που διέπουν τα σήματα
διακριτού χρόνου και συστήματα ανάλυσης αυτών για μονοδιάστατα σήματα.
Πρακτικά υπάρχει η δυνατότητα να διαχειριστούμε τα σήματα αυτά ως αναλογικά
και με σωστή χρήση συγκεκριμένων κριτηρίων μπορούμε να εξάγουμε τα σωστά
αποτελέσματα. Τέτοιου τύπου συστήματα καθόρισαν τις βασικές αρχές των
καταγραφικών συσκευών δεδομένων. Όμως πολλά συστήματα διακριτού χρόνου
δεν ορίζονται ως προσομοιώσεις αναλογικών συστημάτων καθώς και πολλές
ακολουθίες δεν προκύπτουν καταγράφοντας ένα αναλογικό σήμα. Για τους
παραπάνω λόγους αντί να εφαρμοστούν τα αποτελέσματα από την θεωρία που
αναφέρεται στα συνεχή σήματα-συστήματα, θα εκβάλλονται παράλληλα συμπεράσματα
ξεκινώντας από τα χαρακτηριστικά που διέπουν το σήμα και θέτοντας το
ανάλογο πλαίσιο επεξεργασίας. Εδώ ασχοληθήκαμε μόνο με ψηφιακά σήματα
καθώς η καταγραφή των σημάτων έγινε με Η/Υ μέσω προγράμματος ${(Lab-View)}$.

** Σήματα συνεχούς χρόνου
Στην εισαγωγή αναφερθήκαμε στον γενικό ορισμό των σημάτων και τις διαφορές
που τα κατηγοριοποιούν σε αρχικό βαθμό. Επειδή ο στόχος της παρούσας εργασίας
ήταν η απόρριψη θορύβου δεν θα γίνει η πρέπουσα ανάλυση στην θεωρία των σημάτων,
αντιθέτως θα παρατεθούν οι βασικές αρχές και έννοιες ώστε να υπάρχει το υπόβαθρο
για τα επόμενα κεφάλαια. Σήμα συνεχούς χρόνου ορίζουμε ως την εξίσωση που
περιγράφει την εξέλιξη μιας περιοδικής κυματομορφής στο χρόνο. Πιο συγκεκριμένα
αν υποθέσουμε πως ο χρόνος διάρκειας του σήματος είναι \(t\) τότε η κυματομορφή στο
πεδίο του χρόνου θα εκφράζεται ως συνάρτηση αυτού \(s(t)\).

Μπορεί λοιπόν να παρασταθεί από μία ανεξάρτητη μεταβλητή και ορίζεται για κάθε
τιμή της. Με παρόμοιο τρόπο ορίζονται και τα διακριτά σήματα συνεχούς χρόνου.
Η διαφορά είναι πως αντί να μπορούμε να ταυτίσουμε κάθε χρονική στιγμή με το
αντίστοιχο \(s(t)\), μπορούμε να ορίσουμε την εξίσωση της κυματομορφής για
περιορισμένο ή αλλιώς διακριτό πεδίο τιμών. Σήμα συνεχούς χρόνου
ονομάζεται ένα σήμα \(y(t)\), το οποίο ορίζεται για κάθε τιμή του \(t\) σε κάποιο
διάστημα χρόνου \([\alpha,\beta]\). Συνήθως τα συναντούμε στην μορφή συνεχούς ρεύματος σε
μετρητικές και άλλες συσκευές σε εξόδους για την ένδειξη κάποιας τιμής ή
απεικόνιση σε παλμογράφο. Τα σήματα συνεχούς χρόνου χωρίζονται σε αναλογικά
και διακριτά σήματα συνεχούς χρόνου.

Αναλογικά σήματα ονομάζονται εκείνα που η ανεξάρτητη μεταβλητή του
χρόνου \(t\) και η μεταβλητή του πλάτους (εξαρτημένη μεταβλητή ως προς τον
χρόνο) λαμβάνουν συνεχής και πραγματικές τιμές, π.χ. \(s(t) = 12 * t\).
Διακριτά σήματα συνεχούς χρόνου ονομάζονται όσα ή εξαρτημένη τιμή
(πλάτος) παίρνει διακριτές τιμές, π.χ.
\begin{equation}
\begin{align}
s(t) =  A * t \\
A &= [0, … ,n],\ t \in [a,b] n \in \mathbb{Z} \\
\end{align}
\end{equation}

Στην πληθώρα των συσκευών επεξεργασίας και καταγραφής σημάτων η χρήση
των αναλογικών σημάτων έχει σχεδόν εκλείψει. Σημαντικό μειονέκτημα
ανάμεσα σε άλλα είναι και ο υπέρογκος χώρος που απαιτείται
για την αποθήκευση του. Παρακάτω θα αναφερθούμε στα *ψηφιακά* σήματα που
έλυσαν πολλά από τα προβλήματα των αναλογικών σημάτων, προσθέτοντας μια
σειρά από “πονοκεφάλους” αρχικά στην επιστημονική κοινότητα. Τα
πλεονεκτήματα ήταν πολλά και τελικά επικράτησαν. Παρακάτω θα παρατεθούν
κάποιες βασικές έννοιες και αρχές που τα διέπουν.
-----
** Σήματα διακριτού χρόνου
Σήμα διακριτού χρόνου ονομάζεται μια ακολουθία αριθμών καταγεγραμμένες
ανά συγκεκριμένο χρονικό διάστημα, π.χ. κάθε 0,01 δευτερόλεπτο. Το
διάστημα αυτό ορίζει την ταχύτητα καταγραφής του σήματος από την
εκάστοτε συσκευή, όμως εμείς αναφερόμαστε σε αυτό το χρόνο μέσω της
συχνότητας καταγραφής ή αλλιώς ${sampling\ frequency}$. Η συχνότητα αυτή
ορίζεται ως το πηλίκο ενός δευτερολέπτου ως προς το χρονικό διάστημα
καταγραφής, δηλαδή από το παραπάνω παράδειγμα θα είχαμε μια συχνότητα
καταγραφής 1/0.01 \([Hz]\).
\begin{equation}
fs = \frac{1}{0,01} [Hz]
\end{equation}
Σημαντικό είναι να αναφερθεί ότι υπάρχει ένα όριο το οποίο πρέπει να
τηρείται ώστε η επαναδημιουργία του σήματος να απεικονίζει όσο το
δυνατόν πιο πολύ στο συνεχές σήμα που καταγράφηκε στην αρχή. Θα
αναφερθούμε αργότερα στο εν λόγω θεώρημα του φυσικού ${Niquist}$.
*** Μοναδιαίο διακριτό σήμα
Μοναδιαίο ονομάζεται το σήμα που αποτελείται από έναν κρουστικού
χαρακτήρα παλμό και έχει μηδενική ισχύ πριν και μετά την εμφάνισή
του. Αν υποθέσουμε μια συνάρτηση \(y(t)\) ,
\begin{equation}
\begin{align}
y(t) = [..., 0, 1, 0, ...]
\end{align}
\end{equation}
θα είναι η έξοδός του.

Μια άλλη βασική υποκατηγορία αποτελεί η μοναδιαία ακολουθία βήματος.
Εδώ σε αντίθεση με παραπάνω, η τιμή της εξόδου αλλάζει από μηδέν σε ένα
μόλις η εξαρτημένη μεταβλητή \(t\) λάβει κάποια οριακή τιμή.
Χρησιμοποιώντας το ανωτέρω παράδειγμα θα έχουμε ότι:
\begin{equation}
\begin{align}
y(t) = [..., 0, 1, 1, 1, ...]
\end{align}
\end{equation}
*** Τυχαίο σήμα
Τα τυχαία σήματα αποτελούν μία ειδική υποκατηγορία που χρησιμοποιείται
ευρέως στην ανάλυση ψηφιακών σημάτων. Αναπτύχθηκαν για να καλύψουν την
ανάγκη επιβεβαίωσης των συσκευών επεξεργασίας κυματομορφών. Με την
πάροδο του χρόνου τις συναντάμε σε διάφορες συσκευές τηλεπικοινωνίας
και σχεδόν σε όλες τις συσκευές παραγωγής ήχου (\(synthesizers\)).
Αξίζει να σημειωθεί για λόγους πληρότητας ότι τα εν' λόγω σήματα
βασίζονται σε στατιστικά μοντέλα που απορρέουν από στατιστικές κατανομές.
Ο “λευκός” γκαουσιανός θόρυβος (\(white\ gaussian\ noise)\) ακολουθεί
την λεγόμενη κανονική κατανομή πιθανοτήτων του \(Gauss\). Στην παρούσα
εργασία ένα αντίστοιχο σήμα χρησιμοποιήθηκε για την επιβεβαίωση των
φίλτρων πριν την εφαρμογή στο σετ δεδομένων. Δεν θα γίνει περαιτέρω
ανάλυση γιατί κρίθηκε πως οι παρεμβολές στον αισθητήρα της εγκατάστασης
προερχόταν από εξωτερικά Η/Μ πεδία και όχι από τυχαίο θόρυβο. Τα καλώδια
που χρησιμοποιήθηκαν για την καταγραφή έχουν την δυνατότητα απόρριψης
παρόμοιου τύπου θόρυβο.
*** Διακριτά σήματα και ακολουθίες
Για τον ορισμό του διακριτού σήματος αρκεί να υποθέσουμε μια μαθηματική
ακολουθία αριθμών \(x\), όπου το νιοστό στοιχείο της θα γραφόταν ως \(x[n]\).
Ορθότερα μπορούμε να γράψουμε την εξής έκφραση:
\begin{equation}
\begin{align}
n \in \mathbb{Z} \\
x &= {x[n]},\  -\infty < n < \infty \\
\end{align}
\end{equation}
όπου \(\mathbb{Z}\) είναι σαφώς το σύνολο των ακέραιων αριθμών και \(x[n]\) το κάθε στοιχείο
της ακολουθίας. Ο συγκεκριμένος τύπος σήματος παράγεται συνήθως από την
καταγραφή αναλογικού σήματος. Επομένως η παραπάνω σχέση μετασχηματίζεται
για αναλογικό σήμα της μορφής \(x_{a}(t)\), για χρονική στιγμή ίση με \(nT\), το
νιοστό στοιχείο της ακολουθίας εξόδου από την καταγραφή θα είναι της
μορφής:
\begin{equation}
\begin{align}
x[n] = x_{a} nT,\ -\infty < n < \infty \\
\end{align}
\end{equation}

Η ποσότητα \(T\) ορίζει την περίοδο καταγραφής που παρέχει την συχνότητα
καταγραφής διαιρώντας με την μονάδα. Αν και τα διακριτά σήματα δεν
προέρχονται πάντα από καταγραφή αναλογικών σημάτων ο ορισμός του αριθμού
των στοιχείων της ακολουθίας \(n\) μπορεί να λάβει μόνο ακέραιες τιμές. Επίσης
γράφοντας μόνο το “τελευταίο” ψηφίο μέσα στην αγκύλη αναφερόμαστε σε όλα
τα στοιχεία της ακολουθίας για συντομία και όχι στο τελευταίο στοιχείο
αυτής.
*** Διαχείριση και βασικές τεχνικές μετασχηματισμών
Κατά την διαδικασία της ανάλυσης σημάτων είναι συχνά απαραίτητη η επέμβαση
στο σήμα εισόδου ή εξόδου. Οι πράξεις του πολλαπλασιασμού και της πρόσθεσης
δυο σημάτων μεταξύ τους λαμβάνει χώρα στοιχείο προς στοιχείο, όπως πράξεις
μεταξύ αριθμού και ακολουθίας. Επίσης όταν αφαιρείται από μια ακολουθία
ακέραιος αριθμός το παράγωγο σήμα ονομάζεται καθυστέρηση του αρχικού
(\(delayed\)). Μια τέτοια ακολουθία μπορεί να βρεθεί γραμμένη ως εξής:

\begin{equation}
\begin{align}
a_{0} \in \mathbb{Z} \\
&out[z] = in[z-a_{0}] \\
\end{align}
\end{equation}

Τέτοιου είδους μετασχηματισμοί εφαρμόζονται σε συνδυασμούς και παρέχουν μία
πληθώρα διεργασιών ανάμεσα σε σήματα αλλά και σε σχέση με κάποια σταθερά.
Μια ειδική περίπτωση που αναφέρθηκε νωρίτερα, ως βηματική μοναδιαία
ακολουθία, εκφράζεται σαν άθροισμα καθυστερημένων ακολουθιών:

\begin{equation}
\begin{align}
out[n] = \sum_{k=0}^{\infty} in[n-k]
\end{align}
\end{equation}
Η παραπάνω σχέση προκύπτει γιατί όλα τα μη μηδενικά στοιχεία της ακολουθίας
\(in[n]\) ισούνται με την μονάδα. Σημαντική θέση στην ανάλυση διακριτών συστημάτων
έχει και η εκθετική ακολουθία. Συχνά απλοποιεί τις πράξεις ειδικά για
συστήματα πέραν του ενός βαθμού ελευθερίας. Η γενική μορφή της εκθετικής
ακολουθίας φαίνεται παρακάτω:
\begin{equation}
\begin{align}
s[n] = Cb^{n}
\end{align}
\end{equation}
όπου \(C\) και \(b\) σταθερές που λαμβάνοντας πραγματικές τιμές
μετατρέπουν την έκφραση σε ακολουθία που λαμβάνει τιμές στο \(\mathbb{R}\).
Συνοπτικά οι εκθετικές μορφές σε συνδυασμό με ανάλογες τριγωνομετρικές
μορφές μπορούν να παρέχουν πληροφορία για την ταχύτητα διάδοσης ενός
σήματος, την μορφολογία της κυματομορφής αλλά και την ισχύ των συχνοτήτων
που μας ενδιαφέρουν. Η ισχύ στο παράδειγμά μας θα ήταν \(C\).
*** Συνδυάζοντας ακολουθίες
Ίσως από τις πιο συχνά αναλυμένες μορφές σημάτων αποτελούν  τα
ημιτονοειδή και συνημιτονοειδή. Η γενική μορφή ορίζεται
όπως θα δειχθεί παρακάτω και θα αναφερθούμε στην σχέση που αναδύεται από
τα μαθηματικά, της εκθετικής μορφής με την ημιτονοειδή.
\begin{equation}
\begin{align}
&y[n] = C \cos(\omega_{0}n + \phi) \\
\end{align}
\end{equation}
Η οποία ορίζεται για κάθε \(n\), με τις τιμές των \(C\)
και \(\phi\) να λαμβάνουν πραγματικές τιμές. Η εκθετική μορφή μιας ακολουθίας
μπορεί να γραφεί και ως \(C \cdod c^{n}\) με την μεταβλητή \(n\) να έχει φανταστικές
τιμές. Θα μπορούσαμε να γράψουμε την παραπάνω έκφραση στην μορφή:
\begin{equation}
\begin{align}
y[n] = |C||c|^{n} \cdot(\cos(\omega_{0}n+\phi)+ j\sin(\omega_{0}n+\phi)) \\
\end{align}
\end{equation}
Η παραπάνω εξίσωση ταλαντεύεται με εκθετικά αυξανόμενη κλήση αν η απόλυτη
τιμή της μεταβλητής \(c\) είναι μεγαλύτερη της μονάδας και με εκθετικά
μειούμενη στην αντίθετη περίπτωση όπου \(|c|<1\).

Στην περίπτωση που η μεταβλητή λάβει την τιμή 1, η σχέση χαρακτηρίζεται
ως φανταστική εκθετική ακολουθία και ικανοποιεί την παρακάτω συνθήκη.
\begin{equation}
\begin{align}
y[n] &= |C| e^{j(\omega_{0}n+\phi)} \\
&= |C|\cdot(\cos(\omega_{0}n+\phi)+ j\sin(\omega_{0}n+\phi)) \\
\end{align}
\end{equation}
Εδώ όπως και σε συνεχή συστήματα μπορούμε να χαρακτηρίσουμε την μεταβλητή
\(\phi\) ως την φάση του σήματος και αντίστοιχα \(\omega_{0}\) ονομάζεται κυκλική συχνότητα.
Παρατηρούμε πως η μεταβλητή \(n\) είναι αδιάστατο μέγεθος και επομένως η κυκλική
συχνότητα θα πρέπει να ορίζεται σε ακτίνια (\(rad\)). Αν απαιτείται περαιτέρω
ορισμός από τις ανάγκες της επεξεργασίας, υπάρχει δυνατότητα να ορίσουμε την
κυκλική συχνότητα σε ακτίνια ανά δείγμα \( \displaystyle \frac{rad}{sample}\) και ως \(n\) ο αριθμός των δειγμάτων
από την καταγραφή του σήματος. Όπως επισημαίνεται στη βιβλιογραφία εδώ φαίνεται
και η πρώτη διαφορά μεταξύ των συνεχών και διακριτών συστημάτων.

Αν υποθέσουμε ότι η φάση του σήματος ισούται με 2π τότε η εκθετική μορφή αποκτά
ψευδώνυμα συχνοτήτων που είναι μη διακριτά μεταξύ τους. Ένα απλό παράδειγμα
για την ημιτονοειδή μορφή φαίνεται παρακάτω:
\begin{equation}
\begin{align}
y[n]&&=C \cos[(\omega_{0} + 2\pi r)n + \phi] \\
&&=C \cos(\omega_{0}n + \phi) \\
\end{align}
\end{equation}
Οι εφαρμογές της ιδιότητας των διακριτών σημάτων να δημιουργούν αυτά τα ψευδώνυμα
ποικίλουν και θα αναφερθούν σε ένα πρώτο βαθμό στο κεφάλαιο της καταγραφής των
σημάτων. Εδώ γίνεται η παραδοχή πως η τιμή της συχνότητας θα πρέπει βρίσκεται
σε μια περιοχή που δεν θα επιτρέπει τέτοιες συμπεριφορές για απλοποίηση.
*** Συστήματα διακριτού χρόνου
Διακριτό σύστημα ορίζεται ως η μετατροπή που απαιτείται για την
ταύτιση του σήματος εξόδου με εκείνο της εισόδου. Σχηματικά
αναπαρίσταται συνήθως με ένα κουτί που αντιπροσωπεύει τις διεργασίες
που επιδέχεται το σήμα εισόδου για να έχουμε το επιθυμητό στην έξοδο.
Θα δειχθεί αργότερα πως οι τιμές του σήματος εξόδου για κάθε τιμή
της μεταβλητής \(n\) μπορεί να είναι εξαρτημένες από το σήμα εισόδου.
Στην συνέχεια φαίνεται η μαθηματική απεικόνιση ενός συστήματος που
δρα σε μια ακολουθία (σήμα εισόδου), για την εξαγωγή ενός δεύτερου
σήματος.
\begin{equation}
\begin{align}
out[n] = G\{in[n]\}
\end{align}
\end{equation}

Εδώ αξίζει να αναφερθεί μια έννοια που θα μας απασχολήσει ξανά στην
ενότητα κατασκευής φίλτρων. Πρόκειται για το σύστημα μεταβαλλόμενης μέσης
τιμής ή αλλιώς μέσης τρέχουσας τιμής. Η εμφάνισή της στην βιβλιογραφία
αναφορικά με την επεξεργασία σημάτων είναι εκτενής. Η διεργασία που
εφαρμόστηκε στην παρούσα περίπτωση  περιορίστηκαν στο φίλτρο μέσης
τρέχουσας τιμής ή \(F.I.R.\) με τα αρχικά να σημαίνουν \(Finite\ Impulse\ Response\).
Η παρακάτω γενική μορφή του προαναφερόμενου συστήματος με κάποιες
απλοποιήσεις που θα αναφερθούν σε επόμενο κεφάλαιο είναι η δομή του
φίλτρου μέσης τιμής.
\begin{equation}
\begin{align}
out[n] = \frac{1}{M_{1}+M_{2}+1}\sum_{k=-M_{1}}^{M_{2}} in[n-k]
\end{align}
\end{equation}
*** Γραμμικότητα συστημάτων
Τα συστήματα που εμφανίζουν γραμμική συμπεριφορά είναι εξ´ ορισμού
παραγόμενα από την αρχή της υπέρθεσης. Πιο συγκεκριμένα αν δύο διαδοχικές
τιμές του σήματος εισόδου παράγουν δυο αντίστοιχες τιμές εξόδου, το σύστημα
θα μπορεί να λέγεται γραμμικό αν και μόνο αν ισχύει ότι:
\begin{equation}
\begin{align}
G\{s_{1}[n]+s_{2}[n]\} = \\
&G\{x_{2}[n]\}+G\{x_{2}[n]\} = out_{1}[n] + out_{2}[n]
\end{align}
\end{equation}
και ταυτόχρονα να ικανοποιείται και η εξής ιδιότητα:
\begin{equation}
\begin{align}
G\{g \cdot s[n]\} = \\
&gG\{s[n]\} = g\cdot out[n]
\end{align}
\end{equation}
όπου \(g\) μια αυθαίρετη σταθερά. Οι ανωτέρω ιδιότητες μπορούν να συνδυαστούν,
ώστε να ικανοποιείται η αρχή της υπέρθεσης. Επιπρόσθετα υπάρχει δυνατότητα
εφαρμογής σε πολλαπλά σήματα εισόδου. Αν για παράδειγμα γνωρίζουμε πως ένα
σύστημα είναι γραμμικό \(F\{\cdot\}\) τότε μπορούμε να υποθέσουμε πως για κάθε έξοδο
του συστήματος θα ισχύει το εξής:
\begin{equation}
\begin{align}
in[n] = \sum_{z}b_{z}in_{z}[n] \\
&F\{in[n]\} = out[n] = \sum_{z}b_{z}out_{z}[n] \\
\end{align}
\end{equation}
Για να γίνει πιο κατανοητή η παραπάνω συμπεριφορά ας υποθέσουμε ένα λογαριθμικό
σύστημα,
\begin{equation}
\begin{align}
r[u] = \log_{10}(|x[u]|)
\end{align}
\end{equation}
και ας πάρουμε δύο τιμές για την ακολουθία \(x_{1}[\cdot]\) και \(x_{2}[\cdot]\) να ισούνται με 1 και 10
αντίστοιχα. Αυτό σημαίνει ότι τα σήματα εξόδου θα πρέπει, ικανοποιώντας την
ιδιότητα της ομογένειας, να απέχουν δέκα μονάδες μεταξύ τους όσο δηλαδή και
τα σήματα εισόδου \((x_{2}=10x_{1})\). Όπως είναι προφανές κάτι τέτοιο δεν ισχύει
στην συγκεκριμένη περίπτωση, αφού \(\log1=0,\ \log10=1\).

Η ενότητα αυτή θα μπορούσε να γεμίσει το περιεχόμενο της παρούσας εργασίας
και άλλες τόσες μαζί. Έχουν γραφεί πολλά βιβλία που αναλύουν το ζήτημα, ένα
από τα αναλυτικότερα φέρει τίτλο \(Discrete-Time\ Signal\ Processing\) των \(Alan\ Oppenheim\) και
\(Ronald\ Schafer\) παρέχοντας στον αναγνώστη εκτεταμένες βάσεις για την επεξεργασία
και μαθηματική αναπαράσταση σημάτων και συστημάτων. Εδώ αναφέρθηκαν οι βασικές
έννοιες και αρχές, με σκοπό την καλύτερη κατανόηση της καταγραφής και της
απομείωσης θορύβου σε σήματα. Στην συνέχεια θα ασχοληθούμε με την καταγραφή
ψηφιακών σημάτων και μερικά από τα σημαντικά προβλήματα κατά την διαδικασία.
* Καταγραφή σημάτων
** Φαινόμενα καταγραφής
    Σε αυτή την ενότητα θα περιγραφούν οι βασικές θεωρίες που χρησιμοποιούνται
για την ψηφιακή καταγραφή και επεξεργασία σημάτων καθώς και κάποια προβλήματα
που μπορεί να εμφανιστούν κατά τις διαδικασίες αυτές. Μια από τις σημαντικότερες
θεωρίες είναι του Φυσικού και Ηλεκτρολόγου Μηχανικού \(Harry\ Nyquist\),
όπου θα αναφερθεί στη συνέχεια. Επίσης θα αναφερθούμε σε διαστρεβλώσεις
και καταστρεπτικές συμπεριφορές των συστημάτων κατά την μετατροπή τους από
συνεχή σε διακριτά σήματα και σε τρόπους αναγνώρισης και αντιμετώπισης
των προβλημάτων. Θα παρατεθεί ο συνήθης τρόπος απόκτησης ενός διακριτού σήματος
από την καταγραφή σημάτων συνεχούς χρόνου, όπως επίσης και ο τρόπος που αυτό γίνεται
εφικτό από συστήματα καταγραφής σε Η/Υ.
*** Μέθοδος καταγραφής
Ο πιο συνήθης τρόπος εξαγωγής ενός διακριτού σήματος είναι μέσω της περιοδικής
καταγραφής κάποιου συνεχούς σήματος. Στην πράξη αυτό σημαίνει πως καταγράφεται
μία τιμή του σήματος εισόδου σε ένα σύστημα ανά προκαθορισμένο χρονικό διάστημα,
το οποίο ονομάζεται περίοδος καταγραφής του σήματος σε μονάδες δευτερολέπτου.
Διαιρώντας την μονάδα (δείγμα) με την περίοδο αποκτούμε την συχνότητα καταγραφής ορισμένη
σε δείγμα ανά δευτερόλεπτο \(\displaystyle \frac{sample}{sec}\). Το σύστημα που εκτελεί την συγκεκριμένη
επεξεργασία ονομάζεται μετατροπέας αναλογικού σε διακριτό σήμα (\(D.A.C.\))
και σε σημερινές συσκευές καθίσταται σχεδόν υποχρεωτική η χρήση του για
πολλούς λόγους. Ένα παράδειγμα αποτελεί η ανάγκη για ανάγνωση αισθητήριων
οργάνων και εκτέλεση προδιαγεγραμμένων εντολών σύμφωνα με την τιμή εισόδου.
Σε αυτή την περίπτωση ένας μικρο-ελεγκτής δεν διαθέτει την δυνατότητα
ανάγνωσης και επεξεργασίας αναλογικών σημάτων και επομένως η μετατροπή του
σε διακριτό σήμα υπό κάποια συχνότητα καταγραφής αποτελεί μονόδρομο.

Μετά την περιοδική καταγραφή, είναι αδύνατο να ανακτηθεί επακριβώς το αρχικό
αναλογικό σήμα. Αίτιο αποτελεί το γεγονός πως πολλά αναλογικά σήματα μπορούν
να έχουν όμοια αναπαράσταση διακριτών *παράγωγων*. Το συγκεκριμένο
φαινόμενο αποτελεί θεμελιώδες πρόβλημα στον τομέα της ανάλυσης ψηφιακών
σημάτων, όμως αργότερα θα δειχθεί πως είναι δυνατός ο περιορισμός της εν' λόγω
συμπεριφοράς καθορίζοντας το πλήθος των δειγμάτων. Στην συνέχεια θα αναφερθούμε
στην βασική *αρχή* που μας επιτρέπει να καταγράφουμε τα αναλογικά σήματα με
τρόπο που αποτυπώνει όλη την πληροφορία που εμπεριέχουν. Σημασία δίνεται στην
έννοια της πληροφορίας καθώς ο σκοπός χρήσης των σημάτων είναι η κωδικοποίηση
αυτής, όπως ήδη έχει αναφερθεί στην εισαγωγή.
*** Θεώρημα δειγματοληψίας
Στο θεώρημα καταγραφής σημάτων ορίζεται η ελάχιστη συχνότητα δειγματοληψίας με
σκοπό την δυνατότητα ανακατασκευής του αρχικού αναλογικού σήματος. Ο ορισμός αναφέρει
πως, αν ένα συνεχές σήμα δεν περιέχει πληροφορία πάνω από κάποια συχνότητα Α σε
\(Hz\), τότε για να είναι δυνατή η ανάκτηση της αρχικής κυματομορφής θα πρέπει να
ισχύει ότι:
\begin{equation}
\begin{align}
f_{s} \geq 2A \\
\end{align}
\end{equation}

Από τον παραπάνω ορισμό προκύπτει πως απαιτούνται ταυτόχρονα δύο ζητήματα. Το
πρώτο καθορίζει κάποιο ελάχιστο όριο για την συχνότητα καταγραφής, που προκύπτει
από την μέγιστη συχνότητα του αναλογικού σήματος. Το δεύτερο αναφέρεται σε
ανακατασκευή του αρχικού, χωρίς να προσδιορίζει την μέθοδο που θα χρησιμοποιηθεί.

Τα σήματα που παρουσιάζουν απουσία πληροφορίας σε ορισμένες συχνότητες ονομάζονται
*περιορισμένου φάσματος*. Τέτοια συμπεριφορά έχουν σήματα χαμηλών συχνοτήτων που δεν
εμφανίζουν ισχύ σε συχνότητες άνω των 200 \(Hz\). Αντίστοιχα υπάρχουν σήματα που
εμπεριέχουν πληροφορία σε ένα ορισμένο εύρος, από 7 έως 10 \(kHz\). Και τα δύο αυτά
σήματα κατηγοριοποιούνται ως *σήματα περιορισμένου φάσματος*.

Ιδιαίτερο ενδιαφέρον παρουσιάζει το γεγονός πως το συγκεκριμένο θεώρημα αναφέρεται
στην βιβλιογραφία με το προσωνύμιο Θεώρημα Δειγματοληψίας \(Shannon\), ενώ
η πρώτη αναφορά γίνεται από τους Βρετανούς μαθηματικούς \(E.T.\) και \(J.M.\)
\(Whittaker\) και \(Ferrar\). Στην Ρωσία το θεώρημα κατεγράφη από τον
\(Kotel'nikov\) και πήρε το όνομά του από εκείνον. Ο \(Shannon\)
το χρησιμοποίησε για την έρευνα που σήμερα μας είναι γνωστή η θεωρία της
πληροφορίας, και γι' αυτό πολλές φορές στην μαθηματική βιβλιογραφία
αναφέρεται και θεώρημα δειγματοληψίας \(WKS\) από τα αρχικά των παραπάνω.
*** Αναπαράσταση στο πεδίο συχνοτήτων
Το θεώρημα της δειγματοληψίας μπορεί να αποδειχθεί μαθηματικά. Όμως
οι ιδιότητες και οι αιτίες που το προκαλούν φαίνονται πιο ξεκάθαρα
εξετάζοντας την διαδικασία της μετατροπής αναλογικού σε διακριτό σήμα
μεταφρασμένο στο πεδίο των συχνοτήτων. Αν αυθαίρετα υποθέσουμε πως ένα
καταγεγραμμένο ψηφιακό σήμα είναι αναλογικό, οι απότομες διακυμάνσεις
στην ισχύ του σήματος προσθέτουν στοιχεία στην ακολουθία υψηλών
συχνοτήτων που προσθέτονται τελικά στο σήμα. Η καταγραφή λοιπόν ενός
αναλογικού σήματος μπορεί να παρομοιαστεί με δραστικό τεμαχισμό του
αρχικού.

Ως παράδειγμα μπορεί να χρησιμοποιηθεί μια ημιτονοειδής συνάρτηση
σχετικά απλή ώστε να γίνει κατανοητή η παραπάνω συμπεριφορά. Έστω
πως για ένα συνεχές σήμα εφαρμόζουμε την μέθοδο της δειγματοληψίας
ως εξής:
\begin{equation}
\begin{align}
x(t)&=\cos(2 \pi f_{z}t + \phi),\ t=cT,\ c \in [0, +\infty),\ c \in \mathbb{Z} \Rightarrow \\
&x(cT) = \cos(2 \pi f_{z} cT + \phi) \\
\end{align}
\end{equation}
Ας δούμε τώρα τι συμβαίνει σε περίπτωση που υπολογίσουμε την τιμή
του καταγεγραμμένου σήματος σε συχνότητα ίση με \(f_{tot} = f_{z}+f_{s}\):
\begin{equation}
\begin{align}
x_{a}(cT) &= \cos(2 \pi cT \cdot (f_{z}+f_{s})+ \phi) \Rightarrow \\
&= \cos(2 \pi cf_{z}T + 2 \pi c + \phi) \Rightarrow \\
&= \cos(2 \pi cf_{z}T + \phi) \Rightarrow \\
&= x(cT)
\end{align}
\end{equation}
Όπως φαίνεται για κάθε δείγμα εγγραμμένο με κάποια συχνότητα
πολλαπλάσια από εκείνη της καταγραφής \(f_{s}\), το σήμα εμπεριέχει στοιχεία
στο συγκεκριμένο φάσμα. Στην περίπτωση που δεν ικανοποιείται το θεώρημα
της δειγματοληψίας προκύπτει η λεγόμενη αλλοίωση προσθέτοντας αναληθή
δείγματα στο σήμα ή αλλιώς *ψευδώνυμα συχνοτήτων*. Η καταστρεπτική αυτή
συμπεριφορά θα αναλυθεί στην παρακάτω ενότητα ενώ αξίζει να σημειωθεί
πως υπάρχει πιθανότητα να υποφέρουν και οι πειραματικές μετρήσεις του
εργαστηρίου από το φαινόμενο αυτό καθώς η μέγιστη συχνότητα καταγραφής
που επιτεύχθηκε ήταν στα 500 \(kHz\).
*** Αλλοίωση
Ως αλλοίωση αναφερόμαστε εδώ στο αποτέλεσμα καταγραφής ενός σήματος,
όπου η έξοδος αποτελείται από διαφορετικά σήματα και δεν είναι δυνατό να
επαναδημιουργιθεί το αρχικό. Συνήθως η έξοδος είναι μετατοπισμένη ως
προς το φάσμα των συχνοτήτων, όμως πολλές φορές επηρεάζεται και η ισχύ.
Είναι λοιπόν σημαντικό να αποφευχθεί, όσο το δυνατόν περισσότερο, η
αλλοίωση των σημάτων κατά την διαδικασία καταγραφής τους. Για τον λόγο
αυτό συνήθως εφαρμόζεται ένα φίλτρο χαμηλών συχνοτήτων ή φίλτρο κατά της
αλλοίωσης $\en{AAF}$.

Στην ελληνική βιβλιογραφία το φαινόμενο αυτό αναφέρεται ως *ψευδώνυμα συχνοτήτων*
και ερευνήθηκε από τους $\en{Harry\ Niquist}$ και $\en{Claude\ Shannon}$ ερευνητές στα
$\en{Bell\ Labs}$,
οι οποίοι συνέβαλαν σημαντικά στον τομέα των τηλεπικοινωνιών και την καταγραφή
σημάτων. Άλλωστε το θεωρητικό υπόβαθρο για την καταγραφή *ψηφιακών σημάτων* απαλλαγμένων
από ψευδώνυμα αναπτύχθηκε από τους δύο κατά τις δεκαετίες 1920-1950.
Στην εργαστηριακή εγκατάσταση που εξετάστηκε ήταν αδύνατο να αποφευχθεί η εμφάνισή
τους, όμως χρησιμοποιήθηκε η μέθοδος της επεξεργασίας σημάτων πολλαπλών συχνοτήτων
καταγραφής. Στην συγκεκριμένη μέθοδο θα αναφερθούμε επιγραμματικά στην συνέχεια,
όμως αξίζει να αναφερθεί ότι δίνει την δυνατότητα εντοπισμού των αλλοιώσεων
αποδεκατίζοντας το σήμα σύμφωνα με μία σταθερά και εξετάζοντας την γραφική του
παράσταση σε σχέση με την αρχική καταγραφή. Όσο μειώνεται ο αριθμός των δειγμάτων
το σήμα καταστρέφεται ηθελημένα, παράγοντας ψευδώνυμα συχνοτήτων τα οποία θα πρέπει
να είναι όλα διαφορετικά.

#+attr_latex:  :width 250px
#+attr_latex:  :height 140px
#+ATTR_LATEX: :caption \caption{Φαινόμαινο αλλοίωσης σήματος μετά την καταγραφή του.}
[[./aliasing_from_downsampling.png]]

Το συμπέρασμα αυτό προέκυψε χρησιμοποιώντας μια μέθοδο που εντάσσεται στην κατηγορία
της επεξεργασίας σημάτων πολλαπλών συχνοτήτων, μεταβάλλοντας την συχνότητα καταγραφής
αφαιρώντας πλήθος δειγμάτων, και συγκρίνοντας τις γραφικές παραστάσεις στα πεδία
συχνοτήτων και χρόνου.
Την απόρριψη του συγκεκριμένου τύπου “θορύβου” στις σύγχρονες συσκευές αναλαμβάνουν
ειδικά φίλτρα που ονομάζονται  $\en{F.I.R.}$. Αντίστοιχα φίλτρα χρησιμοποιήθηκαν και στην
επεξεργασία των δεδομένων και συγκρίθηκαν τα αποτελέσματα με άλλους τύπους όπως θα
δούμε παρακάτω.

Τα ψευδώνυμα αυτά εμφανίζονται σε υποδειγματοληπτημένα σήματα. Αν είναι επιθυμητό
να εξεταστεί ένα σήμα που μπορεί να εμπεριέχει θόρυβο σε συχνότητες 2-3 \(kHz\), τότε για
την αποφυγή της αλλοίωσης ή αναδίπλωσης του σήματος θα πρέπει η καταγραφική συσκευή
να έχει την δυνατότητα καταγραφής τουλάχιστον 6 \(kHz\). Στο πλαίσιο της επεξεργασίας των
μετρήσεων της αεροσήραγγας που η μέγιστη καταγραφή αγγίζει τα 500 \(kHz\), το μέγιστο
φάσμα σήματος που μπορούσε να εξεταστεί είναι 250 \(kHz\). Έτσι υπήρχε ανάγκη για
περαιτέρω εξέταση και την λύση παρέχει η μέθοδος του αποδεκατισμού. Εφαρμόζοντας την
εξάγοντας κάθε φορά διαφορετικό αριθμό δειγμάτων από το αρχικό, μας δίνεται η
δυνατότητα να συγκρίνουμε τα σήματα και να υποθέσουμε τυχών επιρροή που μπορεί να
έχουν συχνότητες μεγαλύτερες από εκείνες της συχνότητας καταγραφής. Στο διάγραμμα
που ακολουθεί φαίνεται ένα σήμα στο πεδίο της συχνότητας αποδεκατισμένο επιλέγοντας
κάθε 100ο στοιχείο της αρχικής ακολουθίας.

#+attr_latex: :height 280px
#+attr_latex: :width 500px
#+ATTR_LATEX: :caption \caption{Αποδεκατισμένο σήμα ανά 100 δείγματα (5 \(kHz\)) μαζί με το αρχικά καταγεγραμμένο σε μικρότερη συχνότητα 5 \(kHz\) σε σύγκριση με εκείνο στα 500 \(kHz\).}
[[file:./decimation/with_aliasing.png]]
** Μείωση αριθμού δειγμάτων
Η τεχνική αυτή εφαρμόζεται σε ψηφιακά σήματα με πολλά δείγματα ανά
χρονικό διάστημα που όμως η τυπική απόκλιση προδίδει μια περιοδική
κίνηση που σχετίζεται με ταλάντωση. Τότε είναι εύλογο να χωριστεί το
σήμα σε μικρότερα “κομμάτια”. Αυτό έχει σαν αποτέλεσμα την ταχύτερη
ανάλυση των δεδομένων και την ευελιξία της επιλογής ομάδων σε συνάρτηση
με τον χρόνο ή κάποιο άλλο κριτήριο. Εφαρμόζεται συχνά στην
καθημερινότητά μας, καθώς η συμπίεση αρχείων και τα πρότυπα αρχεία ήχου
και εικόνας συμπεριλαμβάνουν μία ή και περισσότερες διαδικασίες μείωσης
του αριθμού των δειγμάτων.

Στην επεξεργασία ψηφιακών σημάτων οι όροι μείωση αριθμού δειγμάτων,
αποδεκατισμός και συμπίεση μπορεί να έχουν ταυτόσημα νοήματα ή μπορεί να
περιγράφουν την απομείωση συχνοτήτων και απόρριψη αριθμού δειγμάτων σε
ένα σύστημα ψηφιακής καταγραφής σημάτων πολλαπλών συχνοτήτων. Αργότερα
θα αναλυθεί η σημασία τέτοιων συστημάτων.
*** Ορισμός
Αποδεκατισμός ενός ψηφιακού σήματος σημαίνει η αποθήκευση τελικώς του
κάθε 10ου π.χ. δείγματος από το αρχικό καταγεγραμμένο σήμα με συγκεκριμένη
συχνότητα καταγραφής. Αυτό έχει επεκταθεί ορίζοντας τον αποδεκατισμό
κατά έναν παράγοντα που συνήθως είναι σταθερός αριθμός και μπορεί να
λάβει ακέραιες και δεκαδικές τιμές.

Εδώ αξίζει να σημειωθεί η ανάγκη να λαμβάνει ο παράγοντας αυτός μια
λογική τιμή, για παράδειγμα ένα ψηφιακό σήμα που έχει διάρκεια πέντε
(5) δευτερόλεπτα και καταγράφηκε από συσκευή που είχε συχνότητα
καταγραφής 20 $\en{Hertz}$ ένας παράγοντας 101 προφανώς δεν θα άφηνε κανένα
δείγμα στο νέο ψηφιακό σήμα. Επιπρόσθετα το όριο για να αποφύγουμε την
αλλοίωση απαιτεί το τελικό αποτέλεσμα των διαδικασιών είναι τα 10
δείγματα ανά δευτερόλεπτο (10 $\en{Hz}$). Επομένως θέτοντας τον παράγοντα
αποδεκατισμού 51 θα παρείχε ένα σήμα που θα ήταν αλλοιωμένο.Όταν η
διαδικασία αυτή εφαρμόζεται σωστά σε μια αλληλουχία δειγμάτων ενός σήματος
ή μιας συνεχούς συνάρτησης, παράγεται μια προσομοίωση του καταγεγραμμένου
με μικρότερη συχνότητα.
*** Ένα φίλτρο ως παράδειγμα
Όταν το φίλτρο κατά της αλλοίωσης είναι σχεδιασμένο με πρότυπο $\en{IIR}$, τα
οποία θα αναλυθούν παρακάτω, η διαδικασία βασίζεται στην ανάδραση της
εξόδου στην είσοδο του φίλτρου πριν την έναρξη του δεύτερου σταδίου. Για
το πρότυπο σχεδιασμού $\en{FIR}$ είναι εύκολο να υπολογιστεί για κάθε Μ εξόδου.
Ο υπολογισμός που γίνεται από ένα τέτοιο φίλτρο αποδεκατισμού για κάθε
νιοστή έξοδο δείγματος φαίνεται παρακάτω.

\begin{equation}
y[n]=\sum_{k=0}^{K-1}x[nM-k] \cdot h[k],
\end{equation}


Όπου η ακολουθία $\en{h}$[•] είναι η απόκριση του κρουστικού παλμού ($\en{impulse\ response}$)
, και K είναι το μήκος. Η $\en{x}$[•] αντιπροσωπεύει το σήμα εισόδου
εξαγόμενο από το φίλτρο με λιγότερα δείγματα.
Σε επεξεργαστές γενικής χρήσης μετά τον υπολογισμό της παραπάνω εξίσωσης
για κάποιον αριθμό $\en{n}$, ο ευκολότερος τρόπος να υπολογιστεί το $\en{y[n+1]}$
είναι η καθυστέρηση της αρχής της ακολουθίας $\en{x}$[•] κατά Μ, και να λυθεί
το παραπάνω άθροισμα ξανά. Αν ο παράγοντας Μ=2, η συνάρτηση $\en{h}$[•] μπορεί
να αντιπροσωπεύει ένα φίλτρο μισών συχνοτήτων, όπου σχεδόν το μισό πλήθος
των δειγμάτων του αρχικού σήματος θα είναι μηδενικής ισχύος ($\en{amplitute}$)
και δεν θα συμπεριληφθούν στο προϊόν πολλαπλασιασμού.
Οι *τιμές* της απόκρισης του παλμού κατά διαστήματα Μ δημιουργούν
υποαληλλουχίες, πλήθους Μ περιπλεγμένες μεταξύ τους.Το παράγωγο του
πολλαπλασιασμού είναι η πρόσθεση των προϊόντων από τον πολλαπλασιασμό
κάθε υποαληλλουχίας με το καταγεγραμμένο σήμα $\en{x}$[•]. Επιπρόσθετα λόγω
της μείωσης του πλήθους των δειγμάτων στο σήμα κατά Μ, κάθε σήμα που
χρησιμοποιήθηκε στον προηγούμενο υπολογισμό κάποιου Μ προϊόντος δεν θα
επαναληφθεί σε επόμενο υπολογισμό. Αυτός είναι και ο λόγος που τα φίλτρα
μικρής τάξης Μ $\en{FIR}$ φιλτράρουν μια από τις αλληλουχίες της εισόδου κάθε
φορά και τα Μ προϊόντα προσθέτονται για να κατασκευαστεί το σήμα εξόδου.
Αυτή η μέθοδος εφαρμόζεται σε συστήματα πολλαπλών επεξεργαστών, όπου ένα
σήμα χωρίζεται σε φάσεις και φιλτράρεται ξεχωριστά από Μ αριθμό φίλτρων
και τελικά προσθέτονται για την δημιουργία του σήματος εξόδου. Τα παραπάνω
φίλτρα ονομάζονται και πολυφασικά.

Για εγκυκλοπαιδικούς λόγους αξίζει να σημειωθεί πως είναι πιθανό σε κάθε
φάση του υπολογισμού να αντικαθιστούμε τις τιμές της προηγούμενης φάσης
με μηδενικές τιμές, σε ένα αντίγραφο της αλληλουχίας $\en{h}$[•], ώστε να
επεξεργαστεί το αρχικό σήμα στην συχνότητα εισόδου (πολλαπλασιάζοντας
με 0) και αποδεκατίζοντας την έξοδο κατά έναν παράγοντα Μ. Η παραπάνω
διαδικασία ονομάστηκε στα αγγλικά $\en{the\ first\ Noble\ identity}$ και εφαρμόζεται σε
διάφορες πολυφασικές μεθόδους.
* Σχεδιασμός Φίλτρων
** Κατηγορίες
Λόγω των πολλών εφαρμογών που έχουν και την εκθετική αύξηση της χρήσης
ηλεκτρονικών συσκευών στην καθημερινότητα, οι δυνατότητες επεξεργασίας
ψηφιακών σημάτων αποτελεί πρακτικά απαραίτητη προϋπόθεση. Έτσι η ανάγκη
για την ανάπτυξη διαφόρων τύπων φίλτρων π.χ. το φίλτρο μέσης τρέχουσας
τιμής ($\en{F.I.R.}$), το φίλτρο άπειρης κρουστικής απόκρισης ($\en{I.I.R.}$) και το μεσιανό
φίλτρο \((median\ filters)\) έγινε εμφανής από το στάδιο ακόμα της ανάπτυξης
του ραδιοφώνου. Στην συνέχεια θα αναφερθούμε και στις τρεις αυτές
κατηγορίες αναφέροντας παραδείγματα από τις μεθόδους που χρησιμοποιήθηκαν
στην ανάλυση των δεδομένων από την *εργαστηριακή εγκατάσταση* ? ...
Η γενική διαφοροποίηση που γίνεται αρχικά είναι ως προς το εύρος
συχνοτήτων που επηρεάζουν. Έτσι αν απορρίπτονται οι ύψηλες συχνότητες, το
φίλτρο ονομάζεται διέλευσης χαμηλών συχνοτήτων ($\en{low-pass\ filter}$)
ενώ το αντίστροφο ονομάζεται φίλτρο διέλευσης υψηλών συχνοτήτων ($\en{high-pass\ filter}$).
Αν το φίλτρο επηρεάζει μία περιοχή ή *φάσμα* συχνοτήτων και
απορρίπτει όσες βρίσκονται πριν και μετά, ονομάζεται φίλτρο απόρριψης
εύρους συχνοτήτων ($\en{band-pass\ filter}$).
** Φίλτρο μέσης τρέχουσας τιμής
Στα προηγούμενα κεφάλαια επικεντρωθήκαμε περισσότερο στην μαθηματική αναπαράσταση
των σημάτων με μια μικρή αναφορά στα γραμμικά συστήματα. Τα φίλτρα αποτελούν γραμμικά
συστήματα και ως εκ τούτου αντιμετωπίζονται λαμβάνοντας υπόψη τις ανάλογες ιδιότητες
και συμπεριφορές. Σκοπός σχεδιασμού αυτών των συστημάτων αποτελεί η αφαίρεση στοιχείων
από κάποιο σήμα, ή η τροποποίηση προκαθορισμένων χαρακτηριστικών του. Εδώ θα αναφερθούμε
στην κατηγορία των συστημάτων πεπερασμένης κρουστικής απόκρισης, ή όπως θα αποκαλούνται
στην συνέχεια για συντομία \(F.I.R.\). Για αρχή μπορούμε να φανταστούμε πως η έξοδος του
φίλτρου παράγεται αθροίζοντας ένα πεπερασμένο αριθμό δειγμάτων όπου εφαρμόζουμε κάποιο
“βάρος στάθμισης”. Στόχος των επόμενων ενοτήτων είναι ο προσδιορισμός των βασικών αρχών
πού διέπουν τα διακριτά συστήματα και την εφαρμογή τους στον σχεδιασμό των \(F.I.R.\). Θα
επανέλθουμε στον όρο της γραμμικότητας και θα αναφερθούμε και στην χρονική αμεταβλητότητα
που συνδυασμένες καλύπτουν ένα ευρύ φάσμα της εν' λόγω κατηγορίας.
*** Μέση τρέχουσα τιμή και σχεδιασμός συστήματος
Ένας από τους πιο διαδεδομένους τρόπους μετασχηματισμού σημάτων είναι ο υπολογισμός
της μέσης τιμής για δύο ή παραπάνω δειγμάτων, με σκοπό την αφαίρεση έντονων στιγμιαίων
διακυμάνσεων του σήματος γύρω από κάποια επιθυμητή τιμή. Λόγω της πληθώρας αλγόριθμων
για των υπολογισμό μέσης τιμής ακολουθιών είναι από τις πιο συχνά εφαρμοσμένες τεχνικές
στον τομέα της οικονομικής επιστήμης και πιο συγκεκριμένα στην μακροχρόνια ανάλυση των
τιμών μετοχής σε χρηματιστήριο. Με απλά λόγια αν κάποιος επιθυμεί να εξετάσει την
ανοδική ή καθοδική πορεία μιας μετοχής δεν τον αφορά η αυξομείωση της τιμής ανά ημέρα,
πόσο μάλλον ανά δευτερόλεπτο. Τα τελευταία δεκαδικά όμως αλλάζουν κάθε δευτερόλεπτο, σε
πραγματικό χρόνο και επομένως εφαρμόζεται ένα φίλτρο μέσης τρέχουσας τιμής στις τιμές
ώστε να είναι δυνατή η αξιοποίηση της πληροφορίας των μεταβολών με μικρότερη απόκλιση,
από την μέση τιμή.

Για να γίνει πιο κατανοητό ας υποθέσουμε πως ένα ψηφιακό σήμα μπορεί να αναπαρασταθεί
ως \(in[z]\). Εφαρμόζεται ένα σύστημα φίλτρου όπως το παραπάνω υπολογίζοντας τον μέσο όρο από
πέντε δείγματα την φορά. Τότε για κάθε δείγμα της ακολουθίας εξόδου του συστήματος θα
ισχύει ότι:
\begin{equation}
\begin{align}
out[n] = \frac{1}{k} \cdot \sum_{z}^{{k-1}}in[n+z], k=5 \\
\end{align}
\end{equation}
Η σχέση (7.1) ονομάζεται και σχέση διαφορών και αποτελεί πλήρη περιγραφή ενός *συστήματος
\(F.I.R\)*, δίνοντας την δυνατότητα στον χρήστη να εξάγει πληροφορία για κάθε τιμή του σήματος
εισόδου \(in[n]\). Όσο για τον προσδιορισμό της αρχικής τιμής της μεταβλητής \(z\) τις περισσότερες
φορές επιλέγεται η τιμή μηδέν με σκοπό να συμπεριλάβουμε το πρώτο δείγμα της εισόδου
στο οποίο αναφερόμαστε εδώ και στην συνέχεια ώς \(in[0]\). Το δείγμα που λαμβάνεται σαν “αρχικό”,
για \(n = 1,\ 2,\ 3,\ ... \) μπορούμε να το χαρακτηρίσουμε και ως το παρόν του σήματος. Αντίστοιχα τα
δείγματα που έπονται αυτού, και χρησιμοποιούνται στο παραπάνω σύστημα για τον υπολογισμό
της εξόδου συνθηκολογώντας αναφέρονται στην βιβλιογραφία ως μέλλον του σήματος. Η
συγκεκριμένη οπτική εντάσσει την έννοια των “παραθύρων” καθώς ένα συρόμενο παράθυρο, πέντε
τιμών συνεχίζοντας το παράδειγμα, θα ορίσει τις επιλεγμένες τιμές για τον υπολογισμό του
σήματος εξόδου \(out[n]\).
*** Σχεδιασμός και εφαρμογή φίλτρων
Ένα \(F.I.R.\) φίλτρο κατασκευάζεται από την γενική εξίσωση διαφορών που θα δούμε παρακάτω,
όμως αξίζει να αναφέρουμε ένα χαρακτηριστικό. Τα που φίλτρα κατασκευάζονται χρησιμοποιώντας
στοιχεία του παρελθόντος από το σήμα εισόδου για τον υπολογισμό της μέσης τιμής και
έχει επικρατήσει η ονομασία αιτιατό φίλτρο. Με την συγκεκριμένη έκφραση εννοούμε πως
η αιτία που καθορίζει το αποτέλεσμα δεν προηγείται αυτού. Αντίστοιχα τα φίλτρα που
βασίζονται σε στοιχεία που προπορεύονται του εξεταζόμενου στοιχείου ονομάζονται μη
αιτιατά. Ας δούμε την γενική εξίσωση που καθορίζει ένα φίλτρο όπως ορίστηκε παραπάνω,
για κάποιο αιτιατό φίλτρο μέσης τρέχουσας τιμής.
\begin{equation}
\begin{align}
out[x] = \sum_{z=0}^{{T}} a_{z} in[x-z] \\
\end{align}
\end{equation}

Γίνεται λοιπόν αντιληπτό πως λόγω του πεπερασμένου πεδίου ορισμού του σήματος εισόδου,
λόγω της διακριτότητας του φάσματός του, θα υπάρχουν στοιχεία κατά τον υπολογισμό των
αρχικών δειγμάτων εξόδου σε ένα παράθυρο αντίστοιχο εκείνο του αριθμού Τ που βασίζονται
σε λιγότερα από πέντε στοιχεία. Αυτό στις εφαρμογές των φίλτρων προβλέπεται και κατ'
επέκταση δίνεται η δυνατότητα ο δείκτης \(z\) να λάβει αρνητικές τιμές. Στην αρχή μοιάζει
παράδοξο καθώς δεν μπορεί στην φύση να υπάρξει αρνητικός αριθμός δειγμάτων, όμως μας
δίνει την δυνατότητα να εφαρμόζουμε σχετικά μεγάλα παράθυρα, χωρίς τον φόβο διαστρέβλωσης
της εξόδου.

Ένα φίλτρο για να οριστεί πλήρως είναι απαραίτητο να γνωρίζουμε με σαφήνεια όλες τις
τιμές των συντελεστών του, δηλαδή των \(a_{z}\) στο παράδειγμα που ορίστηκε το αιτιατό φίλτρο.
Υποθέτοντας τις παρακάτω τιμές για το σύνολο αυτό μπορούμε να γνωρίζουμε την εξίσωση
που περιγράφει το ανάλογο φίλτρο, π.χ.:
\begin{equation}
\begin{align}
\{a_{z}\} = \{5,\ -7,\ 2,\ 1,\ 9\} \Rightarrow \\
out[x] &= \sum_{z=0}^{4}a_{z}in[x-z] \\
&= 5in[x] - 7in[x-1] + 2in[x-2] + in[x-3] +9in[x-4]
\end{align}
\end{equation}
Όπως φαίνεται είμαστε σε θέση να υπολογίσουμε το σήμα εξόδου για κάθε τιμή της εισόδου.
Ο αριθμός Τ ονομάζεται τάξη του φίλτρου ενώ το πλήθος των συντελεστών ονομάζεται μήκος ή
μέγεθος. Οι έννοιες αυτές προέρχονται από τον μετασχηματισμό \(z\), μέθοδος η οποία  ξεπερνά
το πλαίσιο της παρούσας εργασίας, όμως ας συνδέσουμε το μήκος με την ταχύτητα υπολογισμού
του φίλτρου ενώ την τάξη με την μεταβολή της ταχύτητας κατακρημνισμού της εξίσωσης του
φίλτρου ή όπως ονομάζεται στα περισσότερα όργανα ηλεκτρονικής μουσικής \(release\ value\).
*** notes :noexport:
convolution sum == αθροισμα συνέλιξης
- να προστεθεί
  [[file:../books/ScienceDirect_articles_18Feb2023_15-57-03.874/6---Finite-impulse-response-filter-des_2003_Practical-Digital-Signal-Process.pdf][fir intro]]
- output sequence

  \begin{equation}
  \begin{align}
  y(n)=\sum_{m=0}^{M}x(m)h(n-m)
  \end{align}
  \end{equation}
** Φίλτρο άπειρης κρουστικής απόκρισης
Τα φίλτρα άπειρης κρουστικής απόκρισης είναι όπως προδίδει και το όνομά τους
ακριβώς το αντίθετο από εκείνα της πεπερασμένης . Πρακτικά αυτό σημαίνει
πως η διάρκεια της κρουστικής απόκρισης είναι άπειρη. Αυτό συμβαίνει καθώς ο
υπολογισμός γίνεται χρησιμοποιώντας την μέθοδο της ανάδρασης, αξιοποιώντας την
έξοδο του φίλτρου για την επανατροφοδότηση της εισόδου. Η γενική εξίσωση της
παρούσας κατηγορίας έχει την μορφή:
\begin{equation}
\begin{align}
out[z] = \sum_{f=0}^{\infty}u(f)in(z-f) \\
\end{align}
\end{equation}

Όπως είναι φανερό η διαφορά εδώ είναι πως το άνω όριο της πρόσθεσης προσεγγίζει
το άπειρο, σε θεωρητικό επίπεδο τουλάχιστον. Αυτό συμβαίνει γιατί η απόκριση
της ακολουθίας \(u\) διαθέτει άπειρη διάρκεια. Έτσι όπως θα δειχθεί αμέσως μετά,
ο υπολογισμός με την μέθοδο της συνέλιξης καθίσταται μη πρακτικός και εφαρμόζεται
αναδρομή. Για να γίνει πιο κατανοητή η έννοια της αναδρομής ας δούμε ένα
παράδειγμα που, κατά την σωστή εφαρμογή του, απαιτούνται I+T+1
πολλαπλασιασμοί και I+T αθροίσεις για τον υπολογισμό της απόκρισης του φίλτρου.
\begin{equation}
\begin{align}
out[z] = - \sum_{f=1}^{T}c(f)out(z-f) + \sum_{f=0}^{I}d(f)in(z-f) \\
\end{align}
\end{equation}

Σημαντικό μειονέκτημα των \(IIR\) φίλτρων είναι η διαφορά φάσης που έχει το σήμα
εξόδου. Αν είναι ζωτικής σημασίας, τότε υπερτερούν τα \(FIR\), αφού ο υπολογισμός
της απόκρισης των συστημάτων απειροστού μεγέθους απαιτεί μη γραμμική ανάλυση.
Στην αντίθετη περίπτωση η τάξη (\(order\)) του φίλτρου, για την απόρριψη του ίδιου
φάσματος συχνοτήτων ενός σήματος θα είναι πολύ μικρότερη κάνοντας χρήση της
αναδρομικής ιδιότητας των \(IIR\). Στην επόμενη ενότητα φαίνονται κάποια παραδείγματα
με τον αντίστοιχο κώδικα σε \(python\) για την δημιουργία δειγμάτων των βασικών
τύπων παραθύρων. Αρχικά φαίνονται έντονες διαφορές στην απόκριση που παρέχουν
όμως όλα υπολογίζονται με την χρήση των παραπάνω εξισώσεων. Εξαίρεση απαιτεί
το φίλτρο \(butterworth\) που λεπτομέρειες θα αναφέρουμε στην συνέχεια.

*** notes :noexport:
- να προστεθεί
  [[file:../books/ScienceDirect_articles_18Feb2023_15-57-03.874/7---Infinite-impulse-response--IIR--filte_2003_Practical-Digital-Signal-Proc.pdf][iir intro]]
*** Παραδείγματα με κώδικα
\selectlanguage{greek}
Εδώ φαίνονται μερικά από τα βασικότερα φίλτρα άπειρης κρουστικής απόκρισης, που
από εδώ και πέρα θα αναφερόμαστε σε αυτά ως \(IIR\). Οι τύποι των παρακάτω φίλτρων
αποτελούν τα πιο διαδεδομένα και εύχρηστα, για την προσομοίωση φυσικών εφαρμογών
σε προγραμματιστικό περιβάλλον. Δεν είναι άλλωστε τυχαίο πως οι περισσότερες
γλώσσες προγραμματισμού παρέχουν μια ή και περισσότερες βιβλιοθήκες για τον
σχεδιασμό και τη χρήση τους.

Το φίλτρο \(butterworth\) αποτελεί την καλύτερη δυνατή λύση για έξοδο με την μικρότερη
ενίσχυση καθώς όπως φαίνεται και στο γράφημα δεν παρουσιάζει ταλαντωτικές
συμπεριφορές στις συχνότητες διέλευσης και απόρριψης. Αυτό επιτυγχάνεται
μειώνοντας την ταχύτητα μεταβολής της ισχύος του σήματος, αποκτώντας έτσι μια
περιοχή μετάβασης όπου οι συχνότητες δεν απορρίπτονται όμως απομειώνονται σε
σημαντικό βαθμό ώστε να μην αλλοιώνεται η έξοδος του.

Το \(chebyshev\) ενώ εκ πρώτης όψης φαίνεται να επηρεάζει το σήμα σε μη
αποδεκτό βαθμό, προνόμιό του αποτελεί η ταχύτητα που προσφέρει αποτελέσματα.
Αυτό οφείλεται στην μέθοδο της αναδρομής που χρησιμοποιείται κατά την επεξεργασία
με το συγκεκριμένο φίλτρο. Τα περισσότερα χρησιμοποιούν την μέθοδο της συνέλιξης.

Παρακάτω φαίνεται η κατασκευή ενός πρότυπου φίλτρου τύπου \(butterworth\) με την χρήση
της βιβλιοθήκης \(scipy\). Αντίστοιχα παραδείγματα θα προστεθούν για κάθε γράφημα
πρότυπου φίλτρου.

\selectlanguage{english}
#+begin_src jupyter-python :session python3 :async yes :results drawer :exports code
# 4TH ORDER BUTTERWORTH FILTER WITH A GAIN DROP OF 1/sqrt(2)
# AT 0.4 CYCLES/SAMPLE
from scipy import signal
import matplotlib.pyplot as plt
import math
import numpy as np
bb, ab  = signal.butter (4, 0.8, 'low', analog=False,output='ba')
wb, hb = signal.freqz(bb, ab)
wb = wb/(2*math.pi)

plt.plot(wb, abs(np.array(hb)))
plt.title('Butterworth filter frequency response')
plt.xlabel('Frequency [cycles/sample]')
plt.ylabel('Amplitute [dB]')
plt.margins(0, 0.1)
plt.grid(which = 'both', axis='both')
#+end_src

#+RESULTS:
:results:
[[file:./.ob-jupyter/87ef5e6ac3e463c1a27a094c6ae4ea3dd05c83f2.png]]
:end:

#+CAPTION:Butterworth filter frequency response

[[file:./Butterworth Filter Freq Response.png]]


#+begin_src jupyter-python :session python3 :async yes :results drawer :exports code
# 4TH ORDER BESSEL FILTER WITH A GAIN DROP OF 1/sqrt(2)
# AT 0.4 CYCLES/SAMPLE
bb, ab = signal.bessel (4, 0.8, 'low', analog=False, output='ba')
wb, hb = signal.freqz(bb, ab)
wb = wb/(2*math.pi)

plt.plot(wb, abs(np.array(hb)))
plt.title('Bessel filter frequency response')
plt.xlabel('Frequency [cycles/sample]')
plt.ylabel('Amplitute [dB]')
plt.margins(0, 0.1)
plt.grid(which= 'both', axis= 'both')
#+end_src

#+RESULTS:
:results:
[[file:./.ob-jupyter/47597dd876fd4b667b7dacefadc37d6179395293.png]]
:end:

[[file:./Bessel Filter Freq Response.png]]

#+begin_src jupyter-python :session python3 :async yes :results drawer :exports code
#4TH ORDER CHEBYSHEV FILTER TYPE 1 (ONLY IN PASSBAND RIPPLES)
# WITH MAX RIPPLES=2 AND THE GAIN DROP AT 1.5 CYCLES/SAMPLE
bb, ab = signal.cheby1 (4, 2, 0.3, 'low', analog=False, output='ba')
wb, hb = signal.freqz(bb, ab)
wb = wb/(2*math.pi)

plt.plot(wb, abs(np.array(hb)))
plt.title('Chebyshev filter frequency response')
plt.xlabel('Frequency [cycles/sample]')
plt.ylabel('Amplitute [dB]')
plt.margins(0, 0.1)
plt.grid(which= 'both', axis= 'both')
#+end_src

#+RESULTS:
:results:
[[file:./.ob-jupyter/7c09dfb582346e4cb49ed3fc05b279aa521034f2.png]]
:end:

[[file:./Chebyshev Filter Freq Response.png]]

#+begin_src jupyter-python :session python3 :async yes :results drawer :exports code
# 4TH ORDER ELLIPTIC FILTER WITH MAX RIPPLES =2dB IN PASSBAND,
# MIN ATTENUATION =8dB IN STOP BAND AT 0.25 CYCLES/SAMPLE
bb, ab = signal.ellip (4, 2, 8, 0.5, 'low', analog=False, output='ba')
wb, hb = signal.freqz(bb, ab)
wb = wb/(2*math.pi)

plt.plot(wb, abs(np.array(hb)))
plt.title('Elliptic filter frequency response')
plt.xlabel('Frequency [cycles/sample]')
plt.ylabel('Amplitute [dB]')
plt.margins(0, 0.1)
plt.grid(which= 'both', axis= 'both')
#+end_src

#+RESULTS:
:results:
[[file:./.ob-jupyter/16e7ff124636d39cb84dec0dbd1c5a76d6f82f05.png]]
:end:

[[file:./Elliptic Filter Freq Response.png]]

\selectlanguage{greek}
Παρατηρούμε πως όλα τα παραπάνω παραδείγματα εφαρμόζονται για το ίδιο φάσμα
συχνοτήτων, όμως επηρεάζουν τις συχνότητες διέλευσης και κατά συνέπια το
σήμα εξόδου με διαφορετικό τρόπο. Ανάλογα με τις εκάστοτε προϋποθέσεις και
περιορισμούς του συστήματος επεξεργασίας που διαθέτουμε μπορεί να προτιμηθεί
κάποια από τις περιπτώσεις που προαναφέρθηκαν εδώ. Η πολυπλοκότητα και το εύρος
των σημάτων που διαχειριζόμαστε σε βιομηχανικές εγκαταστάσεις αλλά και στην
καθημερινή αλληλεπίδραση με τα τεχνολογικά μέσα έχουν εξειδικεύσει αυτές τις
κατηγορίες περεταίρω, με την χρήση αλγορίθμων βελτιστοποίησης, όμως στο πλαίσιο
της παρούσας εργασίας δεν θα σχολιαστούν τέτοιες μέθοδοι.

Αξίζει εδώ να σχολιαστεί ότι τα συγκεκριμένα πρότυπα φίλτρων τυποποιήθηκαν
από το λογισμικό υπολογισμών και προγραμματισμού \(Matlab\) και στην συνέχεια
πολλές γλώσσες προγραμματισμού τα συμπεριέλαβαν σε βιβλιοθήκες για επεξεργασία
σημάτων. Η \(python\) θεωρείται από τις γλώσσες με τις αναλυτικότερες βιβλιοθήκες
για την κατασκευή φίλτρων, λόγω των πολλών επιλογών σε τύπους αλλά ειδικά στην
πλειθώρα χαρακτηριστικών που μπορεί ο χρήστης να καθορίσει για τη συμπεριφορά
και απόκριση των φίλτρων.
* Αποτελέσματα και εγκατάσταση εργαστηρίου
** Εγκατάσταση εργαστηρίου
    Η εγκατάσταση που χρησιμοποιήθηκε για την συλλογή των δεδομένων
αποτελείται από μία αεροσήραγγα την οποία τροφοδοτεί με σταθερή ταχύτητα
αέρα ένας ηλεκτροκινητήρας προσδεδεμένος σε έναν έλικα. Στην μέση της
σήραγγας υπάρχει ένα πλέγμα διάχυσης ώστε η ροή του αέρα να γίνεται όσο
το δυνατόν πιο ομοιόμορφα στην έξοδο όπου βρίσκεται και το αισθητήριο
όργανο για την καταγραφή της ταχύτητας του ανέμου. Παρακάτω φαίνεται μια
εικόνα της εγκατάστασης σε σχηματικό διάγραμμα.

#+attr_latex:  :width 420px
#+attr_latex:  :height 250px
#+attr_latex:  :center t
#+ATTR_LATEX: :caption \caption{Θάλαμος ομοιόμορφης παροχής ανέμου στο αισθητήριο όργανο όπου τοποθετείται στο σημείο \textbf{Α}. Στο σημείο  \textbf{\(A_{s}\)}, βρίσκεται ένα πλέγμα διάσπασης της ροής που μας επιτρέπει την ομαλή ταχύτητα στο σημείο εξόδου \textbf{A}.}
[[file:./Wind_Tunnel_setup_lab.png]]
** Μεθοδολογία επεξεργασίας
    Ένας λόγος που δεν χρησιμοποιήθηκε επεξεργασία σε πραγματικό χρόνο είναι
ότι η εγκατάσταση “που χρησιμοποιήθηκε για την συλλογή των δεδομένων”
κατασκευάστηκε με σκοπό την σύνδεσή του σε κεντρική μονάδα επικοινωνίας
και από εκεί πραγματοποιείται σύνδεση μέσω σειριακής θύρας $\en{USB}$ με Η/Υ,
όπου και καταγράφεται το σήμα του αισθητήριου οργάνου ($\en{pitot-tube}$). Ένας
δεύτερος λόγος ήταν η ανάγκη να δοκιμαστούν διαφορετικές μέθοδοι
αφαίρεσης του θορύβου και προφανώς αυτό θα ήταν πιο δύσκολο εάν έπρεπε
να γίνει σε πραγματικό χρόνο αλλάζοντας τις απαραίτητες παραμέτρους για
την ρύθμιση του φίλτρου. Θα έπρεπε λοιπόν να εγκατασταθεί ανάλογη
συσκευή, όπως ένας μικροεπεξεργαστής, που θα είχε την δυνατότητα για
υψηλές ταχύτητες δειγματοληψίας καθώς η καταγραφή έγινε στα 100 $\en{kHz}$.
Αυτό θα αύξανε πολύ το κόστος της κατασκευής και θα απαιτούσε
βαθμονόμιση του φίλτρου για να μην προστεθεί περαιτέρω σφάλμα στην
μέτρηση. Παρακάτω φαίνεται ένα διάγραμμα της συνδεσμολογίας και του τρόπου
καταγραφής του σήματος.

#+begin_src dot :file ./flowcharts/test-first.png :results file :exports results :session dot :tangle ./graphviz/lab-struct.gv
digraph regexp  {
    // size= "4,6!"
    "Pitot-tube" ->
    "H/Y" ->
    "Αρχείο δεδομένων" ->
    "Αρχικό σήμα πρoς επεξεργασία" ->
    "Περιπτώσεις πειράματος" ->
    {"Συμπιεσμένος αέρας"  "Αεροσύραγκα" } [color=red]

    "Συμπιεσμένος αέρας" -> "5, 10 m/s" [color=forestgreen]

    "Αεροσύραγκα" -> "5, 10, 15, 20 m/s" [color=magenta]

    {"5, 10, 15, 20 m/s" "5, 10 m/s" }
    -> {"Ανοιχτός Inverter" "Κλειστός Inverter"}[color = blueviolet,
                                                 arrowhead = diamond,
                                                 arrowsize = 1.4 ]

    "Pitot-tube" -> "Αρχικό σήμα πρoς επεξεργασία"
}

#+end_src

#+attr_latex:  :width 420px
#+attr_latex:  :height 550px
#+attr_latex:  :center t
#+RESULTS:
[[file:./flowcharts/test-first.png]]

Για την επεξεργασία των δεδομένων έπρεπε αρχικά να σιγουρευτούμε πως οι
μετρήσεις δεν υπέφεραν από το φαινόμενο της αλλοίωσης. Έτσι καθίσταται
αναγκαία η εφαρμογή της μεθόδου μείωσης αριθμού δειγμάτων, ώστε να εξεταστεί
το μέγεθος αλλοίωσης του σήματος. Στην συνέχεια έπρεπε να γίνει η μετατροπή
του σήματος στο πεδίο των συχνοτήτων για να αναγνωριστεί το φάσμα συχνοτήτων
που εμπεριέχουν τον θόρυβο και να σχεδιαστεί το κατάλληλο φίλτρο. Για τον σκοπό
αυτό εφαρμόστηκε ο ταχύς μετασχηματισμός \(Fourier\) από την βιβλιοθήκη \(numpy\) και
φάνηκε ξεκάθαρα μια περιοχή συχνοτήτων στα σήματα από τα 2000 \(Hz\).
Εδώ φαίνονται δύο από τα διαγράμματα της ανάλυσης των φίλτρων που
χρησιμοποιήθηκαν στην σύγκριση των μεθόδων απόρριψης του θορύβου.

Η εύρεση της μέσης τιμής για κάθε στοιχείο του
σήματος με την συνάρτηση \(average()\) για την ανάλυση του σήματος στο πεδίο του
χρόνου. Μας δίνει την πληροφορία της ισχύς του σήματος γύρω από την ενδιάμεση
τιμή, ή αλλιώς *θέση ισορροπίας*. Επιπρόσθετα η μέθοδος που εφαρμόζεται για
την εξέταση των φίλτρων και των άλλων διεργασιών που εφαρμόζονται στο σήμα
βασίζεται στην τεχνική του \(Welch\) για την εκτίμηση της πυκνότητας φάσματος
συχνοτήτων.

Έτσι για την εκλογή των συμπερασμάτων θα παρατεθούν στη συνέχεια διαγράμματα
με το αρχικό σήμα και το επεξεργασμένο στο πεδίο των συχνοτήτων καθώς είναι
πιο εύκολο να διακρίνουμε την επιρροή των φίλτρων στο σήμα εξόδου. Όπως έχει
αναφερθεί και παραπάνω κατά την απόρριψη του μη αποδεκτού θορύβου, τα φίλτρα
εντάσσουν αμελητέες καταστρεπτικές συμπεριφορές στο σύστημα που αν δεν ληφθούν
υπ' όψη ενδέχεται να επηρεάσουν το σήμα εξόδου.


#+begin_src latex
\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
\centering
\includegraphics[width=.8 \linewidth]{./fir-200.png}
\caption{\(F.I.R.\) φίλτρο}
\label{fig:sub1}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
\centering
\includegraphics[width=.8 \linewidth]{./iir-butter-200.png}
\caption{\(I.I.R.\) φίλτρο}
\label{fig:sub2}
\end{subfigure}
\caption{Διαφορετικά φίλτρα διέλευσης χαμηλών συχνοτήτων}
\label{fig:test}
\end{figure}
#+end_src

#+RESULTS:
#+begin_example
\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
\centering
\includegraphics[width=.8 \linewidth]{./fir-200.png}
\caption{\(F.I.R.\) φίλτρο}
\label{fig:sub1}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
\centering
\includegraphics[width=.8 \linewidth]{./iir-butter-200.png}
\caption{\(I.I.R.\) φίλτρο}
\label{fig:sub2}
\end{subfigure}
\caption{Διαφορετικά φίλτρα διέλευσης χαμηλών συχνοτήτων}
\label{fig:test}
\end{figure}
#+end_example

#+begin_src dot :file ./flowcharts/proc-meth.png :results file :exports results :session dot :tangle ./graphviz/proc-methods.gv

digraph processing {
    // root of operations
    root [label="Επεξεργασία σήματος με θόρυβο" ]
    filt [label="Απομείωση θορυβου"]
    aliasing [label="Έλεγχος \n αλλοίωσης"]
    averg [label="Υπολογισμός \n μέσης τιμής \n σήματος"]

    // filter related
    fir [label="FIR"]
    iir [label="IIR"]
    apply [label="Εφαρμογή φίλτρων"]
    filterconst [label="Κατασκευή \n φίλτρων"]
    filt_type [label="Διέλευσης χαμηλών \n συχνοτήτων \n (low-pass)"]

    // aliasing
    decimop [label="Αποδεκατισμός \n ανά 5 και 50 δείγματα \n (decimation)"]
    timedom [label="Επεξεργασία στο πεδίο \n του χρόνου"]

    //general bubbles
    graphs [label="Γραφήματα"]
    fftmethod [label= "Πεδίο συνχότητας \n (fft algorithm)" ]
    choosfilt [label="Επιλογή επιθυμητών \n συχνοτήτων \n(cutoff frequency)"]
    results [label="Σύγκριση αποτελεσμάτων"]
    avrged [label="average(signal, fs) \n \n Ανάλογα με την \n συχνότητα \n καταγραφής, fs"]
    welch [label="Μέθοδος Welch \n (Spectral density)"]

    {rank=same; apply filt_type }
    {rank=same; filt timedom }
    {rank=same; fftmethod aliasing averg}
    {rank=same; decimop filterconst avrged}

    // start the graph at last 🫠
    root -> {filt timedom}

    // filtering path
    filt ->
    fftmethod ->
    choosfilt ->
    filterconst -> {fir iir} ->
    filt_type ->
    apply ->
    welch ->
    graphs [style=bold, color=red]

    // aliasing path
    timedom ->
    aliasing ->
    decimop ->
    apply ->
    graphs[color=blueviolet , style=bold]

    // aliasing path
    timedom ->
    averg ->
    avrged ->
    apply ->
    graphs [color=magenta]

    graphs -> results [color=forestgreen, style=bold]
}
#+end_src

#+attr_latex:  :width 420px
#+attr_latex:  :height 699px
#+attr_latex:  :center t
#+RESULTS:
[[file:./flowcharts/proc-meth.png]]
\clearpage
** DONE Phase delay problem :noexport:
CLOSED: [2023-04-07 Παρ 20:09]
:LOGBOOK:
- CLOSING NOTE [2023-04-07 Παρ 20:09] \\
  done and demonstrated bellow
:END:
*** the phase problem with python
#+begin_src jupyter-python :session python3 :async yes :results raw drawer :exports none
import numpy as np
import scipy.signal

np.random.seed(42)  # for reproducibility
fs = 30  # sampling rate, Hz
ts = np.arange(0, 5, 1.0 / fs)  # time vector - 5 seconds
ys = np.sin(2*np.pi * 1.0 * ts)  # signal @ 1.0 Hz, without noise
yerr = 0.5 * np.random.normal(size=len(ts))  # Gaussian noise
yraw = ys + yerr

b, a = scipy.signal.iirfilter(4, Wn=2.5, fs=fs, btype="low", ftype="butter")
print(b, a, sep="\n")
y_lfilter = scipy.signal.lfilter(b, a, yraw)


plt.tight_layout()
# plt.savefig("simple-lowpass-lfilter.png", dpi=100)

# apply filter forward and backward using filtfilt
y_filtfilt = scipy.signal.filtfilt(b, a, yraw)

plt.figure(figsize=[6.4, 2.4])
plt.plot(ts, yraw, label="Raw signal")
plt.plot(ts, y_lfilter, alpha=0.5, lw=3, label="with delay")
plt.plot(ts, y_filtfilt, alpha=0.8, lw=4, label="without delay")
plt.legend(loc="lower center", bbox_to_anchor=[0.5, 1], ncol=3,
           fontsize="smaller")
plt.xlabel("Time / s")
plt.ylabel("Amplitude")

plt.tight_layout()
plt.savefig("./bucket/filters/lowpass-filtfilt.png", dpi=100)
plt.show()

#+end_src

#+RESULTS:
:results:
: [0.00257643 0.01030574 0.01545861 0.01030574 0.00257643]
: [ 1.         -2.63862774  2.76930979 -1.33928076  0.24982167]
: <Figure size 640x480 with 0 Axes>
[[file:./.ob-jupyter/c0bb46f715a888827cb46ad3996973fce886bdf6.png]]
:end:

[[https://www.samproell.io/posts/yarppg/digital-filters-python/][reference]]
** Σύγκριση αποτελεσμάτων φίλτρων
Για να συγκρίνουμε τις δυο διαφορετικές διαδικασίες είναι προφανές ότι δεν
ωφελεί να επικεντρωθούμε στην ταχύτητα έκδοσης αποτελεσμάτων. Θα πρέπει λοιπόν
να εξετάσουμε τις διαστρεβλώσεις σε χαμηλές συχνότητες που εντάσσει η κάθε
κατηγορία αλλά και η διαφορά φάσης της εξόδου κάθε διαδικασίας. Εύλογα έχουν
γίνει προσπάθειες για την εξάλειψη της καθυστέρησης που προκύπτει και οι
περισσότερες βιβλιοθήκες με σκοπό την επεξεργασία σημάτων έχουν λύσει σε
τέτοιο βαθμό το πρόβλημα που σχεδόν δεν απασχολεί τον ερευνητή πέρα από την
επιλογή κατάλληλης συνάρτησης. Για την επεξεργασία των δεδομένων έχουν ληφθεί
δύο μέτρα προς την κατεύθυνση αυτή. Το πρώτο αφορά την αποφυγή της συνάρτησης
\(lfilter\) που όπως μπορούμε εύκολα να δείξουμε εντάσσει μεγάλη διαφορά φάσης μεταξύ
της εξόδου και της εισόδου του συστήματος.

#+CAPTION: Σύγκριση συναρτήσεων εφαρμογής του ίδιου φίλτρου της βιβλιοθήκης \(signal\).
[[file:./bucket/filters/lowpass-filtfilt.png]]

Ο έλεγχος των αποτελεσμάτων γίνεται με την χρήση της τυπικής απόκλισης. Κατά
την εφαρμογή οποιουδήποτε φίλτρου θα πρέπει η τυπική απόκλιση του σήματος να
μειώνεται, λογικό παράγωγο της διαδικασίας καθαρισμού σημάτων από θόρυβο, αφού
η απομάκρυνση από την μέση τιμή θα πρέπει να μειώνεται. Αν η τυπική απόκλιση
αυξάνεται, το σύστημα επηρεάζεται καταστρεπτικά από την διεργασία που
εφαρμόζεται σε αυτό. Παρατηρήθηκε αντίστοιχη συμπεριφορά αυξάνοντας την τάξη
του φίλτρου πέραν του αναγκαίου κατά πολλές τάξεις μεγέθους.

** Επεξεργασία δεδομένων ανέμου
Όπως φαίνεται και στο παραπάνω διάγραμμα ροής για την ικανοποιητική σύγκριση
της επιρροής του φίλτρου στο σήμα που καταγράφηκε από τον αισθητήρα μέτρησης
της ταχύτητας ανέμου, προέχει ο έλεγχος της αλλοίωσης λόγω ανεπαρκούς
συχνότητας της κάρτας ΝΙ (\(Native\ Instruments\)) καταγραφής. Ο τρόπος που επιλέχθηκε
εδώ ήταν η χρήση της τυπικής απόκλισης της κυματομορφής και να ελεγχθεί η
τυχών αύξησή της μετά την επεξεργασία. Από την αρχή μπορούμε να
παρατηρήσουμε πως όταν ο μετασχηματιστής που ευθύνεται για τις παρεμβολές,
είναι εμφανής η αύξηση της τυπικής απόκλισης κατά 2 τάξεις μεγέθους. Επίσης
κατά την διαδικασία βελτιστοποίησης της τάξης του φίλτρου, λόγω βασικών
διαφορών στα \(FIR\) και \(IIR\) συστήματα, χρησιμοποιήθηκε ώστε να αποφευχθεί η
κατασκευή διαγραμμάτων κάθε φορά που πειραματιζόμασταν με διάφορα
χαρακτηριστικά του εκάστοτε φίλτρου.

#+begin_src jupyter-python :session python3 :async yes :results raw drawer :exports results :tangle ./src/tables_data_process_blocks.py
#%%
from tabulate import tabulate
table = [[f'{dfi_i0_w0.description.replace("Inverter Off", "Μετ. κλειστός").replace("WS", "Ταχ. αν.").replace("100kHz", "")}',
          "{:.4f}".format(np.std(df_tdms_0_0.data)),
          "{:.4f}".format(np.std(dfi_i0_w0.data))],

         [f'{dfi_i1_w0.description.replace("Inverter On", "Μετ. ανοιχτός").replace("WS", "Ταχ. αν.").replace("100kHz", "")}',
          "{:.4f}".format(np.std(df_tdms_1_0.data)),
          "{:.4f}".format(np.std(dfi_i1_w0.data))],
         [f'{dfi_i1_w5.description.replace("Inverter On", "Μετ. ανοιχτός").replace("WS", "Ταχ. αν.").replace("100kHz", "")}',
          "{:.4f}".format(np.std(df_tdms_1_5.data)),
          "{:.4f}".format(np.std(dfi_i1_w5.data))],
         [f'{dfi_i1_w10.description.replace("Inverter On", "Μετ. ανοιχτός").replace("WS", "Ταχ. αν.").replace("100kHz", "")}',
          "{:.4f}".format(np.std(df_tdms_1_10.data)),
          "{:.4f}".format(np.std(dfi_i1_w10.data))],

         [f'{dfi_i1_w15.description.replace("Inverter On", "Μετ. ανοιχτός").replace("WS", "Ταχ. αν.").replace("100kHz", "")}',
          "{:.4f}".format(0),
          "{:.4f}".format(np.std(dfi_i1_w15.data))],
         [f'{dfi_i1_w20.description.replace("Inverter On", "Μετ. ανοιχτός").replace("WS", "Ταχ. αν.").replace("100kHz", "")}',
          "{:.4f}".format(0),
          "{:.4f}".format(np.std(dfi_i1_w20.data))],
         ]

print(tabulate(table, headers=["Ταχύτητα ανέμου και μετασχηματιστής",
                               "Συμπιεσμένος αέρας",
                               "Αεροσήραγγα"]))

#+end_src

#+RESULTS:
:results:
: Ταχύτητα ανέμου και μετασχηματιστής      Συμπιεσμένος αέρας    Αεροσήραγγα
: -------------------------------------  --------------------  -------------
: Μετ. κλειστός, Ταχ. αν.=0,                           0.0062         0.0076
: Μετ. ανοιχτός, Ταχ. αν.=0,                           0.0364         0.0392
: Μετ. ανοιχτός, Ταχ. αν.=5,                           0.0434         0.0385
: Μετ. ανοιχτός, Ταχ. αν.=10,                          0.0841         0.04
: Μετ. ανοιχτός, Ταχ. αν.=15,                          0              0.0421
: Μετ. ανοιχτός, Ταχ. αν.=20,                          0              0.0566
:end:
Πίνακας τυπικής απόκλισης αρχικών σημάτων.

** Εφαρμογή φίλτρων
Για την παρεμβολή που επηρεάζει το σήμα του αισθητήρα θα εφαρμοστεί ένα φίλτρο
διέλευσης χαμηλών συχνοτήτων. Είμαστε σε θέση να γνωρίζουμε πως οι χαμηλές
συχνότητες του σήματος εμπεριέχουν όλο το ποσό της πληροφορίας που αποτελεί
την μέτρηση. Οι μετρήσεις που καταγράφηκαν για μηδενικές ταχύτητες, με τον
μετασχηματιστή κλειστό και ανοιχτό, χρησιμοποιήθηκαν για να βρεθεί η
ονομαστική τάση του αισθητήρα. Όσο για την επιλογή του κατάλληλου φίλτρου,
ως καταλληλότερα κρίθηκαν το \(butterworth\) από την κατηγορία των \(IIR\) για την
ελάχιστη διαστρέβλωση που αποφέρει κατά την εφαρμογή του στις συχνότητες
διέλευσης. Για την εύκολη σύγκριση των δύο μεθόδων, τα φίλτρα \(FIR\) έπρεπε να
μετατραπούν από την μορφή της εξίσωσης μεταφοράς σε δευτέρας τάξης “κομμάτια”
της αναπαράστασης της εξίσωσης μεταφοράς που χαρακτηρίζει το φίλτρο. Για τις
κατηγορίες που θα δούμε παρακάτω, οι βασικοί τύποι των \(FIR\) φίλτρων που θα
παρουσιαστούν αναφέρονται στην ευρύτερη βιβλιογραφία ως τύπου \(I\) και τύπου \(II\).
Η διαφορά είναι πως τα πρώτα παρουσιάζουν θετική συμμετρία και έχουν τάξη
ακέραιου περιττού αριθμού. Τα τύπου \(II\) εμφανίζουν την ίδια συμμετρία, όμως
η τάξη του φίλτρου είναι άρτιος αριθμός.

Υπάρχουν άλλες δύο κατηγορίες που εμφανίζουν αρνητική συμμετρία, όμως η
διαφορά στις τάξεις των φίλτρων τύπου \(III,\ IV\) είναι ανάλογες με των προηγούμενων
δύο τύπων.

Στην παρούσα εργασία ασχοληθήκαμε μόνο με φίλτρα από τους πρώτους 2 τύπους,
όμως αργότερα θα μπορούσαν να ερευνηθούν και περισσότεροι τύποι και
κατηγορίες παραθύρων. Όλες οι παραπάνω κατηγορίες συμπεριλαμβανομένων και
των \(IIR\), στην έξοδό τους, το σήμα παραμορφώνεται εμφανίζοντας διαφορά φάσης
με το σήμα εξόδου. Έτσι, όπως αναφέρθηκε και νωρίτερα στην ενότητα 6.3,
επιλέγοντας την σωστή συνάρτηση από την κατάλληλη βιβλιοθήκη μπορούμε να
μειώσουμε το σφάλμα της αλλοίωσης και την πρόσθεση διαφοράς φάσης, σε
αποδεκτό βαθμό. Στην συνέχεια θα συγκριθούν τα διαγράμματα της πυκνότητας
ισχύος του σήματος με την μέθοδο του \(Welch\), ώστε να εκλεγεί το κατάλληλο
προς εφαρμογή φίλτρο.
** Αποτελέσματα επεξεργασίας
Για κάθε σήμα που καταγράφηκε εφαρμόστηκαν και οι δύο μέθοδοι και φάνηκε πως
ενώ για τα φίλτρα \(IIR\) είχαμε αποδεκτό βαθμό αλλοίωσης, ελέγχοντας την
τυπική απόκλιση του σήματος εξόδου με εκείνη της εισόδου, τα \(FIR\)
φίλτρα παρέχουν καλύτερα αποτελέσματα. Ο τύπος του θορύβου που επηρεάζει το
σήμα του αισθητήρα εμφανίζεται κυρίως σε συχνότητες που καταλαμβάνουν
ηλεκτρομαγνητικά κύματα ξεκινώντας από την περιοχή των 10-100 \(kHz\).
Καταγράφηκαν και σήματα με συχνότητα δειγματοληψίας 500 \(kHz\) και ο θόρυβος
παραμένει, επομένως κρίθηκε πως πρόκειται για παρεμβολή μεγαλύτερης συχνότητας
από τις δυνατότητες καταγραφής του συστήματος που διαθέτουμε.
*** Αποδεκατισμός σήματος
<<sec:decimation-chapter>>
Η τεχνική του αποδεκατισμού εφαρμόστηκε κυρίως στην αρχή της επεξεργασίας
για να ελεγχθεί η διαδικασία καταγραφής. Κατέστη αναγκαίο να μπορέσουμε
να διασταυρώσουμε τον βαθμό που το αρχικό σήμα υπέστη αλλοίωση από την
καταγραφή του. Επίσης σημαντικό ήταν να διασφαλιστεί πως κάθε μέθοδος
απόρριψης συχνοτήτων θα μπορούσε να εφαρμοστεί σε μειωμένο αριθμό
δειγμάτων. Λόγω υψηλής συχνότητας καταγραφής μετά τα δέκα δευτερόλεπτα
διάρκειας σήματος, για την ολοκλήρωση των διαδικασιών που εφαρμόζονται, θα
χρειαζόμασταν πολύ χρόνο. Στα παρακάτω διαγράμματα αποτυπώνεται ο τρόπος
που επηρεάζει το σήμα η διαδικασία αυτή.
**** Directories :noexport:
- [X] *Εδώ πρεπει να μπουν διαγράμματα απο \(decimation\)*
- [X] Να πω και μερικά πραγματα μαζι με τα αποτελέσματα.
- [X] Έχω ήδη κάποια από τα αρχεία για το paper
- [X] Να τσεκαριστούν για να είμαι σίγουρος
#+begin_src jupyter-python :session python3 :async yes :results raw drawer :exports code :tangle ./src/tables_data_process_blocks.py
#%%

ca_meas_dir = FOLDER_FOR_DATA / 'compressed air'

data_CA_inv_1_WS_0 = 'ca1_0.1'
# contains the following channels
# [<TdmsChannel with path /'Wind Measurement'/'Torque'>,
#  <TdmsChannel with path /'Wind Measurement'/'Drag'>,
#  <TdmsChannel with path /'Wind Measurement'/'Wind1'>,
#  <TdmsChannel with path /'Wind Measurement'/'Wind2'>]

path_ca_meas = ca_meas_dir / f'{data_CA_inv_1_WS_0}' / TDMS_FNAME

tdms_raw_WT =TdmsFile(path_ca_meas)

ca1_0 = WT_NoiseChannelProc.from_tdms(tdms_raw_WT[GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter On, WS=0, 500kHz')
#%%


# Decimation folder measurments
dec_meas_dir = FOLDER_FOR_DATA / 'Decimation'
dec_at_50_kHz = 'de50.1'
dec_at_5_kHz = 'de5.1'
path_dec_meas_50_kHz = dec_meas_dir / f'{dec_at_50_kHz}' / TDMS_FNAME

path_dec_meas_5_kHz = FOLDER_FOR_DATA / dec_meas_dir / f'{dec_at_5_kHz}' / TDMS_FNAME

tdms_raw_WT_50kHz =TdmsFile(path_dec_meas_50_kHz)
tdms_raw_WT_5kHz =TdmsFile(path_dec_meas_5_kHz)


dec_50kHz = WT_NoiseChannelProc.from_tdms(tdms_raw_WT_50kHz[GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter On, WS=0, 50kHz')
dec_5kHz = WT_NoiseChannelProc.from_tdms(tdms_raw_WT_5kHz[GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter On, WS=0, 5kHz')


#+end_src

#+RESULTS:
:results:
:end:
**** *Διαγράμματα αποδεκατισμού με και χωρίς αλλοίωση στο πεδίο των συχνοτήτων*
#+begin_src jupyter-python :session python3 :async yes :results raw drawer :exports none
from scipy import signal
import matplotlib.pyplot as plt
NPERSEG=1024<<6
FIGSIZE = (15,10)
medec = 100

# print(len(ca1_0.decimate(dec=medec, offset=0).data))
y = signal.decimate(ca1_0.data, medec, ftype='fir')
z, f = signal.welch(y,
                    fs=ca1_0.fs_Hz/medec,
                    window='flattop',
                    nperseg=NPERSEG/medec,
                    scaling='density')
# print(len(y))
sign = Graph_data_container(x=z,
                            y=f,
                            label="dec factor 100")

plot_spect_comb2([
    ca1_0.decimate(dec=1,offset=0).set_desc('500 kHz origin').calc_spectrum( nperseg=NPERSEG, scaling='density'),
    ca1_0.decimate(dec=medec,offset=0).set_desc('5 kHz (dec=10)').calc_spectrum( nperseg=NPERSEG/medec, scaling='density'),
    dec_5kHz.set_desc('5 kHz origin').calc_spectrum(nperseg=NPERSEG/100, scaling='density')
],
                 title='Αποδεκατισμός σήματος χωρίς επεξεργασία κατά της αλλοίωσης',
                 xlim=[1e0,1e6], ylim = [1e-5,0.5e-2],
                 figsize = FIGSIZE,
                 draw_lines=True
                 )
plt.savefig(f'./decimation/with_aliasing.png',facecolor='white', transparent=False)
plot_spect_comb2([
    ca1_0.decimate(dec=1,offset=0).set_desc('500 kHz origin').calc_spectrum( nperseg=NPERSEG/1, scaling='density'),
    sign,
    dec_5kHz.set_desc('5 kHz origin').calc_spectrum(nperseg=NPERSEG/100, scaling='density')
],
                 title='Αποδεκατισμός σήματος με φίλτρο κατά της αλλοίωσης',
                 xlim=[1e0,1e6], ylim = [1e-5,0.5e-2],
                 figsize = FIGSIZE,
                 draw_lines=True
                 )
plt.savefig(f'./decimation/anti_aliasing_fir.png',facecolor='white', transparent=False)
#+end_src
#+RESULTS:
:results:
[[file:./.ob-jupyter/8027c0b392685323a7c98def9626636667d1e0a6.png]]
[[file:./.ob-jupyter/edbe4f41909919700fee15b1f35b2b2952f34d49.png]]
:end:

#+attr_latex: :width 500px :height 280px
#+CAPTION: Αποδεκατισμός σήματος χωρίς επεξεργασία κατά της αλλοίωσης.
[[file:./decimation/with_aliasing.png]]

#+attr_latex: :width 500px :height 280px
#+CAPTION: Αποδεκατισμός σήματος με φίλτρο \(FIR\) κατά της αλλοίωσης.
[[file:./decimation/anti_aliasing_fir.png]]

Όπως φαίνεται και παρακάτω η διαδικασία της μείωσης του αριθμού των
δειγμάτων μπορεί να εντάξει αλλοίωση σε αρχικά “καθαρό” σήμα. Για να
μπορέσουμε να εφαρμόσουμε σωστά την συγκεκριμένη τεχνική, χρησιμοποιώντας
και κάποιο φίλτρο για την διόρθωση της αλλοίωσης, υπάρχουν πολλές μέθοδοι,
ήδη στις βιβλιοθήκες που χρησιμοποιήθηκαν για την ανάλυση των σημάτων.
\clearpage
#+begin_src jupyter-python :session python3 :async yes :results raw drawer :exports results :tangle ./src/tables_data_process_blocks.py
#%%
from tabulate import SEPARATING_LINE
NPERSEG=1024<<6
FIGSIZE = (15,10)
medec = 100

# print(len(ca1_0.decimate(dec=medec, offset=0).data))
y = signal.decimate(ca1_0.data, medec, ftype='fir')
z, f = signal.welch(y,
                    fs=ca1_0.fs_Hz/medec,
                    window='flattop',
                    nperseg=NPERSEG/medec,
                    scaling='density')
# print(len(y))
sign = Graph_data_container(x=z,
                            y=f,
                            label="dec factor 100")

tablexydec=[["Αριθμός δειγμάτων\n\
συχνοτήτων (χ άξονας)",
             len(ca1_0.decimate(dec=1, offset=0).calc_spectrum( nperseg=NPERSEG).x),
             len(ca1_0.decimate(dec=10, offset=0).calc_spectrum( nperseg=NPERSEG/10).x),
             len(ca1_0.decimate(dec=100, offset=0).calc_spectrum( nperseg=NPERSEG/100).x)
             ],
            SEPARATING_LINE,
            ["Αριθμός δειγμάτων\n\
ισχύος του σήματος\n\
(ψ άξονας)",
             len(ca1_0.decimate(dec=1, offset=0).calc_spectrum( nperseg=NPERSEG).y),
             len(ca1_0.decimate(dec=10, offset=0).calc_spectrum( nperseg=NPERSEG/10).y),
             len(ca1_0.decimate(dec=100, offset=0).calc_spectrum( nperseg=NPERSEG/100).y)
             ]]

tablexyrec=[["Αριθμός δειγμάτων\n\
συχνοτήτων (χ άξονας)",
             0,
             len(dec_50kHz.calc_spectrum(nperseg=NPERSEG/10).x),
             len(dec_5kHz.calc_spectrum(nperseg=NPERSEG/100).x),
             ],
            SEPARATING_LINE,
            ["Αριθμός δειγμάτων\n\
ισχύος του σήματος\n\
(ψ άξονας)",
             0,
             len(dec_50kHz.calc_spectrum(nperseg=NPERSEG/10).y),
             len(dec_5kHz.calc_spectrum(nperseg=NPERSEG/100).y),
             ]]

tablexysign=[["Αριθμός δειγμάτων\n\
συχνοτήτων (χ άξονας)",
             len(sign.x),
             ],
             SEPARATING_LINE,
            ["Αριθμός δειγμάτων\n\
ισχύος του σήματος\n\
(ψ άξονας)",
             len(sign.y),
             ]]
#+end_src

#+RESULTS:
:results:
:end:
**** *Πίνακες επαλήθευσης μεθόδων στο πεδίο των συχνοτήτων*

Όπως φαίνεται στον επόμενο πίνακα ο αριθμός των δειγμάτων καθώς
εφαρμόζουμε την μέθοδο του αποδεκατισμού παραμένει σταθερός, γεγονός που
καθορίζει την ορθότητα της εφαρμογής.
#+NAME: :table:dec_table
#+begin_src jupyter-python :session python3 :async yes :exports results :tangle ./src/tables_data_process_blocks.py
#%%
from tabulate import tabulate
print(tabulate(tablexydec, headers=["αποδεκατισμένο σήμα",
                                    "χωρίς αποδεκατισμό",
                                    "ανά 10 ",
                                    "ανά 100 "],
               tablefmt="simple"))
#+end_src

- Πίνακας αριθμού δειγμάτων για αποδεκατισμένο σήμα χωρίς φίλτρο
  #+ATTR_LATEX: :placement [t] :center t :booktabs t :environment tabular :width \textwidth :align X[1lm]X[2lm]
  #+RESULTS: :table:dec_table
  : αποδεκατισμένο σήμα      χωρίς αποδεκατισμό    ανά 10     ανά 100
  : ---------------------  --------------------  ---------  ----------
  : Αριθμός δειγμάτων                     32769       3277         328
  : συχνοτήτων (χ άξονας)
  : ---------------------  --------------------  ---------  ----------
  : Αριθμός δειγμάτων                     32769       3277         328
  : ισχύος του σήματος
  : (ψ άξονας)
- Πίνακας αριθμού δειγμάτων καταγεγραμμένου σήματος σε μικρότερη συχνότητα
  #+begin_src jupyter-python :session python3 :async yes :results raw drawer :exports results :tangle ./src/tables_data_process_blocks.py
#%%
from tabulate import tabulate
print(tabulate(tablexyrec, headers=["καταγεγραμμένο σε \n\
μικρότερη συχνότητα",
                                    "χωρίς αποδεκατισμό",
                                    "50.000 \n\
Χέρτζ",
                                    "5.000 \n\
Χέρτζ"],
               tablefmt="simple"))
  #+end_src
  #+RESULTS:
  :results:
  : καταγεγραμμένο σε        χωρίς αποδεκατισμό    50.000     5.000
  : μικρότερη συχνότητα                              Χέρτζ     Χέρτζ
  : ---------------------  --------------------  ---------  --------
  : Αριθμός δειγμάτων                         0       3277       328
  : συχνοτήτων (χ άξονας)
  : ---------------------  --------------------  ---------  --------
  : Αριθμός δειγμάτων                         0       3277       328
  : ισχύος του σήματος
  : (ψ άξονας)
  :end:
- Πίνακας αριθμού δειγμάτων με φίλτρο
  #+begin_src jupyter-python :session python3 :async yes :results raw drawer :exports results :tangle ./src/tables_data_process_blocks.py
#%%
print(tabulate(tablexysign,
               headers=["σήμα με φίλτρο \n\
κατά της αλλοίωσης",
                        "5.000\n\
Χέρτζ"],
               tablefmt="simple"))
  #+end_src
  #+RESULTS:
  :results:
  : σήμα με φίλτρο           5.000
  : κατά της αλλοίωσης       Χέρτζ
  : ---------------------  -------
  : Αριθμός δειγμάτων          328
  : συχνοτήτων (χ άξονας)
  : ---------------------  -------
  : Αριθμός δειγμάτων          328
  : ισχύος του σήματος
  : (ψ άξονας)
  :end:
\clearpage
- Πίνακας τυπικών αποκλίσεων σε σχέση με την μέθοδο επεξεργασίας.
  - Αποδεκατισμός
    \selectlanguage{english}
    #+begin_src jupyter-python :session python3 :async yes :results raw drawer :exports results :tangle ./src/tables_data_process_blocks.py
#%%
from pros_noisefiltering.WT_NoiProc import fir_factory_constructor

anti_aliased = signal.decimate(ca1_0.data, 100, ftype='fir')
anti_aliased_50 = signal.decimate(ca1_0.data, 10, ftype='fir')

table_std = [["5 kHz", np.std(anti_aliased), np.std(dec_5kHz.data)],
             ["50 kHz", np.std(anti_aliased_50), np.std(dec_50kHz.data)],
             SEPARATING_LINE,
             ["origin (500 kHz)", None, np.std(ca1_0.data)]]


print(tabulate(table_std,
               headers=["decimation",
                        "with anti-aliasing",
                        "without anti-aliasing"],
               tablefmt="rst",
               floatfmt=".4f"))

  #+end_src
    #+RESULTS:
    :results:
    : ================  ====================  =======================
    : decimation          with anti-aliasing    without anti-aliasing
    : ================  ====================  =======================
    : 5 kHz                           0.0058                   0.0350
    : 50 kHz                          0.0105                   0.0366
    : ================  ====================  =======================
    : origin (500 kHz)                                         0.0364
    : ================  ====================  =======================
    :end:
  \selectlanguage{greek}
  - Εφαρμογή φίλτρων
     \selectlanguage{english}
     #+begin_src jupyter-python :session python3 :async yes :results raw drawer :exports results :tangle ./src/tables_data_process_blocks.py
#%%

butter_2000 = ca1_0.filter(fc_Hz=2000).data
butter_200 = ca1_0.filter(fc_Hz=200).data

# construct the fir filters with 2000 and 200 Hz cutoff
fir_2000 = fir_factory_constructor(fir_order=60, fc_Hz=2000)
fir_200 = fir_factory_constructor(fir_order=60, fc_Hz=200)

# apply fir filters
fir_filt_2000 = ca1_0.filter(fc_Hz=2_000, filter_func=fir_2000).data
fir_filt_200 = ca1_0.filter(fc_Hz=2_00, filter_func=fir_200).data

table_filts = [["butterworth IIR", np.std(butter_2000), np.std(butter_200)],
               ["simple FIR", np.std(fir_filt_2000), np.std(fir_filt_200)],
               ]

# filtering table
print(tabulate(table_filts,
               headers=["low-pass filter",
                        "2 kHz cutoff" ,
                        "200 Hz cutoff"],
               tablefmt="rst",
               floatfmt=".4f"))

    #+end_src

    #+RESULTS:
    :results:
    : =================  ==============  ===============
    : low-pass filter      2 kHz cutoff    200 Hz cutoff
    : =================  ==============  ===============
    : butterworth IIR            0.0035           0.0029
    : simple FIR                 0.0054           0.0054
    : =================  ==============  ===============
    :end:

  \selectlanguage{greek}
**** plots for decimated signals from same origin :noexport:
#+begin_src jupyter-python :session python3 :async yes :results raw drawer :exports none


#%% [markdown]
# ## Comparing compressed air with other measurements with less sampling frequency
# comparing the signal
# when different filters are applied and averaging occurs
#

plot_spect_comb2([ca1_0.set_desc('500 kHz').calc_spectrum( nperseg=NPERSEG),
                  dec_50kHz.set_desc('50 kHz').calc_spectrum( nperseg=NPERSEG/10),
                  dec_5kHz.set_desc('5 kHz').calc_spectrum( nperseg=NPERSEG/100)
                  ],
                 title='Comparison of signals with different sampling rates',
                 xlim=[1e1,3.5e5], ylim = [1e-5,0.5e-2],
                 figsize = FIGSIZE
                 , draw_lines=True
                 )


#+end_src

#+RESULTS:
:results:
[[file:./.ob-jupyter/6068645eb6533d71c74f84931e8fa9a7eedcd204.png]]
:end:
**** time histories :noexport:
#+begin_src jupyter-python :session python3 :async yes :results raw drawer :exports code
in1_0_av100 = ca1_0.average(100)
print(ca1_0.operations)
print(in1_0_av100.operations)
print(ca1_0.decimate(1).operations)
print(ca1_0.decimate(1).average(100).operations)
print(ca1_0.filter(fc_Hz=100).average(100).operations)
#+end_src

#+RESULTS:
:results:
: ['Loaded from tdms file Wind Measurement/Wind2, 500000.0000000014']
: ['Loaded from tdms file Wind Measurement/Wind2, 500000.0000000014', 'Apply Averaging :100']
: ['Loaded from tdms file Wind Measurement/Wind2, 500000.0000000014', 'Decimation factor:1, Offset:0, new fs_Hz:500000.0000000014']
: ['Loaded from tdms file Wind Measurement/Wind2, 500000.0000000014', 'Decimation factor:1, Offset:0, new fs_Hz:500000.0000000014', 'Apply Averaging :100']
: ['Loaded from tdms file Wind Measurement/Wind2, 500000.0000000014', 'pass filter 100', 'Apply Averaging :100']
:end:
*** Απομείωση θορύβου
Για την επιλογή του κατάλληλου φίλτρου εξετάστηκαν οι δύο βασικές
κατηγορίες, συγκρίνοντας την τιμή της τυπικής απόκλισης του σήματος πριν
και μετά την εφαρμογή. Αξίζει να σημειωθεί ότι, για να αποκτήσει κανείς
πλήρη εικόνα για την βέλτιστη επιλογή θα πρέπει να συμπεριληφθεί και ο
χρόνος εκτέλεσης της επεξεργασίας. Από τους σημαντικότερους παράγοντες
που επηρεάζουν τον χρόνο υπολογισμού στα φίλτρα είναι η τάξη τους, δηλαδή
το πλήθος των συντελεστών του πολυωνύμου που θα κατασκευαστεί από τον
εκάστοτε αλγόριθμο. Όπως θα δειχθεί και στη συνέχεια, τα φίλτρα \(IIR\), ενώ
αποδίδουν καλύτερα στην απομείωση του θορύβου με φίλτρα μικρότερης τάξης
από τα \(FIR\), απαιτούν μεγαλύτερη υπολογιστική ισχύ λόγω της αναδρομικής
συμπεριφοράς στα πρώτα. Στην πράξη ανάλογα με την συχνότητα καταγραφής και
την διάρκεια του σήματος, δηλαδή την ποσότητα των στοιχείων που εκφράζουν
το διακριτό σήμα προς επεξεργασία, επιλέγεται και μια από τις βασικές
κατηγορίες. Εδώ εξετάστηκαν και οι δύο μέθοδοι με σήματα διάρκειας περίπου
επτά δευτερόλεπτα σε συχνότητες καταγραφής 500 και 100 \(kHz\). Η πηγή του
ανέμου από το καλώδιο πεπιεσμένου αέρα καταγράφηκε με συχνότητα 500 \(kHz\),
ενώ του *\(ventilator\)* στα 100 \(kHz\).

#+CAPTION: Διάγραμμα απεικόνισης σήματος στα πεδία χρόνου και συχνότητας εφαρμόζοντας ένα απλό \(butterworth\) φίλτρο διέλευσης χαμηλών συχνοτήτων.
#+attr_latex: :width 450px :height 480px
[[file:./src/sign_overview/butterworth_IIR_low_pass_2000_Hz_Inverter_on_WS_0_.jpg]]

Όπως θα γίνει αντιληπτό αργότερα, η διαδικασία παραγωγής των αποτελεσμάτων
αποτέλεσε το μικρότερο μέρος της εργασίας. Σημαντικό ήταν να καθοριστεί ο
τρόπος και οι μέθοδοι που θα χρησιμοποιηθούν και έπειτα να εφαρμοστούν
σωστά. Τέλος, θα δειχθεί πως και οι δύο μέθοδοι είναι αποδεκτοί για την
συγκεκριμένη εφαρμογή, υπό προϋποθέσεις που θα συζητηθούν στα συμπεράσματα.

*** notes :noexport:
- [X] *Εδώ πρέπει να μπουν διαγράμματα από \(filters\ and\ welch\)*
- [X] *Να φέρω τα αναγκαία εδώ σε \(code\ blocks\)*
- [X] Τα έχω ήδη από τα τους φακέλους με τα φίλτρα
- [X] Να τσεκαριστούν για να είμαι σίγουρος
*** Διαγράμματα πυκνότητας ισχύος εισόδου και εξόδου φίλτρων
Η βασική ανάλυση των σημάτων γίνεται στο πεδίο των συχνοτήτων και κυρίως
μέσω της πολυαναφερόμενης μέχρι στιγμής μεθόδου \(Welch\). Αυτό συμβαίνει
καθώς απεικονίζοντας το σήμα στο πεδίο του χρόνου, εκτός της μεταβολής της
ισχύος του σήματος (αν αυτή απεικονίζεται), δεν μπορούμε να καθορίσουμε
τυχών θορυβώδη φάσματα συχνοτήτων. Έτσι πρώτο βήμα είναι να αποτυπωθεί το
φάσμα που επηρεάζει το φάσμα χαμηλών συχνοτήτων, όπου και καταγράφεται η
πληροφορία από τους αισθητήρες. Στις περισσότερες συσκευές οι συχνότητες
που ξεπερνούν τα \(2-5\ kHz\), είτε αναφέρονται σε σήμα ήχου ή/και εικόνας,
είτε αποτελούν θόρυβο από το περιβάλλον πέραν εξαιρέσεων. Στην περίπτωση
που εξετάστηκε στο εργαστήριο, κρίθηκε πως μετά τα \(2\ kHz\) δεν περιείχε
“ουσιώδη” πληροφορία. Έτσι τα φίλτρα που εφαρμόστηκαν ήταν διέλευσης χαμηλών
συχνοτήτων από \(100-2000\ Hz\). Η επιλογή της ταχύτητας κατακρημνισμού,
δηλαδή την κλίση που εμφανίζει η απόκριση του φίλτρου. Στα παρακάτω
διαγράμματα σημειώνεται με μπλε διακεκομμένη γραμμή.

Θα φανεί από τα πρώτα διαγράμματα πως τα \(FIR\) συστήματα παρουσιάζουν πολύ
πιο απότομη κλίση. Αυτό συμβαίνει καθώς ο κύριος παράγοντας που επηρεάζει,
το χαρακτηριστικό αυτό είναι η τάξη του φίλτρου. Όμως ταυτόχρονα αυξάνεται
και η ταχύτητα υπολογισμού αφού δεν καλείται αναδρομικά η έξοδος του
φίλτρου όπως έχει σημειωθεί στην ενότητα των φίλτρων. Κατά την εφαρμογή
των δύο μεθόδων θα διαπιστώσουμε πως τα αποτελέσματα αποκλίνουν σε πολύ
μικρό βαθμό συγκρίνοντας τις τυπικές αποκλίσεις των εξόδων σχετικά με την
είσοδο των φίλτρων.

- Διαγράμματα ισχύος με την μέθοδο \(Welch\) για πεπιεσμένο αέρα
  - \(FIR\) φίλτρο απλού παραθύρου με τάξη ίση με 60 (αριθμός συντελεστών πολυωνύμου)
    #+begin_src jupyter-python :session python3 :async yes :results raw drawer :exports results
from pros_noisefiltering.WT_NoiProc import (plot_comparative_response,
                                            filt_butter_factory)

butter_filter_2000 = filt_butter_factory(filt_order=4, fc_Hz=2000)
ca1_5 = df_tdms_1_5
ca1_10 = df_tdms_1_10

plot_comparative_response(ca1_5,
                          filter_func=fir_2000,
                          response_offset=2e-4,
                          Kolmogorov_offset=4e0,
                          nperseg=NPERSEG,
                          figsize=(8, 4))
plot_comparative_response(ca1_10,
                         filter_func=fir_2000,
                         response_offset=2e-4,
                         Kolmogorov_offset=4e0,
                         nperseg=NPERSEG,
                         figsize=(8, 4))

                         #+end_src

    #+RESULTS:
    :results:
    [[file:./.ob-jupyter/c469ed3fa3a6519d08d5db5af8e8102d4ae24c1c.png]]
    [[file:./.ob-jupyter/626aba17ce5e7b93d79643fefdf4073ca486b9a8.png]]
    :end:
  -  \(IIR\) φίλτρο τύπου \(butterworth\) με τάξη ίση με 2
    #+begin_src jupyter-python :session python3 :async yes :results raw drawer :exports results
plot_comparative_response(ca1_5,
                          filter_func=butter_filter_2000,
                          response_offset=2e-4,
                          Kolmogorov_offset=4e0,
                          nperseg=NPERSEG,
                          figsize=(8, 4))
plot_comparative_response(ca1_10,
                      filter_func=butter_filter_2000,
                      response_offset=2e-4,
                      Kolmogorov_offset=4e0,
                      nperseg=NPERSEG,
                      figsize=(8, 4))


                      #+end_src

   #+RESULTS:
   :results:
   [[file:./.ob-jupyter/0ca1155c1309d384c49d587ebe2854960ee9de1a.png]]
   [[file:./.ob-jupyter/113953e9338dc3c032044042256d6a8d091cef30.png]]
   :end:

- Διαγράμματα ισχύος με την μέθοδο \(Welch\) για παροχή ανέμου από την αεροσήραγγα

  Εδώ θα παρατηρήσει κανείς πως ο θόρυβος είναι λιγότερο εμφανής από τα
  προηγούμενα διαγράμματα. Αυτό συμβαίνει λόγω της χαμηλότερης συχνότητας
  καταγραφής στην περίπτωση της αεροσήραγγας. Όπως αναγράφεται και στους
  τίτλους των διαγραμμάτων τα παρακάτω σήματα καταγράφηκαν με συχνότητα
  \(100\ kHz\). Έτσι λόγω του θεωρήματος \(Niquist\) το μέγιστο φάσμα που
  μπορούμε να απεικονίσουμε υποχωρεί από τα \(250\ kHz\), του πειράματος με
  τον πεπιεσμένο αέρα, στα \(50\ kHz\). Επιλέξαμε την μείωση αυτή, για
  λόγους πειραματισμού καθώς η μείωση του αριθμού των δειγμάτων, προσφέρει
  ταχύτερη επεξεργασία.

   - \(FIR\) φίλτρο απλού παραθύρου με τάξη ίση με 60 (αριθμός συντελεστών πολυωνύμου)
    #+begin_src jupyter-python :session python3 :async yes :results raw drawer :exports results
plot_comparative_response(dfi_i1_w5,
                          filter_func=fir_2000,
                          response_offset=2e-4,
                          Kolmogorov_offset=4e0,
                          nperseg=NPERSEG,
                          figsize=(8, 4))
plot_comparative_response(dfi_i1_w10,
                          filter_func=fir_2000,
                          response_offset=2e-4,
                          Kolmogorov_offset=4e0,
                          nperseg=NPERSEG,
                          figsize=(8, 4))

plot_comparative_response(dfi_i1_w15,
                          filter_func=fir_2000,
                          response_offset=2e-4,
                          Kolmogorov_offset=4e0,
                          nperseg=NPERSEG,
                          figsize=(8, 4))
plot_comparative_response(dfi_i1_w20,
                          filter_func=fir_2000,
                          response_offset=2e-4,
                          Kolmogorov_offset=4e0,
                          nperseg=NPERSEG,
                          figsize=(8, 4))

                          #+end_src

    #+RESULTS:
    :results:
    [[file:./.ob-jupyter/14263a900760581982f9a87f593f8894a7a6c24e.png]]
    [[file:./.ob-jupyter/328c1bf5701027dc0a2c71f2d361c8a21878b1d8.png]]
    [[file:./.ob-jupyter/0bee83ba9176ddfd1d086b65d8e8c09fe4ee5773.png]]
    [[file:./.ob-jupyter/48908e838951101d1cd115e595e1e3fe5767c1f8.png]]
    :end:

   \clearpage
   - \(IIR\) φίλτρο τύπου \(butterworth\) με τάξη ίση με 2
    #+begin_src jupyter-python :session python3 :async yes :results raw drawer :exports results
plot_comparative_response(dfi_i1_w5,
                          filter_func=butter_filter_2000,
                          response_offset=2e-4,
                          Kolmogorov_offset=4e0,
                          nperseg=NPERSEG,
                          figsize=(8, 4))
plot_comparative_response(dfi_i1_w10,
                          filter_func=butter_filter_2000,
                          response_offset=2e-4,
                          Kolmogorov_offset=4e0,
                          nperseg=NPERSEG,
                          figsize=(8, 4))

plot_comparative_response(dfi_i1_w15,
                          filter_func=butter_filter_2000,
                          response_offset=2e-4,
                          Kolmogorov_offset=4e0,
                          nperseg=NPERSEG,
                          figsize=(8, 4))
plot_comparative_response(dfi_i1_w20,
                         filter_func=butter_filter_2000,
                         response_offset=2e-4,
                         Kolmogorov_offset=4e0,
                         nperseg=NPERSEG,
                         figsize=(8, 4))

                         #+end_src

    #+RESULTS:
    :results:
    [[file:./.ob-jupyter/5c357c6e7c3b087f1dffc7b15311fe1c7c978308.png]]
    [[file:./.ob-jupyter/2406695beec08654bec870291d14bb908408e5b3.png]]
    [[file:./.ob-jupyter/1f8daa26a48447a7a2d83fcfdd89f6b52ec7fce1.png]]
    [[file:./.ob-jupyter/ec7b1604fde14b50450f0eca88e54b9b1980342e.png]]
    :end:


- Πίνακας τυπικής απόκλισης εισόδου και εξόδου φίλτρων για πεπιεσμένο αέρα

  Στους παρακάτω πίνακες παραθέτονται οι τυπικές αποκλίσεις των σημάτων
  που χρησιμοποιήθηκαν για την εξαγωγή των ανωτέρω διαγραμμάτων. Σε κάθε
  πίνακα καταγράφονται οι τυπικές αποκλίσεις για το καταγεγραμμένο σήμα,
  όπως επίσης και για τις δύο κατηγορίες φίλτρων.

  \selectlanguage{english}
  #+begin_src jupyter-python :session python3 :async yes :results raw drawer :exports results
from pros_noisefiltering.WT_NoiProc import filt_butter_factory
butter_iir_2000 = filt_butter_factory(fc_Hz=2000, filt_order=4)

fir_out_1_5_ca = ca1_5.filter(fc_Hz=2000,
                              filter_func=fir_2000)
iir_out_1_5_ca = ca1_5.filter(fc_Hz=2000,
                              filter_func=butter_iir_2000)
ca_data_to_filter = [ca1_5, ca1_10]
iir_data_out = []
fir_data_out = []
# filter with fir all data and make a list for the output
for each in ca_data_to_filter:
    fir_data_out.append(each.filter(fc_Hz=2000,
                                    filter_func=fir_2000))

# filter with iir all data and make a list for the output
for each in ca_data_to_filter:
    iir_data_out.append(each.filter(fc_Hz=2000,
                                    filter_func=butter_iir_2000))


table_std_filtering = [[f"{ca_data_to_filter[0].description}",
                        np.std(ca_data_to_filter[0].data),
                        np.std(fir_data_out[0].data),
                        np.std(iir_data_out[0].data)],

                       [f"{ca_data_to_filter[1].description}",
                        np.std(ca_data_to_filter[1].data),
                        np.std(fir_data_out[1].data),
                        np.std(iir_data_out[1].data)]]
print(tabulate(table_std_filtering,
               headers=["Record description",
                        "std raw signal",
                        "FIR",
                        "IIR"],
               floatfmt=".4f" ))
# print(np.std(fir_out_1_5_ca.data), np.std(ca1_5.data))
# print(np.std(iir_out_1_5_ca.data), np.std(ca1_5.data))
# butter_iir_200 = filt_butter_factory(fc_Hz=200, filt_order=4)

  #+end_src
  #+RESULTS:
  :results:
  : Record description      std raw signal     FIR     IIR
  : --------------------  ----------------  ------  ------
  : Inverter on, WS=5               0.0434  0.0245  0.0241
  : Inverter on, WS=10              0.0841  0.0760  0.0759
  :end:

\selectlanguage{greek}
\clearpage
- Πίνακας τυπικής απόκλισης εισόδου και εξόδου φίλτρων για αεροσήραγγα
  \selectlanguage{english}
  #+begin_src jupyter-python :session python3 :async yes :results raw drawer :exports results
from pros_noisefiltering.WT_NoiProc import filt_butter_factory
butter_iir_2000 = filt_butter_factory(fc_Hz=2000, filt_order=4)

fir_out_1_5_ca = ca1_5.filter(fc_Hz=2000,
                              filter_func=fir_2000)
iir_out_1_5_ca = ca1_5.filter(fc_Hz=2000,
                              filter_func=butter_iir_2000)
wt_data_to_filter = [dfi_i1_w5, dfi_i1_w10,
                     dfi_i1_w15, dfi_i1_w20]
iir_data_out = []
fir_data_out = []
# filter with fir all data and make a list for the output
for each in wt_data_to_filter:
    fir_data_out.append(each.filter(fc_Hz=2000,
                                    filter_func=fir_2000))

# filter with iir all data and make a list for the output
for each in wt_data_to_filter:
    iir_data_out.append(each.filter(fc_Hz=2000,
                                    filter_func=butter_iir_2000))


table_std_filtering = [[f"{wt_data_to_filter[0].description}",
                        np.std(wt_data_to_filter[0].data),
                        np.std(fir_data_out[0].data),
                        np.std(iir_data_out[0].data)],

                       [f"{wt_data_to_filter[1].description}",
                        np.std(wt_data_to_filter[1].data),
                        np.std(fir_data_out[1].data),
                        np.std(iir_data_out[1].data)],

                       [f"{wt_data_to_filter[2].description}",
                        np.std(wt_data_to_filter[2].data),
                        np.std(fir_data_out[2].data),
                        np.std(iir_data_out[2].data)],
                       [f"{wt_data_to_filter[3].description}",
                        np.std(wt_data_to_filter[3].data),
                        np.std(fir_data_out[3].data),
                        np.std(iir_data_out[3].data)],
                       ]
print(tabulate(table_std_filtering,
               headers=["Record description",
                        "std raw signal",
                        "FIR",
                        "IIR"],
               floatfmt=".4f" ))
# print(np.std(fir_out_1_5_ca.data), np.std(ca1_5.data))
# print(np.std(iir_out_1_5_ca.data), np.std(ca1_5.data))
# butter_iir_200 = filt_butter_factory(fc_Hz=200, filt_order=4)

  #+end_src

  #+RESULTS:
  :results:
  : Record description            std raw signal     FIR     IIR
  : --------------------------  ----------------  ------  ------
  : Inverter On, WS=5, 100kHz             0.0385  0.0074  0.0083
  : Inverter On, WS=10, 100kHz            0.0400  0.0124  0.0130
  : Inverter On, WS=15, 100kHz            0.0421  0.0279  0.0281
  : Inverter On, WS=20, 100kHz            0.0566  0.0483  0.0484
  :end:

\selectlanguage{greek}
     
*** notes :noexport:
- \(Welch\ method\ filtered-raw\ signal\) [100%]
  - [X] Διαγράμματα για κομπρεσέρ
  - [X] Διαγράμματα για αεροσήραγγα
  - [X] τυπικές αποκλείσεις
* Συμπεράσματα
Όπως αναφέρθηκε αρκετές φορές και οι δύο κατηγορίες φίλτρων αποφέρουν αποδεκτά
αποτελέσματα. Η σύγκριση μπορεί να γίνει λοιπόν στην ταχύτητα
υπολογισμού των εξόδων όμως, αυτή *εξαρτάται ισχυρά* από την ποσότητα των
δειγμάτων του σήματος που επιθυμούμε να επεξεργαστούμε. Έτσι κυρίαρχο
ρόλο στην επιλογή του φίλτρου λαμβάνει η συχνότητα δειγματοληψίας (\(fs\)) και η
χρονική περίοδος που θα θέλαμε να αναλύσουμε. Ταυτόχρονα την \(fs\) καθορίζει
και το μέγιστο φάσμα συχνοτήτων σήματος που θέλουμε να καταγράψουμε, λόγω του
θεωρήματος της δειγματοληψίας. Επομένως είναι εύλογο να προσαρμόζεται η
επιλογή του φίλτρου σε σχέση με τον τύπο θορύβου (φάσμα συχνοτήτων)
που προσπαθούμε να απορρίψουμε, την συχνότητα δειγματοληψίας και την χρονική
περίοδο καταγραφής. Στην εγκατάσταση που εξετάστηκε, λόγω έντονων Η/Μ
παρεμβολών, παρουσιάστηκε ήπιος θόρυβος σε φάσμα άνω των \(3-5\ kHz\) με εμφανή
στοιχεία μετά τα \(12\ kHz\). Λόγω της μεγάλης διαφοράς των φασμάτων θορύβου και
επιθυμητού σήματος, μπορούμε να χρησιμοποιήσουμε χωρίς πρόβλημα φίλτρα τύπου
\(FIR\) για την απόρριψη του. Η τυπική απόκλιση της εξόδου και των δύο τύπων
διαφέρουν σε αμελητέο βαθμό για την διάρκεια των επτά (7) δευτερολέπτων που
επεξεργάστηκαν.

Μια ακόμα κύρια παράμετρος για την επιλογή αποτέλεσε η ποιότητα του σήματος
εξόδου, καθώς και η ακρίβεια του φάσματος διέλευσης συχνοτήτων που
προορίζονταν για επεξεργασία. Καταλήξαμε πως η επιθυμητή τιμή της τυπικής
απόκλισης του σήματος εξόδου θα εμφανίζει πτώση κατά μια τάξη μεγέθους
τουλάχιστον, σχετικά με την είσοδο του σήματος. Παρατηρούμε στους πίνακες της
προηγούμενης ενότητας ότι, εμφανίζεται σημαντική πτώση της τυπικής απόκλισης
για ταχύτητες μέχρι 5 \((m/s)\) και όσο αυξάνεται η ταχύτητα του ανέμου η διαφορά
μειώνεται. Αυτό συμβαίνει λόγω της αύξησης της ισχύος του σήματος στις χαμηλές
συχνότητες. Όπως προαναφέρθηκε η πληροφορία της ταχύτητας του ανέμου παρέχεται
σε χαμηλές συχνότητες από το αισθητήριο όργανο με αποτέλεσμα να υπερκαλύπτεται
ο θόρυβος στις υψηλές ταχύτητες. Το συγκεκριμένο φαινόμενο μπορεί να
χρησιμοποιηθεί προς όφελος της ερευνητικής ομάδας, εφαρμόζοντας το ανάλογο
φίλτρο μόνο όταν καταγράφονται χαμηλές ταχύτητες ανέμου (ιδανικά \(0-10\ (m/s)\)).
Σε υψηλότερες ταχύτητες εφαρμόζοντας την τεχνική του αποδεκατισμού σε συνδυασμό
με ένα φίλτρο κατά της αλλοίωσης, όπως παρουσιάστηκε στο κεφάλαιο
[[sec:decimation-chapter]], δύναται να επιτύχουμε όμοια αποτελέσματα αφού
μειώνοντας την συχνότητα καταγραφής στην πράξη μειώνεται και το πλήθος των
δειγμάτων άρα και το φάσμα συχνοτήτων που περιέχει το αποδεκατισμένο σήμα.

Στην περίπτωση που απαιτείται λεπτομερή και αναλυτική απόρριψη φασμάτων
συχνοτήτων, προτείνεται ο συνδυασμός των δύο κατηγοριών φίλτρων. Αρχικά θα
πρέπει να εφαρμοστεί ο τύπος \(FIR\). Έτσι απομειώνεται μεγάλο μέρος του θορύβου
σε υψηλές συχνότητες, μετά τα \(5-8\ kHz\) επιλέγοντας την συχνότητα αποκοπής στα
2 \(kHz\), και στην συνέχεια με την εφαρμογή ενός \(IIR\) φίλτρου λόγω μεγαλύτερης
ακρίβειας της δεύτερης κατηγορίας να αποκτήσουμε πιο “καθαρό” σήμα τελικά στην
έξοδο. Συνδυάζοντας τις δύο κατηγορίες φίλτρων αποφέρει μεν καλύτερα αποτελέσματα,
όμως αυξάνει σημαντικά τον χρόνο επεξεργασίας λόγος που συνίσταται μόνο σε
ειδικές περιπτώσεις ή/και μετά από σχετικές προϋποθέσεις του πειράματος.

Στόχος της παρούσας εργασίας ήταν ο πλήρης καθορισμός του θορύβου που
καταγράφηκε από τον αισθητήρα,
η επιλογή κατάλληλου φίλτρου για την απόρριψη των ανεπιθύμητων συχνοτήτων όπως
και η εύρεση της βέλτιστης μεθόδου ανάλογα την εκάστοτε περίπτωση (ταχύτητα
ανέμου, ποσότητα θορύβου, κ.α.). Για το μέλλον, σημαντικές παράμετροι που δεν
εξετάστηκαν πλήρως εδώ είναι η προέλευση καθώς και ο καθορισμός της ισχύος και
απόστασης της κάθε πηγής ηλεκτρομαγνητικών παρεμβολών στον περιβάλλοντα χώρο.
Μετά από υποθέσεις, καταλήξαμε πως υπάρχουν έτερες πηγές Η/Μ κυμάτων που ενδέχεται
να επηρεάζουν το καταγεγραμμένο σήμα. Εν κατακλείδι το ποσό του θορύβου ενώ
ισχυρό δεν καταστρέφει την πληροφορία της ταχύτητας του ανέμου από το
αισθητήριο όργανο και επομένως δεν υπάρχει ανάγκη εφαρμογής τεχνικών
επαναδημιουργίας του αρχικού σήματος και οι μέθοδοι του αποδεκατισμού και
φιλτραρίσματος κρίνονται επαρκείς.
\clearpage
* Βιβλιογραφία
\selectlanguage{english}
#+bibliography: ./diss_bibliography.bib
[cite/n:@SULAIMAN20223117]
[cite/n:@auto-fir-from-analog]
[cite/n:@iir-survey]
[cite/n:@SMITH2003333]
[cite/n:@pitot-standards]
[cite/n:@LAI200314]
[cite/n:@LAI200350]
[cite/n:@LAI200361]
[cite/n:@LAI200398]
[cite/n:@Re-on-pitot]
[cite/n:@sig-proc-first]
[cite/n:@oppenheim99]
[cite/n:@SMITH200387]
[cite/n:@SMITH2003169]
[cite/n:@SMITH2003185]
[cite/n:@SMITH2003225]
[cite/n:@SMITH2003243]
[cite/n:@SMITH2003261]
[cite/n:@SMITH2003277]
[cite/n:@SMITH2003285]
[cite/n:@SMITH2003319]
#+print_bibliography:
* Source blocks :noexport: :noexport:
** [#A] WHAT IS LOADED TO JUPYTER KERNEL
#+begin_src jupyter-python :session python3 :async yes :results raw drawer
%whos
#+end_src

#+RESULTS:
:results:
#+begin_example
Variable                    Type                    Data/Info
-------------------------------------------------------------
CHAN_NAME                   str                     Wind2
FIGSIZE                     tuple                   n=2
FIGSIZE_STD                 tuple                   n=2
FOLDER_FOR_DATA             PosixPath               /mnt/data_folder/measurem<...>2/new_record_prop_channel
GROUP_NAME                  str                     Wind Measurement
Graph_data_container        type                    <class 'pros_noisefilteri<...>er.Graph_data_container'>
NPERSEG                     int                     65536
Path                        type                    <class 'pathlib.Path'>
SEPARATING_LINE             str                     
TDMS_FNAME                  str                     Data.tdms
TdmsFile                    type                    <class 'nptdms.tdms.TdmsFile'>
WT_NoiseChannelProc         type                    <class 'pros_noisefilteri<...>roc.WT_NoiseChannelProc'>
a                           ndarray                 5: 5 elems, type `float64`, 40 bytes
ab                          ndarray                 5: 5 elems, type `float64`, 40 bytes
anti_aliased                ndarray                 31000: 31000 elems, type `float64`, 248000 bytes (242.1875 kb)
anti_aliased_50             ndarray                 310000: 310000 elems, type `float64`, 2480000 bytes (2.3651123046875 Mb)
b                           ndarray                 5: 5 elems, type `float64`, 40 bytes
bb                          ndarray                 5: 5 elems, type `float64`, 40 bytes
butter_200                  ndarray                 3100000: 3100000 elems, type `float64`, 24800000 bytes (23.651123046875 Mb)
butter_2000                 ndarray                 3100000: 3100000 elems, type `float64`, 24800000 bytes (23.651123046875 Mb)
butter_filter_2000          function                <function filt_butter_fac<...>butter at 0x7f2e1f975b20>
butter_iir_2000             function                <function filt_butter_fac<...>butter at 0x7f2e1f6934c0>
ca1_0                       WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e1fd1ff10>
ca1_10                      WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e3026ec90>
ca1_5                       WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e3026ed50>
ca_data_to_filter           list                    n=2
ca_meas_dir                 PosixPath               /mnt/data_folder/measurem<...>op_channel/compressed air
comp_air_dir                str                     compressed air
data_CA_inv_0_WS_0          str                     ca0_0.1
data_CA_inv_0_WS_11         str                     ca0_10.1
data_CA_inv_0_WS_5          str                     ca0_5.1
data_CA_inv_1_WS_0          str                     ca1_0.1
data_CA_inv_1_WS_10         str                     ca1_10.1
data_CA_inv_1_WS_5          str                     ca1_5.1
data_inv_inv_0_WS_0         str                     in0_0.1
data_inv_inv_1_WS10         str                     in1_10.1
data_inv_inv_1_WS15         str                     in1_15.1
data_inv_inv_1_WS_0         str                     in1_0.1
data_inv_inv_1_WS_20        str                     in1_20.1
data_inv_inv_1_WS_5         str                     in1_5.1
dec_50kHz                   WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e1fd16450>
dec_5kHz                    WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e1fd548d0>
dec_at_50_kHz               str                     de50.1
dec_at_5_kHz                str                     de5.1
dec_meas_dir                PosixPath               /mnt/data_folder/measurem<...>d_prop_channel/Decimation
df_tdms_0_0                 WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e3c0c0310>
df_tdms_0_10                WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e3026e390>
df_tdms_0_5                 WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e3026ed10>
df_tdms_1_0                 WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e3026ded0>
df_tdms_1_10                WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e3026ec90>
df_tdms_1_5                 WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e3026ed50>
dfi_i0_w0                   WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e302728d0>
dfi_i1_w0                   WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e30286d50>
dfi_i1_w10                  WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e30287750>
dfi_i1_w15                  WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e30287710>
dfi_i1_w20                  WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e30287790>
dfi_i1_w5                   WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e30286610>
each                        WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e30287790>
f                           ndarray                 328: 328 elems, type `float64`, 2624 bytes
filt_butter_factory         function                <function filt_butter_factory at 0x7f2e3b0fc400>
fir_200                     function                <function fir_factory_con<...>filter at 0x7f2e1fe84900>
fir_2000                    function                <function fir_factory_con<...>filter at 0x7f2e1fd837e0>
fir_data_out                list                    n=4
fir_factory_constructor     function                <function fir_factory_con<...>ructor at 0x7f2e30230fe0>
fir_filt_200                ndarray                 3100000: 3100000 elems, type `float64`, 24800000 bytes (23.651123046875 Mb)
fir_filt_2000               ndarray                 3100000: 3100000 elems, type `float64`, 24800000 bytes (23.651123046875 Mb)
fir_out_1_5_ca              WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e1f1c6350>
fs                          int                     30
hb                          ndarray                 512: 512 elems, type `complex128`, 8192 bytes
iir_data_out                list                    n=4
iir_out_1_5_ca              WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e1f1c7990>
in1_0_av100                 WT_NoiseChannelProc     <pros_noisefiltering.WT_N<...>object at 0x7f2e1fe0b390>
inv_meas_dir                str                     inverter
item                        str                     in1_20.1
l_tdms_CA                   list                    n=6
l_tdms_Inv                  list                    n=6
math                        module                  <module 'math' from '/usr<...>311-x86_64-linux-gnu.so'>
medec                       int                     100
np                          module                  <module 'numpy' from '/us<...>kages/numpy/__init__.py'>
path_ca_meas                PosixPath               /mnt/data_folder/measurem<...>sed air/ca1_0.1/Data.tdms
path_comp                   PosixPath               /mnt/data_folder/measurem<...>ord_prop_channel/inverter
path_dec_meas_50_kHz        PosixPath               /mnt/data_folder/measurem<...>cimation/de50.1/Data.tdms
path_dec_meas_5_kHz         PosixPath               /mnt/data_folder/measurem<...>ecimation/de5.1/Data.tdms
plot_comparative_response   function                <function plot_comparativ<...>sponse at 0x7f2e3ca68e00>
plot_spect_comb2            function                <function plot_spect_comb2 at 0x7f2e30207f60>
plt                         module                  <module 'matplotlib.pyplo<...>es/matplotlib/pyplot.py'>
raw_signal_CA               list                    n=6
scipy                       module                  <module 'scipy' from '/us<...>kages/scipy/__init__.py'>
sign                        Graph_data_container    <pros_noisefiltering.Grap<...>object at 0x7f2e1facd950>
signal                      module                  <module 'scipy.signal' fr<...>cipy/signal/__init__.py'>
table                       list                    n=6
table_filts                 list                    n=2
table_std                   list                    n=4
table_std_filtering         list                    n=4
tablexydec                  list                    n=3
tablexyrec                  list                    n=3
tablexysign                 list                    n=3
tabulate                    function                <function tabulate at 0x7f2e1fd81080>
tdms_raw_WT                 TdmsFile                <nptdms.tdms.TdmsFile object at 0x7f2e641a6810>
tdms_raw_WT_50kHz           TdmsFile                <nptdms.tdms.TdmsFile object at 0x7f2e1fd49390>
tdms_raw_WT_5kHz            TdmsFile                <nptdms.tdms.TdmsFile object at 0x7f2e640e97d0>
ts                          ndarray                 150: 150 elems, type `float64`, 1200 bytes
wb                          ndarray                 512: 512 elems, type `float64`, 4096 bytes
wt_data_to_filter           list                    n=4
x                           TdmsFile                <nptdms.tdms.TdmsFile object at 0x7f2e30271590>
y                           ndarray                 31000: 31000 elems, type `float64`, 248000 bytes (242.1875 kb)
y_filtfilt                  ndarray                 150: 150 elems, type `float64`, 1200 bytes
y_lfilter                   ndarray                 150: 150 elems, type `float64`, 1200 bytes
yerr                        ndarray                 150: 150 elems, type `float64`, 1200 bytes
yraw                        ndarray                 150: 150 elems, type `float64`, 1200 bytes
ys                          ndarray                 150: 150 elems, type `float64`, 1200 bytes
z                           ndarray                 328: 328 elems, type `float64`, 2624 bytes
#+end_example
:end:
** FFT

#+begin_src jupyter-python :session none  :async yes :results drawer

class FftNew:
    """# Better approach to fft.

    Here is an example of how the calculation of fft for a given
    signal is implemented.

    Main function
    ----------
    >>>def fft_calc_and_plot(self):
    >>>    num_samp = len(self.time_sec)
    >>>    # compute fft
    >>>    fhat = fft(self.sig, num_samp)
    >>>    # Power spectrum (power/freq)
    >>>    psd = fhat * np.conj(fhat) / num_samp
    >>>    # create x-axis (frequencies)
    >>>    freq = (1/(self.time_interv * num_samp)) * np.arange(num_samp)
    >>>    # plot only first half (possitive)
    >>>    plt_pos = np.arange(1, np.floor(num_samp/2), dtype=int)

    Usage
    ----------
    >>>FftNew(df_tdms_1_0.decimate(dec=5, offset=0),
    >>>     title='Decimation number 5 CA INV ON').fft_calc_and_plot()

    Reference
    ----------
    http://databookuw.com/
    """

    def __init__(self, sign, title):
        """# Object initialize.

        This function constructs an object for a given signal
        which will be plotted in the frequency domain.
        """
        self.plt_title = title
        self.samp_rate = sign.fs_Hz
        self.sig = sign.data
        self.ind = sign.data_as_Series.index
        self.time_interv = 1 / int(self.samp_rate)
        self.time_sec = self.ind * self.time_interv

    def fft_calc_and_plot(self):
        """# FFT calculation and plotting.

        This function is used to calculate and plot a signal in the
        frequency domain using the fft library from numpy.
        """
        num_samp = len(self.time_sec)
        # compute fft
        fhat = fft(self.sig, num_samp)
        # Power spectrum (power/freq)
        psd = fhat * np.conj(fhat) / num_samp
        # create x-axis (frequencies)
        freq = (1/(self.time_interv * num_samp)) * np.arange(num_samp)
        # plot only first half (possitive)
        plt_pos = np.arange(1, np.floor(num_samp/2), dtype=int)

        fig, axs = plt.subplots(2, 1)

        plt.sca(axs[0])
        plt.grid(True, which='both')
        plt.title(self.plt_title)
        plt.xlabel('Time [s]')
        plt.ylabel('Amplitute (Voltage)')
        plt.plot(self.time_sec, self.sig)
        # plt.loglog(freq[plt_pos],(PSD[plt_pos]))

        plt.sca(axs[1])
        plt.loglog(freq[plt_pos], abs(psd[plt_pos]))
        plt.title('Frequency domain')
        plt.xlabel('Frequencies [Hz]')
        plt.ylabel('Power/Freq')
        plt.grid(True, which='both')


#+end_src

#+RESULTS:
: 79f950729e3c1baa1f0d390325623460

#+begin_src jupyter-python :session none  :async yes :results drawer

#+end_src

** LaTeX blocks
*** 2 image side by side


\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
\centering
\includegraphics[width=.8 \linewidth]{./decimation/with_aliasing.png}
\caption{Αποδεκατισμός σήματος στα 5 \(kHz\)}
\label{fig:sub1}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
\centering
\includegraphics[width=.8 \linewidth]{./decimation/anti_aliasing_fir.png}
\caption{Αποδεκατισμός με φίλτρο κατά της αλλοίωσης}
\label{fig:sub2}
\end{subfigure}
\caption{Αποδεκατισμός σήματος με και χωρίς επεξεργασία κατά της αλλοίωσης.}
\label{fig:test}
\end{figure}
* GO BUTTONS :noexport:
# <(agenda)> file:~/org/agenda.org
# <(code)>
# <(diss-notes)>
# <(edit latex headers file)>
# <(apa citation file)>
# <(go to presentation)>
