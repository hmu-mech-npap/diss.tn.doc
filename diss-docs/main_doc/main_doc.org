:ORG-PROPERTIES:
#+LANGUAGE: gr
#+STARTUP: latexpreview showeverything
#+OPTIONS: tags:t toc:nil
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+EXCLUDE_TAGS: noexport
#+TAGS:  noexport(n)
#+INCLUDE: latex-headers-diss.org
:END:
\clearpage \tableofcontents \clearpage
* Imports :noexport:
#+begin_src jupyter-python :session py :async yes :results drawer
import numpy as np
import math
import matplotlib.pyplot as plt
from scipy import signal
from tabulate import tabulate
#+end_src

#+RESULTS:
:results:
:end:

#+begin_src jupyter-python :session py :async yes :results raw drawer

from pathlib import Path
from matplotlib import pyplot as plt
import scipy.signal as signal
import numpy as np

from nptdms import TdmsFile

from pros_noisefiltering.WT_NoiProc import WT_NoiseChannelProc, Graph_data_container
from pros_noisefiltering.gen_functions import plot_spect_comb2

#+end_src
#+RESULTS:
:results:
:end:
** Basic folders and data
#+begin_src jupyter-python :session py :async yes :results raw drawer
FOLDER_FOR_DATA = Path(
    '/mnt/data_folder/measurements_12_05_22/new_record_prop_channel/')
if not FOLDER_FOR_DATA.exists():
    FOLDER_FOR_DATA = Path('D:/_data/WEL/WEL20220512/')

# %% CONSTANTS
FIGSIZE_STD = (6, 6)
# Constant directories and names for the .tdms file structure
# Dir name
TDMS_FNAME = 'Data.tdms'
GROUP_NAME = 'Wind Measurement'
CHAN_NAME = 'Wind2'

# %%
# Dir names for the Compressed air measurment
#
# =================================================
#
# Here the Compressed air measurements are imported
#
# =================================================
#
comp_air_dir = 'compressed air'

# %% preparing tdms files
# New renamed folders for rec version information
data_CA_inv_0_WS_0 = 'ca0_0.1'
data_CA_inv_0_WS_5 = 'ca0_5.1'
data_CA_inv_0_WS_11 = 'ca0_10.1'
data_CA_inv_1_WS_0 = 'ca1_0.1'
data_CA_inv_1_WS_5 = 'ca1_5.1'
data_CA_inv_1_WS_10 = 'ca1_10.1'

path_comp = FOLDER_FOR_DATA / comp_air_dir

# CA stands for compressed air

raw_signal_CA = [data_CA_inv_0_WS_0, data_CA_inv_0_WS_5,
                 data_CA_inv_0_WS_11, data_CA_inv_1_WS_0,
                 data_CA_inv_1_WS_5, data_CA_inv_1_WS_10]

l_tdms_CA = []

for item in raw_signal_CA:
    x = TdmsFile(Path(f'{path_comp}/{item}', TDMS_FNAME))
    l_tdms_CA.append(x)

# %%
# [print(x) for x in l_tdms_CA[0][GROUP_NAME].channels()]
# %%
GROUP_NAME = 'Wind Measurement'
CHAN_NAME = 'Wind2'


df_tdms_0_0 = WT_NoiseChannelProc.from_tdms(
    l_tdms_CA[0][GROUP_NAME][CHAN_NAME],
    desc='Inverter off, WS=0')
df_tdms_0_5 = WT_NoiseChannelProc.from_tdms(
    l_tdms_CA[1][GROUP_NAME][CHAN_NAME],
    desc='Inverter off, WS=5')
df_tdms_0_10 = WT_NoiseChannelProc.from_tdms(
    l_tdms_CA[2][GROUP_NAME][CHAN_NAME],
    desc='Inverter off, WS=11')
df_tdms_1_0 = WT_NoiseChannelProc.from_tdms(
    l_tdms_CA[3][GROUP_NAME][CHAN_NAME],
    desc='Inverter on, WS=0')
df_tdms_1_5 = WT_NoiseChannelProc.from_tdms(
    l_tdms_CA[4][GROUP_NAME][CHAN_NAME],
    desc='Inverter on, WS=5')
df_tdms_1_10 = WT_NoiseChannelProc.from_tdms(
    l_tdms_CA[5][GROUP_NAME][CHAN_NAME],
    desc='Inverter on, WS=10')

#
# =================================================
#
# Here the Inverter measurements are imported
#
# =================================================
#
# %%
inv_meas_dir = 'inverter'
# Inverter measurements of interest
data_inv_inv_0_WS_0 = 'in0_0.1'
data_inv_inv_1_WS_0 = 'in1_0.1'
data_inv_inv_1_WS_5 = 'in1_5.1'
data_inv_inv_1_WS10 = 'in1_10.1'
data_inv_inv_1_WS15 = 'in1_15.1'
data_inv_inv_1_WS_20 = 'in1_20.1'


path_comp = FOLDER_FOR_DATA / inv_meas_dir

# suffixes:
# - CA : compressed air
# - Inv : Inverter
# - DEC : decimation

raw_signal_CA = [data_inv_inv_0_WS_0, data_inv_inv_1_WS_0,
                 data_inv_inv_1_WS_5,
                 data_inv_inv_1_WS10, data_inv_inv_1_WS15,
                 data_inv_inv_1_WS_20]

l_tdms_Inv = []

for item in raw_signal_CA:
    x = TdmsFile(Path(f'{path_comp}/{item}', TDMS_FNAME))
    l_tdms_Inv.append(x)

# %%
# [print(x) for x in l_tdms_Inv[0][GROUP_NAME].channels()]
# %%
dfi_i0_w0 = WT_NoiseChannelProc.from_tdms(
    l_tdms_Inv[0][GROUP_NAME][CHAN_NAME],
    desc='Inverter Off, WS=0, 100kHz')
dfi_i1_w0 = WT_NoiseChannelProc.from_tdms(
    l_tdms_Inv[1][GROUP_NAME][CHAN_NAME],
    desc='Inverter On, WS=0, 100kHz')
dfi_i1_w5 = WT_NoiseChannelProc.from_tdms(
    l_tdms_Inv[2][GROUP_NAME][CHAN_NAME],
    desc='Inverter On, WS=5, 100kHz')
dfi_i1_w10 = WT_NoiseChannelProc.from_tdms(
    l_tdms_Inv[3][GROUP_NAME][CHAN_NAME],
    desc='Inverter On, WS=10, 100kHz')
dfi_i1_w15 = WT_NoiseChannelProc.from_tdms(
    l_tdms_Inv[4][GROUP_NAME][CHAN_NAME],
    desc='Inverter On, WS=15, 100kHz')
dfi_i1_w20 = WT_NoiseChannelProc.from_tdms(
    l_tdms_Inv[5][GROUP_NAME][CHAN_NAME],
    desc='Inverter On, WS=20, 100kHz')

#+end_src
#+RESULTS:
:results:
:end:
* Εισαγωγή
#+ODT: <text:p text:style-name="PageBreak"/>
Σε πολλές περιπτώσεις η ανάγκη της επεξεργασίας σημάτων, όπως στις
τηλεπικοινωνίες μετά ή/και πριν την μετάδοση από τον πομπό προς τον
δέκτη, και η εκλογή πληροφοριών από αυτό έθεσαν από νωρίς το πρόβλημα
των παρεμβολών του περιβάλλοντος στις ηλεκτρονικές συσκευές και την
ανάγκη απομόνωσης του φάσματος των συχνοτήτων που χρησιμοποιούνται για
κάθε λειτουργία.

Η απομόνωση αυτή μπορεί να επιτευχθεί είτε μέσω συμβατικών φίλτρων,
δηλαδή αντιστάσεις και πυκνωτές κατάλληλα τοποθετημένους στο κύκλωμα που
συλλέγει την τάση (*ρεύμα μέτρησης*), είτε με την χρήση μεθόδων ψηφιακής
επεξεργασίας σημάτων \(DSP\).
Στις μέρες μας προτιμάται ο 2ος τρόπος λόγω
της ραγδαίας εξέλιξης των Η/Υ με αποτέλεσμα να επιφέρει μεγαλύτερο
κόστος η εγκατάσταση αναλογικών φίλτρων σε κάθε θέση που απαιτείται.

Οι μέθοδοι αλλά και η πληθώρα συστημάτων λήψης και ανάλυσης σημάτων τις
τελευταίες δεκαετίες έχουν, αφενός εξελιχθεί ως προς την υπολογιστική
ισχύ με ταχύτερους επεξεργαστές και αλγόριθμους, αφετέρου δίνουν
πλέον την δυνατότητα διαχείρισης των πληροφοριών απομακρυσμένα με
αποτέλεσμα την ευρύτερη εγκαθίδρυση των ψηφιακών μέσων επεξεργασίας
σημάτων. Στις μέρες μας η ανάγκη διαχείρισης ολοένα και μεγαλύτερα
αρχεία δεδομένων με καλύτερη ακρίβεια οδήγησε την επιστημονική κοινότητα
στην χρήση της μεθόδου *μετα-επεξεργασίας* (\(post-processing\)). Βασικό όφελος
ήταν η δυνατότητα επαναληψιμότητας του πειράματος και σύγκρισης των
αποτελεσμάτων σε όλο τον κόσμο, ουσιαστική αρχή της πειραματικής
διαδικασίας. Έτσι με την χρήση προγραμματισμού δίνεται πλέον η
δυνατότητα στον ερευνητή, να δημιουργεί ένα περιβάλλον προσομοίωσης και
να δοκιμάζει διάφορες λύσεις χωρίς να επισκεφτεί την πειραματική διάταξη
σε πολλές περιπτώσεις μετά την καταγραφή των μετρήσεων.

Στην παρούσα εργασία θα πραγματευτούμε την απομείωση συγκεκριμένων
συχνοτήτων με την χρήση Ψηφιακής Ανάλυσης Σημάτων και φίλτρων, διαφόρων
κατηγοριών. Στο πλαίσιο αυτό θα παρουσιαστεί, μια μελέτη που
πραγματοποιήθηκε σε συνεργασία με το εργαστήριο Αιολικής Ενέργειας του
τμήματος Μηχανολόγων Μηχανικών στο Ελληνικό Μεσογειακό Πανεπιστήμιο με
θέμα την απόρριψη θορύβου από αισθητήριο όργανο για την μέτρηση της
ταχύτητας ανέμου σε περιβάλλον με ενισχυμένες παρεμβολές. Η
ιδιαιτερότητα που παρουσιάστηκε στην εγκατάσταση ήταν παρεμβολές από
ηλεκτρικό μετασχηματιστή, που όμως ήταν αδύνατο να
αφαιρεθεί, και ταυτόχρονα ο σχεδιασμός όπως και η τοποθέτηση ενός
αναλογικού φίλτρου θα ενέτασαν μεγάλο κόστος και περιπλοκότητα. Θα
αναλυθούν οι δομές σημάτων που επεξεργάστηκαν καθώς και οι τύποι των
φίλτρων που χρησίμευσαν στην απομόνωση των ζητούμενων σημάτων. Επίσης θα
υπάρξει παράθεση των θετικών και αρνητικών που παρατηρήθηκαν κατά την
διάρκεια εκτέλεσης της επεξεργασίας και καταγραφής των δεδομένων (τύποι
αρχείων δεδομένων).
-----
* Ιστορική αναδρομή
:PROPERTIES:
:ATTR_ODT: :page-break t
:END:
Από την εποχή της ανακάλυψης του Απειροστικού λογισμού \(calculus\)
τον 17ο αιώνα, οι επιστήμονες προσπαθούν να εξηγήσουν τα φυσικά
φαινόμενα με μαθηματικά μοντέλα χρησιμοποιώντας εξισώσεις
συνεχών μεταβλητών και διαφορικές εξισώσεις. Χρησιμοποιήθηκαν
τεχνικές αριθμητικής επίλυσης όταν οι αναλυτικές λύσεις δεν
ήταν εφικτό να καθοριστούν. Αργότερα μαθηματικοί του 18ου αιώνα
όπως οι Ευλερ, Μπερνούλι και Λαγκραντζ κατασκεύασαν μεθόδους
για αριθμητική ολοκλήρωση και την εισαγωγή εξισώσεων συνεχών
μεταβλητών. Μια ιστορική μελέτη από τους \(Heideman,\ Johnson\) και
${Burrus}$ (1984) έδειξε ότι ο ${Gauss}$ είχε ανακαλύψει την βασική
αρχή του γρήγορου μετασχηματισμού ${Fourier}$ ήδη από το 1805, πριν
την δημοσίευση της διατριβής του .... πάνω στην απεικόνιση
αρμονικών σειρών εξισώσεων.
Στις αρχές του 1950, η ανάλυση σημάτων γινόταν κυρίως με
αναλογικά συστήματα κατασκευασμένα από ηλεκτρονικά κυκλώματα
ακόμα και με μηχανικές συσκευές. Ενώ οι Η/Υ είχαν κάνει την
είσοδό τους ήδη σε επιχειρήσεις και επιστημονικά εργαστήρια
ήταν ακόμα ακριβοί με περιορισμένες δυνατότητες. Περίπου εκείνη
την εποχή ξεκίνησε η ανάγκη για πιο εξειδικευμένες μεθόδους
στην ανάλυση σημάτων και στράφηκε η προσοχή στην ανάλυση
διακριτού χρόνου σημάτων. Μια από τις πρώτες εφαρμογές των Η/Υ
ήταν η καταγραφή σεισμικών δονήσεων σε πλατφόρμες εξόρυξης
πετρελαίου, που καταγράφονταν σε μαγνητική ταινία για να επεξεργαστούν
αργότερα. Η διαδικασία αυτή δεν μπορούσε να γίνει σε
πραγματικό χρόνο, καθώς μπορεί να χρειαζόντουσαν κάποια
λεπτά ακόμα και ώρες για την επεξεργασία μερικών δευτερολέπτων
από τις μαγνητικές ταινίες.
    Την ίδια εποχή για όσους είχαν την δυνατότητα να χρησιμοποιήσουν
ψηφιακούς υπολογιστές, ήταν εύκολο να δημιουργήσουν ένα περιβάλλον
προσομοίωσης για να μελετήσουν νέους αλγόριθμους και μεθόδους
ανάλυσης σημάτων πριν χρησιμοποιήσουν πόρους και μηχανικούς για την
κατασκευή της αναλογικής συσκευής που τελικά θα εκτελούσε την
επιθυμητή εργασία. Παραδείγματα τέτοιων προσομοιώσεων ήταν εκείνες
που πραγματοποιήθηκαν στο Εργαστήριο Λίνκολν και στα Εργαστήρια Μπελλ
όπου προσομοιώθηκε ένας κωδικοποιητής φωνής ${vocoder}$. Στην κατασκευή
ενός αναλογικού καναλιού κωδικοποιητής φωνής, τα χαρακτηριστικά του
φίλτρου επηρεάζουν την ποιότητα της φωνής σε βαθμό που ήταν δύσκολο να
διακριθούν αντικειμενικά. Μέσω προγραμματισμένων προσομοιώσεων
κατάφεραν την ρύθμιση των χαρακτηριστικών, ώστε να καθορίσουν το
αποτέλεσμα της αναλογικής συσκευής πριν την κατασκευή της.
    Εδώ αξίζει να σημειωθεί ότι ενώ η χρήση των Η/Υ βοήθησε στην πειραματική
διαδικασία, μπορούσε μόνο να /προσομοιώσει ή προσεγγίσει/ το αναλογικό
σύστημα ανάλυσης σημάτων.

Καθώς τα σήματα ξεκίνησαν να επεξεργάζονται σε ψηφιακούς υπολογιστές, οι
ερευνητές αναγκάστηκαν πολύ γρήγορα να χρησιμοποιούν ολοένα και πιο περίπλοκους
αλγόριθμους επεξεργασίας σημάτων. Πολλοί από τους αλγόριθμους
εξελίχθηκαν λόγω της ευελιξίας που παρείχε το προγραμματιστικό περιβάλλον
σε αντίθεση με την μόνιμη αναλογική κατασκευή, όπου περιορίζεται η δυνατότητα
πειραματισμού. Έτσι η συνεχής εξέλιξη και ευελιξία της ψηφιακής
επεξεργασίας σημάτων έδωσε το έναυσμα για την ολική ψηφιοποίηση των συσκευών
και μεθόδων της επεξεργασίας και διάδοσης σημάτων στην πλειοψηφία των
εγκαταστάσεων. Εκείνη την περίοδο ξεκίνησε ενεργά η δημιουργία ψηφιακών
κωδικοποιητών φωνής, ψηφιακών αναλυτών φάσματος κ.α. συσκευών αμιγώς ψηφιακής
επεξεργασίας σήματος, με την ελπίδα ότι τελικά τέτοια συστήματα θα
αποκτούσαν πρακτικές εφαρμογές.

Μία νέα σκοπιά προς την επεξεργασία σημάτων διακριτού χρόνου επιταχύνθηκε
με την δημοσίευση από τους ${Cooley\ and\ Tukey}$ (1965) ενός αποδοτικού αλγόριθμου
για τον υπολογισμό του μετασχηματισμού ${Fourier}$. Η κλάση αυτή θα γίνει
αργότερα γνωστή ως Ταχύς Μετασχηματισμός ${Fourier\ (F.F.T.\ Fast\ Fourier\ Transform)}$.
Ο $\en{F.F.T.}$ ήταν αρκετά σημαντικός για πολλούς λόγους. Βασικό
πρόβλημα των αλγόριθμων της εποχής ήταν ότι απαιτούσαν χρόνους
επεξεργασίας πολύ μεγαλύτερους από τον πραγματικό χρόνο του
καταγεγραμμένου σήματος. Αυτό συνέβαινε γιατί στις περισσότερες
περιπτώσεις απαιτείται η χρήση ανάλυσης φάσματος του σήματος και μέχρι
τότε δεν υπήρχε κάποιος αποδοτικός αλγόριθμος. Ο ταχύς μετασχηματισμός
προσέφερε την δυνατότητα στους ερευνητές να πειραματίζονται σε
πραγματικούς χρόνους με την εγκατάσταση, καθώς μείωσε δραστικά τον χρόνο
επεξεργασίας κατά πολλές τάξεις μεγέθους. Επιπρόσθετα πολλοί αλγόριθμοι
που δεν είχαν καμία πρακτική εφαρμογή, λόγω του χρόνου επεξεργασίας,
ξεκίνησαν να έχουν πρακτικές εφαρμογές στην βιομηχανία και αργότερα στα
προϊόντα για τον γενικό πληθυσμό.

Άλλη μια σημαντική ιδιότητα του ${F.F.T.}$ που βοήθησε στον σχεδιασμό καλύτερων
συσκευών ήταν ότι προγραμματίστηκε με βάση τα σήματα διακριτού χρόνου.
Δηλαδή εμπεριείχε τις απαιτούμενες ιδιότητες και μαθηματικά ώστε να
διαχειρίζεται ψηφιοποιημένα σήματα -διακριτού χρόνου- και να μην
/προσομοιώνει/ μια αναλογική συμπεριφορά ενός σήματος ή συστήματος.
Έτσι η δυνατότητα σχεδιασμού συστημάτων που προβλεπόταν η ακριβής
συμπεριφορά του βοήθησε στην εξέλιξη της επεξεργασίας σημάτων
διακριτού χρόνου χωρίς την ανάγκη συσχέτισης των αποτελεσμάτων
με ένα σύστημα συνεχούς χρόνου (αναλογικού συστήματος). Έτσι η ένταξη
των διακριτών σημάτων ως ξεχωριστή μέθοδος επεξεργασίας προσέφερε στην
ανάπτυξη τεχνολογίας μειώνοντας, εκτός από τους απαιτούμενους χρόνους,
το κόστος και τον όγκο των εγκαταστάσεων για την επίτευξη του στόχου.

Παράλληλα η επινόηση και εφεύρεση των μικρο-ελεγκτών στον τομέα της
μικροηλεκτρονικής επέφερε περαιτέρω μείωση του κόστους. Ενώ οι
πρώτες συσκευές μικρο-ελεγκτών δεν παρείχαν τις απαιτούμενες δυνατότητες
για την ολοκλήρωση των συστημάτων επεξεργασίας διακριτών σημάτων, από
τις αρχές της δεκαετίας του '80 η ταχύτητα τους αυξάνεται εκθετικά.
Επιπρόσθετα η αρχιτεκτονική και τεχνολογία των ολοκληρωμένων κυκλωμάτων
(${I.C.\ Intergated\ Circuit}$) αναπτύχθηκε προς την κατεύθυνση για την κατασκευή
ολοένα και ταχύτερων υπολογιστών για την διαχείριση ακέραιων και δεκαδικών
αριθμών. Έτσι σήμερα η ανάλυση σημάτων, η καταγραφή όπως και η μετάδοσή τους
γίνεται πολλές φορές εξ' ολοκλήρου από ψηφιακά συστήματα.
-----
* Σήματα
** Εισαγωγή
Ο όρος σήμα ${(signal)}$ δίνεται σε κάτι που εμπεριέχει πληροφορία. Γενικά
τα σήματα χρησιμοποιούνται στην κωδικοποίηση και εξαγωγή πληροφοριών για
την κατάσταση ή/και την συμπεριφορά ενός φυσικού συστήματος. Συχνά
συνδυάζοντας διαφορετικά σήματα υπάρχει η δυνατότητα επικοινωνίας μεταξύ
ανθρώπων αλλά και με μηχανήματα. Άν και αναπαριστούμε τα σήματα με διάφορες
μορφές η πληροφορία που μεταδίδουν, εμπεριέχεται με την μορφή μοτίβων. Η
μαθηματική αναπαράσταση παρέχεται μέσω συνάρτησης μίας ή περισσότερων
ανεξάρτητων μεταβλητών. Ένα παράδειγμα είναι η ανεξάρτητη μεταβλητή της
εξίσωσης που περιγράφει μία ψηφιακή εικόνα, όπου θα αποτελείται από δύο
χωρικές μεταβλητές σε συνάρτηση της φωτεινότητας. Αντίθετα ένα αρχείο ήχου
θα ορίζεται σε συνάρτηση με τον χρόνο. Εδώ καταχρηστικά όταν θα αναφερόμαστε
σε κάποιο σήμα θα χρησιμοποιούμε την 2η περίπτωση, δηλαδή ως προς τον χρόνο.

Η ανεξάρτητη μεταβλητή του χρόνου σε ένα σήμα μπορεί να είναι συνεχής ή
διακριτή ως προς το διάστημα που ορίζεται. Τα σήματα συνεχούς χρόνου
ορίζονται για κάθε τιμή τους στο διάστημα και επομένως αναπαριστώνται
με μία ανεξάρτητη συνεχή μεταβλητή. Στην παραπάνω περίπτωση αναφερόμαστε
σε αυτά ως *αναλογικά σήματα*. Ως *σήματα διακριτού χρόνου* ονομάζουμε όσα η
ανεξάρτητη μεταβλητή του χρόνου μας παρέχει πληροφορία για συγκεκριμένα
διαστήματα ή αλλιώς χρονικές στιγμές. Εδώ η αναπαράσταση του χρόνου γίνεται
με την χρήση ακολουθίας αριθμών, συνήθως ανά συγκεκριμένο διάστημα π.χ.
κάθε 0,1 δευτερόλεπτα. Εκτός του χρόνου την ίδια κατηγοριοποίηση συναντούμε
και στην αναπαράσταση της ισχύος ενός σήματος \((amplitute)\). *Ψηφιακά σήματα*
ονομάζονται όσα έχουν διακριτές τιμές ισχύος και χρόνου.

Τα συστήματα ανάλυσης σημάτων κατηγοριοποιούνται ανάλογα. Συστήματα συνεχούς
χρόνου ονομάζονται εκείνα που τα σήματα εισόδου και εξόδου είναι αναλογικά.
Αντίστοιχα συστήματα διακριτού χρόνου ονομάζονται όσα δαχειρίζονται σήματα
διακριτού χρόνου. Ψηφιακά συστήματα ονομάζονται όσα λαμβάνουν σε είσοδο και
έξοδο ψηφιακά σήματα. Επομένως στην ψηφιακή ανάλυση σημάτων
${(Digital\ signal\ processing)}$ επεξεργάζονται σήματα που εκφράζονται
με ακολουθίες για τον χρόνο και την ισχύ τους.

Σήματα διακριτού χρόνου προκύπτουν καταγράφοντας ένα συνεχές σήμα ή από
διεργασίες που εκτελούνται σε διακριτές τιμές του χρόνου. Ανεξαρτήτου
προέλευσης του σήματος, τα συστήματα επεξεργασίας σημάτων διακριτού χρόνου
παρέχουν πολλές δυνατότητες ελκύοντας το ενδιαφέρον τις τελευταίες
δεκαετίες. Έχουν δυνατότητες προσομοίωσης αναλογικών συστημάτων με
περισσότερη ευελιξία και παρέχουν την δυνατότητα ανακάλυψης τυχών μεταβολών
στα σήματα που δεν είναι δυνατόν να γίνουν αντιληπτά από ένα αναλογικό
σύστημα επεξεργασίας. Επιπρόσθετα η συνεχής ανάπτυξη ψηφιακών συσκευών
όπως είναι οι υπολογιστές γενικής χρήσης και οι μικρο-ελεγκτές προτιμάται
η αναπαράσταση των σημάτων σε διακριτά πεδία χρόνου αν όχι σε ψηφιακή μορφή.

Παρακάτω στο κεφάλαιο θα αναφερθούμε σε βασικές έννοιες που διέπουν τα σήματα
διακριτού χρόνου και συστήματα ανάλυσης αυτών για μονοδιάστατα σήματα.
Πρακτικά υπάρχει η δυνατότητα να διαχειριστούμε τα σήματα αυτά ως αναλογικά
και με σωστή χρήση συγκεκριμένων κριτηρίων μπορούμε να εξάγουμε τα σωστά
αποτελέσματα. Τέτοιου τύπου συστήματα καθόρισαν τις βασικές αρχές των
καταγραφικών συσκευών δεδομένων. Όμως πολλά συστήματα διακριτού χρόνου
δεν ορίζονται ως προσομοιώσεις αναλογικών συστημάτων καθώς και πολλές
ακολουθίες δεν προκύπτουν καταγράφοντας ένα αναλογικό σήμα. Για τους
παραπάνω λόγους αντί να εφαρμοστούν τα αποτελέσματα από την θεωρία που
αναφέρεται στα συνεχή σήματα-συστήματα, θα εκβάλλονται παράλληλα συμπεράσματα
ξεκινώντας από τα χαρακτηριστικά που διέπουν το σήμα και θέτοντας το
ανάλογο πλαίσιο επεξεργασίας. Εδώ ασχοληθήκαμε μόνο με ψηφιακά σήματα
καθώς η καταγραφή των σημάτων έγινε με Η/Υ μέσω προγράμματος ${(Lab-View)}$.

** Σήματα συνεχούς χρόνου
Στην εισαγωγή αναφερθήκαμε στον γενικό ορισμό των σημάτων και τις διαφορές
που τα κατηγοριοποιούν σε αρχικό βαθμό. Επειδή ο στόχος της παρούσας εργασίας
ήταν η απόρριψη θορύβου δεν θα γίνει η πρέπουσα ανάλυση στην θεωρία των σημάτων,
αντιθέτως θα παρατεθούν οι βασικές αρχές και έννοιες ώστε να υπάρχει το υπόβαθρο
για τα επόμενα κεφάλαια. Σήμα συνεχούς χρόνου ορίζουμε ως την εξίσωση που
περιγράφει την εξέλιξη μιας περιοδικής κυματομορφής στο χρόνο. Πιο συγκεκριμένα
αν υποθέσουμε πως ο χρόνος διάρκειας του σήματος είναι \(t\) τότε η κυματομορφή στο
πεδίο του χρόνου θα εκφράζεται ως συνάρτηση αυτού \(s(t)\).

Μπορεί λοιπόν να παρασταθεί από μία ανεξάρτητη μεταβλητή και ορίζεται για κάθε
τιμή της. Με παρόμοιο τρόπο ορίζονται και τα διακριτά σήματα συνεχούς χρόνου.
Η διαφορά είναι πως αντί να μπορούμε να ταυτίσουμε κάθε χρονική στιγμή με το
αντίστοιχο \(s(t)\), μπορούμε να ορίσουμε την εξίσωση της κυματομορφής για
περιορισμένο ή αλλιώς διακριτό πεδίο τιμών. Σήμα συνεχούς χρόνου
ονομάζεται ένα σήμα \(y(t)\), το οποίο ορίζεται για κάθε τιμή του \(t\) σε κάποιο
διάστημα χρόνου \([\alpha,\beta]\). Συνήθως τα συναντούμε στην μορφή συνεχούς ρεύματος σε
μετρητικές και άλλες συσκευές σε εξόδους για την ένδειξη κάποιας τιμής ή
απεικόνιση σε παλμογράφο. Τα σήματα συνεχούς χρόνου χωρίζονται σε αναλογικά
και διακριτά σήματα συνεχούς χρόνου.

Αναλογικά σήματα ονομάζονται εκείνα που η ανεξάρτητη μεταβλητή του
χρόνου \(t\) και η μεταβλητή του πλάτους (εξαρτημένη μεταβλητή ως προς τον
χρόνο) λαμβάνουν συνεχής και πραγματικές τιμές, π.χ. \(s(t) = 12 * t\).
Διακριτά σήματα συνεχούς χρόνου ονομάζονται όσα ή εξαρτημένη τιμή
(πλάτος) παίρνει διακριτές τιμές, π.χ.
\begin{equation}
\begin{align}
s(t) =  A * t \\
A &= [0, … ,n],\ t \in [a,b] n \in \mathbb{Z} \\
\end{align}
\end{equation}

Στην πληθώρα των συσκευών επεξεργασίας και καταγραφής σημάτων η χρήση
των αναλογικών σημάτων έχει σχεδόν εκλείψει. Σημαντικό μειονέκτημα
ανάμεσα σε άλλα είναι και ο υπέρογκος χώρος που απαιτείται
για την αποθήκευση του. Παρακάτω θα αναφερθούμε στα *ψηφιακά* σήματα που
έλυσαν πολλά από τα προβλήματα των αναλογικών σημάτων, προσθέτοντας μια
σειρά από "πονοκεφάλους" αρχικά στην επιστημονική κοινότητα. Τα
πλεονεκτήματα ήταν πολλά και τελικά επικράτησαν. Παρακάτω θα παρατεθούν
κάποιες βασικές έννοιες και αρχές που τα διέπουν.
-----
** Σήματα διακριτού χρόνου
Σήμα διακριτού χρόνου ονομάζεται μια ακολουθία αριθμών καταγεγραμμένες
ανά συγκεκριμένο χρονικό διάστημα, π.χ. κάθε 0,01 δευτερόλεπτο. Το
διάστημα αυτό ορίζει την ταχύτητα καταγραφής του σήματος από την
εκάστοτε συσκευή, όμως εμείς αναφερόμαστε σε αυτό το χρόνο μέσω της
συχνότητας καταγραφής ή αλλιώς ${sampling\ frequency}$. Η συχνότητα αυτή
ορίζεται ως το πηλίκο ενός δευτερολέπτου ως προς το χρονικό διάστημα
καταγραφής, δηλαδή από το παραπάνω παράδειγμα θα είχαμε μια συχνότητα
καταγραφής 1/0.01 \([Hz]\).
\begin{equation}
fs = \frac{1}{0,01} [Hz]
\end{equation}
Σημαντικό είναι να αναφερθεί ότι υπάρχει ένα όριο το οποίο πρέπει να
τηρείται ώστε η επαναδημιουργία του σήματος να απεικονίζει όσο το
δυνατόν πιο πολύ στο συνεχές σήμα που καταγράφηκε στην αρχή. Θα
αναφερθούμε αργότερα στο εν λόγω θεώρημα του φυσικού ${Niquist}$.
*** Μοναδιαίο διακριτό σήμα
Μοναδιαίο ονομάζεται το σήμα που αποτελείται από έναν κρουστικού
χαρακτήρα παλμού και έχει μηδενική ισχύ πριν και μετά την εμφάνισή
του. Αν υποθέσουμε μια συνάρτηση \(y(t)\) ,
\begin{equation}
\begin{align}
y(t) = [..., 0, 1, 0, ...]
\end{align}
\end{equation}
θα είναι η έξοδος του σήματος αυτού.

Μια άλλη βασική υποκατηγορία αποτελεί η μοναδιαία ακολουθία βήματος.
Εδώ σε αντίθεση με παραπάνω, η τιμή της εξόδου αλλάζει από μηδέν σε ένα
μόλις η εξαρτημένη μεταβλητή \en{t} λάβει κάποια οριακή τιμή.
Χρησιμοποιώντας το ανωτέρω παράδειγμα θα έχουμε ότι:
\begin{equation}
\begin{align}
y(t) = [..., 0, 1, 1, 1, ...]
\end{align}
\end{equation}
*** Τυχαίο σήμα
Τα τυχαία σήματα αποτελούν μία ειδική υποκατηγορία που χρησιμοποιείται
ευρέως στην ανάλυση ψηφιακών σημάτων. Αναπτύχθηκαν για να καλύψουν την
ανάγκη επιβεβαίωσης των συσκευών επεξεργασίας κυματομορφών. Με την
πάροδο του χρόνου τις συναντάμε σε διάφορες συσκευές τηλεπικοινωνίας
και σχεδόν σε όλες τις συσκευές παραγωγής ήχου (\(synthesizers\)).
Αξίζει να σημειωθεί για λόγους πληρότητας ότι τα εν' λόγω σήματα
βασίζονται σε στατιστικά μοντέλα που απορρέουν από στατιστικές κατανομές.
Ο "λευκός" γκαουσιανός θόρυβος (\(white\ gaussian\ noise)\) ακολουθεί
την λεγόμενη κανονική κατανομή πιθανοτήτων του \(Gauss\). Στην παρούσα
εργασία ένα αντίστοιχο σήμα χρησιμοποιήθηκε για την επιβεβαίωση των
φίλτρων πριν την εφαρμογή στο σετ δεδομένων. Δεν θα γίνει περαιτέρω
ανάλυση γιατί κρίθηκε πως οι παρεμβολές στον αισθητήρα της εγκατάστασης
προερχόταν από εξωτερικά Η/Μ πεδία και όχι από τυχαίο θόρυβο. Τα καλώδια
που χρησιμοποιήθηκαν για την καταγραφή έχουν την δυνατότητα απόρριψης
παρόμοιου τύπου θόρυβο.
*** Διακριτά σήματα και ακολουθίες
Για τον ορισμό του διακριτού σήματος αρκεί να υποθέσουμε μια μαθηματική
ακολουθία αριθμών \(x\), όπου το νιοστό στοιχείο της θα γραφόταν ως \(x[n]\).
Ορθότερα μπορούμε να γράψουμε την εξής έκφραση:
\begin{equation}
\begin{align}
n \in \mathbb{Z} \\
x &= {x[n]},\  -\infty < n < \infty \\
\end{align}
\end{equation}
όπου \(\mathbb{Z}\) είναι σαφώς το σύνολο των ακέραιων αριθμών και \(x[n]\) το κάθε στοιχείο
της ακολουθίας. Ο συγκεκριμένος τύπος σήματος παράγεται συνήθως από την
καταγραφή αναλογικού σήματος. Επομένως η παραπάνω σχέση μετασχηματίζεται
για αναλογικό σήμα της μορφής \(x_{a}(t)\), για χρονική στιγμή ίση με \(nT\), το
νιοστό στοιχείο της ακολουθίας εξόδου από την καταγραφή θα είναι της
μορφής:
\begin{equation}
\begin{align}
x[n] = x_{a} nT,\ -\infty < n < \infty \\
\end{align}
\end{equation}

Η ποσότητα \(T\) ορίζει την περίοδο καταγραφής που παρέχει την συχνότητα
καταγραφής διαιρώντας με την μονάδα. Αν και τα διακριτά σήματα δεν
προέρχονται πάντα από καταγραφή αναλογικών σημάτων ο ορισμός του αριθμού
των στοιχείων της ακολουθίας \(n\) μπορεί να λάβει μόνο ακέραιες τιμές. Επίσης
γράφοντας μόνο το "τελευταίο" ψηφίο μέσα στην αγκύλη αναφερόμαστε σε όλα
τα στοιχεία της ακολουθίας για συντομία και όχι στο τελευταίο στοιχείο
αυτής.
*** Διαχείριση και βασικές τεχνικές μετασχηματισμών
Κατά την διαδικασία της ανάλυσης σημάτων είναι συχνά απαραίτητη η επέμβαση
στο σήμα εισόδου ή εξόδου. Οι πράξεις του πολλαπλασιασμού και της πρόσθεσης
δυο σημάτων μεταξύ τους λαμβάνει χώρα στοιχείο προς στοιχείο, όπως πράξεις
μεταξύ αριθμού και ακολουθίας. Επίσης όταν αφαιρείται από μια ακολουθία
ακέραιος αριθμός το παράγωγο σήμα ονομάζεται καθυστέρηση του αρχικού
(\(delayed\)). Μια τέτοια ακολουθία μπορεί να βρεθεί γραμμένη ως εξής:

\begin{equation}
\begin{align}
a_{0} \in \mathbb{Z} \\
&out[z] = in[z-a_{0}] \\
\end{align}
\end{equation}

Τέτοιου είδους μετασχηματισμοί εφαρμόζονται σε συνδυασμούς και παρέχουν μία
πληθώρα διεργασιών ανάμεσα σε σήματα αλλά και σε σχέση με κάποια σταθερά.
Μια ειδική περίπτωση που αναφέρθηκε νωρίτερα, ως βηματική μοναδιαία
ακολουθία, εκφράζεται σαν άθροισμα καθυστερημένων ακολουθιών:

\begin{equation}
\begin{align}
out[n] = \sum_{k=0}^{\infty} in[n-k]
\end{align}
\end{equation}
Η παραπάνω σχέση προκύπτει γιατί όλα τα μη μηδενικά στοιχεία της ακολουθίας
\(in[n]\) ισούνται με την μονάδα. Σημαντική θέση στην ανάλυση διακριτών συστημάτων
έχει και η εκθετική ακολουθία. Συχνά απλοποιεί τις πράξεις ειδικά για
συστήματα πέραν του ενός βαθμού ελευθερίας. Η γενική μορφή της εκθετικής
ακολουθίας φαίνεται παρακάτω:
\begin{equation}
\begin{align}
s[n] = Cb^{n}
\end{align}
\end{equation}
όπου \(C\) και \(b\) σταθερές που λαμβάνοντας πραγματικές τιμές
μετατρέπουν την έκφραση σε ακολουθία που λαμβάνει τιμές στο \(\mathbb{R}\).
Συνοπτικά οι εκθετικές μορφές σε συνδυασμό με ανάλογες τριγωνομετρικές
μορφές μπορούν να παρέχουν πληροφορία για την ταχύτητα διάδοσης ενός
σήματος, την μορφολογία της κυματομορφής αλλά και την ισχύ των συχνοτήτων
που μας ενδιαφέρουν. Η ισχύ στο παράδειγμά μας θα ήταν \(C\).
*** Συνδυάζοντας ακολουθίες
Ίσως από τις πιο συχνά αναλυμένες μορφές σημάτων αποτελούν  τα
ημιτονοειδή και συνημιτονοειδή. Η γενική μορφή ορίζεται
όπως θα δειχθεί παρακάτω και θα αναφερθούμε στην σχέση που αναδύεται από
τα μαθηματικά, της εκθετικής μορφής με την ημιτονοειδή.
\begin{equation}
\begin{align}
&y[n] = C \cos(\omega_{0}n + \phi) \\
\end{align}
\end{equation}
Η οποία ορίζεται για κάθε \(n\), με τις τιμές των \(C\)
και \(\phi\) να λαμβάνουν πραγματικές τιμές. Η εκθετική μορφή μιας ακολουθίας
μπορεί να γραφεί και ως \(C \cdod c^{n}\) με την μεταβλητή \(n\) να έχει φανταστικές
τιμές. Θα μπορούσαμε να γράψουμε την παραπάνω έκφραση στην μορφή:
\begin{equation}
\begin{align}
y[n] = |C||c|^{n} \cdot(\cos(\omega_{0}n+\phi)+ j\sin(\omega_{0}n+\phi)) \\
\end{align}
\end{equation}
Η παραπάνω εξίσωση ταλαντεύεται με εκθετικά αυξανόμενη κλήση αν η απόλυτη
τιμή της μεταβλητής \(c\) είναι μεγαλύτερη της μονάδας και με εκθετικά
μειούμενη στην αντίθετη περίπτωση όπου \(|c|<1\).

Στην περίπτωση που η μεταβλητή λάβει την τιμή 1, η σχέση χαρακτηρίζεται
ως φανταστική εκθετική ακολουθία και ικανοποιεί την παρακάτω συνθήκη.
\begin{equation}
\begin{align}
y[n] &= |C| e^{j(\omega_{0}n+\phi)} \\
&= |C|\cdot(\cos(\omega_{0}n+\phi)+ j\sin(\omega_{0}n+\phi)) \\
\end{align}
\end{equation}
Εδώ όπως και σε συνεχή συστήματα μπορούμε να χαρακτηρίσουμε την μεταβλητή
\(\phi\) ως την φάση του σήματος και αντίστοιχα \(\omega_{0}\) ονομάζεται κυκλική συχνότητα.
Παρατηρούμε πως η μεταβλητή \(n\) είναι αδιάστατο μέγεθος και επομένως η κυκλική
συχνότητα θα πρέπει να ορίζεται σε ακτίνια (\(rad\)). Αν απαιτείται περαιτέρω
ορισμός από τις ανάγκες της επεξεργασίας, υπάρχει δυνατότητα να ορίσουμε την
κυκλική συχνότητα σε ακτίνια ανά δείγμα \( \displaystyle \frac{rad}{sample}\) και ως \(n\) ο αριθμός των δειγμάτων
από την καταγραφή του σήματος. Όπως επισημαίνεται στη βιβλιογραφία εδώ φαίνεται
και η πρώτη διαφορά μεταξύ των συνεχών και διακριτών συστημάτων.

Αν υποθέσουμε ότι η φάση του σήματος ισούται με 2π τότε η εκθετική μορφή αποκτά
ψευδώνυμα συχνοτήτων που είναι μη διακριτά μεταξύ τους. Ένα απλό παράδειγμα
για την ημιτονοειδή μορφή φαίνεται παρακάτω:
\begin{equation}
\begin{align}
y[n]&&=C \cos[(\omega_{0} + 2\pi r)n + \phi] \\
&&=C \cos(\omega_{0}n + \phi) \\
\end{align}
\end{equation}
Οι εφαρμογές της ιδιότητας των διακριτών σημάτων να δημιουργούν αυτά τα ψευδώνυμα
ποικίλουν και θα αναφερθούν σε ένα πρώτο βαθμό στο κεφάλαιο της καταγραφής των
σημάτων. Εδώ γίνεται η παραδοχή πως η τιμή της συχνότητας θα πρέπει βρίσκεται
σε μια περιοχή που δεν θα επιτρέπει τέτοιες συμπεριφορές για απλοποίηση.
*** Συστήματα διακριτού χρόνου
Διακριτό σύστημα ορίζεται ως η μετατροπή που απαιτείται για την
ταύτιση του σήματος εξόδου με εκείνο της εισόδου. Σχηματικά
αναπαρίσταται συνήθως με ένα κουτί που αντιπροσωπεύει τις διεργασίες
που επιδέχεται το σήμα εισόδου για να έχουμε το επιθυμητό στην έξοδο.
Θα δειχθεί αργότερα πως οι τιμές του σήματος εξόδου για κάθε τιμή
της μεταβλητής \(n\) μπορεί να είναι εξαρτημένες από το σήμα εισόδου.
Στην συνέχεια φαίνεται η μαθηματική απεικόνιση ενός συστήματος που
δρα σε μια ακολουθία (σήμα εισόδου), για την εξαγωγή ενός δεύτερου
σήματος.
\begin{equation}
\begin{align}
out[n] = G\{in[n]\}
\end{align}
\end{equation}

Εδώ αξίζει να αναφερθεί μια έννοια που θα μας απασχολήσει ξανά στην
ενότητα κατασκευής φίλτρων. Πρόκειται για το σύστημα μεταβαλλόμενης μέσης
τιμής ή αλλιώς μέσης τρέχουσας τιμής. Η εμφάνισή της στην βιβλιογραφία
αναφορικά με την επεξεργασία σημάτων είναι εκτενής. Η διεργασία που
εφαρμόστηκε στην παρούσα περίπτωση  περιορίστηκαν στο φίλτρο μέσης
τρέχουσας τιμής ή \(F.I.R.\) με τα αρχικά να σημαίνουν \(Finite\ Impulse\ Response\).
Η παρακάτω γενική μορφή του προαναφερόμενου συστήματος με κάποιες
απλοποιήσεις που θα αναφερθούν σε επόμενο κεφάλαιο είναι η δομή του
φίλτρου μέσης τιμής.
\begin{equation}
\begin{align}
out[n] = \frac{1}{M_{1}+M_{2}+1}\sum_{k=-M_{1}}^{M_{2}} in[n-k]
\end{align}
\end{equation}
*** Γραμμικότητα συστημάτων
Τα συστήματα που εμφανίζουν γραμμική συμπεριφορά είναι εξ´ ορισμού
παραγόμενα από την αρχή της υπέρθεσης. Πιο συγκεκριμένα αν δύο διαδοχικές
τιμές του σήματος εισόδου παράγουν δυο αντίστοιχες τιμές εξόδου, το σύστημα
θα μπορεί να λέγεται γραμμικό αν και μόνο αν ισχύει ότι:
\begin{equation}
\begin{align}
G\{s_{1}[n]+s_{2}[n]\} = \\
&G\{x_{2}[n]\}+G\{x_{2}[n]\} = out_{1}[n] + out_{2}[n]
\end{align}
\end{equation}
και ταυτόχρονα να ικανοποιείται και η εξής ιδιότητα:
\begin{equation}
\begin{align}
G\{g \cdot s[n]\} = \\
&gG\{s[n]\} = g\cdot out[n]
\end{align}
\end{equation}
όπου \(g\) μια αυθαίρετη σταθερά. Οι ανωτέρω ιδιότητες μπορούν να συνδυαστούν,
ώστε να ικανοποιείται η αρχή της υπέρθεσης. Επιπρόσθετα υπάρχει δυνατότητα
εφαρμογής σε πολλαπλά σήματα εισόδου. Αν για παράδειγμα γνωρίζουμε πως ένα
σύστημα είναι γραμμικό \(F\{\cdot\}\) τότε μπορούμε να υποθέσουμε πως για κάθε έξοδο
του συστήματος θα ισχύει το εξής:
\begin{equation}
\begin{align}
in[n] = \sum_{z}b_{z}in_{z}[n] \\
&F\{in[n]\} = out[n] = \sum_{z}b_{z}out_{z}[n] \\
\end{align}
\end{equation}
Για να γίνει πιο κατανοητή η παραπάνω συμπεριφορά ας υποθέσουμε ένα λογαριθμικό
σύστημα,
\begin{equation}
\begin{align}
r[u] = \log_{10}(|x[u]|)
\end{align}
\end{equation}
και ας πάρουμε δύο τιμές για την ακολουθία \(x_{1}[\cdot]\) και \(x_{2}[\cdot]\) να ισούνται με 1 και 10
αντίστοιχα. Αυτό σημαίνει ότι τα σήματα εξόδου θα πρέπει, ικανοποιώντας την
ιδιότητα της ομογένειας, να απέχουν δέκα μονάδες μεταξύ τους όσο δηλαδή και
τα σήματα εισόδου \((x_{2}=10x_{1})\). Όπως είναι προφανές κάτι τέτοιο δεν ισχύει
στην συγκεκριμένη περίπτωση, αφού \(\log1=0,\ \log10=1\).

Η ενότητα αυτή θα μπορούσε να γεμίσει το περιεχόμενο της παρούσας εργασίας
και άλλες τόσες μαζί. Έχουν γραφεί πολλά βιβλία που αναλύουν το ζήτημα, ένα
από τα αναλυτικότερα φέρει τίτλο \(Discrete-Time\ Signal\ Processing\) των \(Alan\ Oppenheim\) και
\(Ronald\ Schafer\) παρέχοντας στον αναγνώστη εκτεταμένες βάσεις για την επεξεργασία
και μαθηματική αναπαράσταση σημάτων και συστημάτων. Εδώ αναφέρθηκαν οι βασικές
έννοιες και αρχές, με σκοπό την καλύτερη κατανόηση της καταγραφής και της
απομείωσης θορύβου σε σήματα. Στην συνέχεια θα ασχοληθούμε με την καταγραφή
ψηφιακών σημάτων και μερικά από τα σημαντικά προβλήματα κατά την διαδικασία.
* Καταγραφή σημάτων
** Φαινόμενα καταγραφής
    Σε αυτή την ενότητα θα περιγραφούν οι βασικές θεωρίες που χρησιμοποιούνται
για την ψηφιακή καταγραφή και επεξεργασία σημάτων καθώς και κάποια προβλήματα
που μπορεί να εμφανιστούν κατά τις διαδικασίες αυτές. Μια από τις σημαντικότερες
θεωρίες είναι του Φυσικού και Ηλεκτρολόγου Μηχανικού \(Harry\ Nyquist\),
όπου θα αναφερθεί στη συνέχεια. Επίσης θα αναφερθούμε σε διαστρεβλώσεις
και καταστρεπτικές συμπεριφορές των συστημάτων κατά την μετατροπή τους από
συνεχή σε διακριτά σήματα και σε τρόπους αναγνώρισης και αντιμετώπισης
των προβλημάτων. Θα παρατεθεί ο συνήθης τρόπος απόκτησης ενός διακριτού σήματος
από την καταγραφή σημάτων συνεχούς χρόνου, όπως επίσης και ο τρόπος που αυτό γίνεται
εφικτό από συστήματα καταγραφής σε Η/Υ.
*** Μέθοδος καταγραφής
Ο πιο συνήθης τρόπος εξαγωγής ενός διακριτού σήματος είναι μέσω της περιοδικής
καταγραφής κάποιου συνεχούς σήματος. Στην πράξη αυτό σημαίνει πως καταγράφεται
μία τιμή του σήματος εισόδου σε ένα σύστημα ανά προκαθορισμένο χρονικό διάστημα,
το οποίο ονομάζεται περίοδος καταγραφής του σήματος σε μονάδες δευτερολέπτου.
Διαιρώντας την μονάδα με την περίοδο αποκτούμε την συχνότητα καταγραφής ορισμένη
σε δείγμα ανά δευτερόλεπτο \(\displaystyle \frac{sample}{sec}\). Το σύστημα που εκτελεί την συγκεκριμένη
επεξεργασία ονομάζεται μετατροπέας αναλογικού σε διακριτό σήμα και σε σημερινές
συσκευές καθίσταται σχεδόν υποχρεωτική η χρήση του για πολλούς λόγους. Ένα
παράδειγμα αποτελεί η ανάγκη για ανάγνωση αισθητήριων οργάνων και εκτέλεση
προδιαγεγραμμένων εντολών σύμφωνα με την τιμή εισόδου. Σε αυτή την περίπτωση
ένας μικρο-ελεγκτής δεν διαθέτει την δυνατότητα ανάγνωσης και επεξεργασίας
αναλογικών σημάτων και επομένως η μετατροπή του σε διακριτό σήμα υπό κάποια
συχνότητα καταγραφής αποτελεί μονόδρομο.

Μετά την περιοδική καταγραφή, είναι αδύνατο να ανακτηθεί επακριβώς το αρχικό
αναλογικό σήμα. Αίτιο αποτελεί το γεγονός πως πολλά αναλογικά σήματα μπορούν
να έχουν όμοια αναπαράσταση διακριτών *παράγωγων?!?!?*. Το συγκεκριμένο
φαινόμενο αποτελεί θεμελιώδες πρόβλημα στον τομέα της ανάλυσης ψηφιακών
σημάτων, όμως αργότερα θα δειχθεί πως είναι δυνατός ο περιορισμός της εν' λόγω
συμπεριφοράς καθορίζοντας το πλήθος των δειγμάτων. Στην συνέχεια θα αναφερθούμε
στην βασική *αρχή?!?!?* που μας επιτρέπει να καταγράφουμε τα αναλογικά σήματα με
τρόπο που αποτυπώνει όλη την πληροφορία που εμπεριέχουν. Σημασία δίνεται στην
έννοια της πληροφορίας καθώς ο σκοπός χρήσης των σημάτων είναι η κωδικοποίηση
αυτής, όπως ήδη έχει αναφερθεί στην εισαγωγή.
*** Θεώρημα δειγματοληψίας
Στο θεώρημα καταγραφής σημάτων ορίζεται η ελάχιστη συχνότητα δειγματοληψίας με
σκοπό την δυνατότητα ανακατασκευής του αρχικού αναλογικού σήματος. Ο ορισμός αναφέρει
πως, αν ένα συνεχές σήμα δεν περιέχει πληροφορία πάνω από κάποια συχνότητα Α σε
\(Hz\), τότε για να είναι δυνατή η ανάκτηση της αρχικής κυματομορφής θα πρέπει να
ισχύει ότι:
\begin{equation}
\begin{align}
f_{s} \geq 2A \\
\end{align}
\end{equation}

Από τον παραπάνω ορισμό προκύπτει πως απαιτούνται ταυτόχρονα δύο ζητήματα. Το
πρώτο καθορίζει κάποιο ελάχιστο όριο για την συχνότητα καταγραφής, που προκύπτει
από την μέγιστη συχνότητα του αναλογικού σήματος. Το δεύτερο αναφέρεται σε
ανακατασκευή του αρχικού, χωρίς να προσδιορίζει την μέθοδο που θα χρησιμοποιηθεί.

Τα σήματα που παρουσιάζουν απουσία πληροφορίας σε ορισμένες συχνότητες ονομάζονται
*περιορισμένου φάσματος*. Τέτοια συμπεριφορά έχουν σήματα χαμηλών συχνοτήτων που δεν
εμφανίζουν ισχύ σε συχνότητες άνω των 200 \(Hz\). Αντίστοιχα υπάρχουν σήματα που
εμπεριέχουν πληροφορία σε ένα ορισμένο εύρος, από 7 έως 10 \(kHz\). Και τα δύο αυτά
σήματα κατηγοριοποιούνται ως *σήματα περιορισμένου φάσματος*.

Ιδιαίτερο ενδιαφέρον παρουσιάζει το γεγονός πως το συγκεκριμένο θεώρημα αναφέρεται
στην βιβλιογραφία με το προσωνύμιο Θεώρημα Δειγματοληψίας \(Shannon\), ενώ
η πρώτη αναφορά γίνεται από τους Βρετανούς μαθηματικούς \(E.T.\) και \(J.M.\)
\(Whittaker\) και \(Ferrar\). Στην Ρωσία το θεώρημα κατεγράφη από τον
\(Kotel'nikov\) και πήρε το όνομά του από εκείνον. Ο \(Shannon\)
το χρησιμοποίησε για την έρευνα που σήμερα μας είναι γνωστή η θεωρία της
πληροφορίας, και γι' αυτό πολλές φορές στην μαθηματική βιβλιογραφία
αναφέρεται και θεώρημα δειγματοληψίας \(WKS\) από τα αρχικά των παραπάνω.
*** Αναπαράσταση στο πεδίο συχνοτήτων
Το θεώρημα της δειγματοληψίας μπορεί να αποδειχθεί μαθηματικά. Όμως
οι ιδιότητες και οι αιτίες που το προκαλούν φαίνονται πιο ξεκάθαρα
εξετάζοντας την διαδικασία της μετατροπής αναλογικού σε διακριτό σήμα
μεταφρασμένο στο πεδίο των συχνοτήτων. Αν αυθαίρετα υποθέσουμε πως ένα
καταγεγραμμένο ψηφιακό σήμα είναι αναλογικό, οι απότομες διακυμάνσεις
στην ισχύ του σήματος προσθέτουν στοιχεία στην ακολουθία υψηλών
συχνοτήτων που προσθέτονται τελικά στο σήμα. Η καταγραφή λοιπόν ενός
αναλογικού σήματος μπορεί να παρομοιαστεί με δραστικό τεμαχισμό του
αρχικού.

Ως παράδειγμα μπορεί να χρησιμοποιηθεί μια ημιτονοειδής συνάρτηση
σχετικά απλή ώστε να γίνει κατανοητή η παραπάνω συμπεριφορά. Έστω
πως για ένα συνεχές σήμα εφαρμόζουμε την μέθοδο της δειγματοληψίας
ως εξής:
\begin{equation}
\begin{align}
x(t)&=\cos(2 \pi f_{z}t + \phi),\ t=cT,\ c \in [0, +\infty),\ c \in \mathbb{Z} \Rightarrow \\
&x(cT) = \cos(2 \pi f_{z} cT + \phi) \\
\end{align}
\end{equation}
Ας δούμε τώρα τι συμβαίνει σε περίπτωση που υπολογίσουμε την τιμή
του καταγεγραμμένου σήματος σε συχνότητα ίση με \(f_{tot} = f_{z}+f_{s}\):
\begin{equation}
\begin{align}
x_{a}(cT) &= \cos(2 \pi cT \cdot (f_{z}+f_{s})+ \phi) \Rightarrow \\
&= \cos(2 \pi cf_{z}T + 2 \pi c + \phi) \Rightarrow \\
&= \cos(2 \pi cf_{z}T + \phi) \Rightarrow \\
&= x(cT)
\end{align}
\end{equation}
Όπως φαίνεται για κάθε δείγμα εγγραμμένο με κάποια συχνότητα
πολλαπλάσια από εκείνη της καταγραφής \(f_{s}\), το σήμα εμπεριέχει στοιχεία
στο συγκεκριμένο φάσμα. Στην περίπτωση που δεν ικανοποιείται το θεώρημα
της δειγματοληψίας προκύπτει η λεγόμενη αλλοίωση προσθέτοντας αναληθή
δείγματα στο σήμα ή αλλιώς *ψευδόνυμα συχνοτήτων*. Η καταστρεπτική αυτή
συμπεριφορά θα αναλυθεί στην παρακάτω ενότητα ενώ αξίζει να σημειωθεί
πως υπάρχει πιθανότητα να υποφέρουν και οι πειραματικές μετρήσεις του
εργαστηρίου από το φαινόμενο αυτό καθώς η μέγιστη συχνότητα καταγραφής
που επιτεύχθηκε ήταν στα 500 \(kHz\).
*** Αλλοίωση
Ως αλλοίωση αναφερόμαστε εδώ στο αποτέλεσμα καταγραφής ενός σήματος,
όπου η έξοδος αποτελείται από διαφορετικά σήματα και δεν είναι δυνατό να
επαναδημιουργιθεί το αρχικό. Συνήθως η έξοδος είναι μετατοπισμένη ως
προς το φάσμα των συχνοτήτων, όμως πολλές φορές επηρεάζεται και η ισχύ.
Είναι λοιπόν σημαντικό να αποφευχθεί, όσο το δυνατόν περισσότερο, η
αλλοίωση των σημάτων κατά την διαδικασία καταγραφής τους. Για τον λόγο
αυτό συνήθως εφαρμόζεται ένα φίλτρο χαμηλών συχνοτήτων ή φίλτρο κατά της
αλλοίωσης $\en{AAF}$.

Στην ελληνική βιβλιογραφία το φαινόμενο αυτό αναφέρεται ως *ψευδώνυμα συχνοτήτων*
και ερευνήθηκε από τους $\en{Harry\ Niquist}$ και $\en{Claude\ Shannon}$ ερευνητές στα
$\en{Bell\ Labs}$,
οι οποίοι συνέβαλαν σημαντικά στον τομέα των τηλεπικοινωνιών και την καταγραφή
σημάτων. Άλλωστε το θεωρητικό υπόβαθρο για την καταγραφή *ψηφιακών σημάτων* απαλλαγμένων
από ψευδώνυμα αναπτύχθηκε από τους δύο κατά τις δεκαετίες 1920-1950.
Στην εργαστηριακή εγκατάσταση που εξετάστηκε ήταν αδύνατο να αποφευχθεί η εμφάνισή
τους, όμως χρησιμοποιήθηκε η μέθοδος της επεξεργασίας σημάτων πολλαπλών συχνοτήτων
καταγραφής. Στην συγκεκριμένη μέθοδο θα αναφερθούμε επιγραμματικά στην συνέχεια,
όμως αξίζει να αναφερθεί ότι δίνει την δυνατότητα εντοπισμού των αλλοιώσεων
αποδεκατίζοντας το σήμα σύμφωνα με μία σταθερά και εξετάζοντας την γραφική του
παράσταση σε σχέση με την αρχική καταγραφή. Όσο μειώνεται ο αριθμός των δειγμάτων
το σήμα καταστρέφεται ηθελημένα, παράγοντας ψευδώνυμα συχνοτήτων τα οποία θα πρέπει
να είναι όλα διαφορετικά.

#+attr_latex:  :width 250px
#+attr_latex:  :height 140px
#+ATTR_LATEX: :caption \caption{Φαινόμαινο αλλοίωσης σήματος μετά την καταγραφή του.}
[[./aliasing_from_downsampling.png]]

Το συμπέρασμα αυτό προέκυψε χρησιμοποιώντας μια μέθοδο που εντάσσεται στην κατηγορία
της επεξεργασίας σημάτων πολλαπλών συχνοτήτων, μεταβάλλοντας την συχνότητα καταγραφής
αφαιρώντας πλήθος δειγμάτων, και συγκρίνοντας τις γραφικές παραστάσεις στα πεδία
συχνοτήτων και χρόνου.
Την απόρριψη του συγκεκριμένου τύπου "θορύβου" στις σύγχρονες συσκευές αναλαμβάνουν
ειδικά φίλτρα που ονομάζονται  $\en{F.I.R.}$. Αντίστοιχα φίλτρα χρησιμοποιήθηκαν και στην
επεξεργασία των δεδομένων και συγκρίθηκαν τα αποτελέσματα με άλλους τύπους όπως θα
δούμε παρακάτω.

Τα ψευδόνυμα αυτά εμφανίζονται σε υποδειγματοληπτημένα σήματα. Αν είναι επιθυμητό
να εξεταστεί ενα σήμα που μπορεί να εμπεριέχει θόρυβο σε συχνότητες 2-3 \(kHz\), τότε για
την αποφυγή της αλλοίωσης ή αναδίπλωσης του σήματος θα πρέπει η καταγραφική συσκευή
να έχει την δυνατότητα καταγραφής τουλάχιστον 6 \(kHz\). Στο πλαίσιο της επεξεργασίας των
μετρήσεων της αεροσύραγγας που η μέγιστη καταγραφή αγγίζει τα 500 \(kHz\), το μέγιστο
φάσμα σήματος που μπορούσε να εξεταστεί είναι 250 \(kHz\). Έτσι υπήρχε ανάγκη για
περαιτέρω εξέταση και την λύση παρέχει η μέθοδος του αποδεκατισμού. Εφαρμόζοντας την
εξάγωντας κάθε φορά διαφορετικό αριθμό δειγμάτων από το αρχικό, μας δίνεται η
δυνατότητα να συγκρίνουμε τα σήματα και να υποθέσουμε τυχών επηρροή που μπορεί να
έχουν συχνότητες μεγαλύτερες από εκείνες της συχνότητας καταγραφής. Στο διαγραμμα
που ακολουθεί φαίνεται ένα σήμα στο πεδίο της συχνότητας αποδεκατισμένο επιλέγοντας
κάθε 5ο και 50ο στοιχείο της αρχικής ακολουθίας.

#+attr_latex: :height 260px
#+attr_latex: :width 500px
#+ATTR_LATEX: :caption \caption{Αποδεκατισμένο σήμα ανά 5 και 50 δείγματα μαζί με το αρχικό.}
[[file:./decim-big.png]]
** Μείωση αριθμού δειγμάτων
Η τεχνική αυτή εφαρμόζεται σε ψηφιακά σήματα με πολλά δείγματα ανά
χρονικό διάστημα που όμως η τυπική απόκλιση προδίδει μια περιοδική
κίνηση που σχετίζεται με ταλάντωση. Τότε είναι εύλογο να χωριστεί το
σήμα σε μικρότερα “κομμάτια”. Αυτό έχει σαν αποτέλεσμα την ταχύτερη
ανάλυση των δεδομένων και την ευελιξία της επιλογής ομάδων σε συνάρτηση
με τον χρόνο ή κάποιο άλλο κριτήριο. Εφαρμόζεται συχνά στην
καθημερινότητά μας, καθώς η συμπίεση αρχείων και τα πρότυπα αρχεία ήχου
και εικόνας συμπεριλαμβάνουν μία ή και περισσότερες διαδικασίες μείωσης
του αριθμού των δειγμάτων.

Στην επεξεργασία ψηφιακών σημάτων οι όροι μείωση αριθμού δειγμάτων,
αποδεκατισμός και συμπίεση μπορεί να έχουν ταυτόσημα νοήματα ή μπορεί να
περιγράφουν την απομείωση συχνοτήτων και απόρριψη αριθμού δειγμάτων σε
ένα σύστημα ψηφιακής καταγραφής σημάτων πολλαπλών συχνοτήτων. Αργότερα
θα αναλυθεί η σημασία τέτοιων συστημάτων.
*** Ορισμός
Αποδεκατισμός ενός ψηφιακού σήματος σημαίνει η αποθήκευση τελικώς του
κάθε 10ου π.χ. δείγματος από το αρχικό καταγεγραμμένο σήμα με συγκεκριμένη
συχνότητα καταγραφής. Αυτό έχει επεκταθεί ορίζοντας τον αποδεκατισμό
κατά έναν παράγοντα που συνήθως είναι σταθερός αριθμός και μπορεί να
λάβει ακέραιες και δεκαδικές τιμές.

Εδώ αξίζει να σημειωθεί η ανάγκη να λαμβάνει ο παράγοντας αυτός μια
λογική τιμή, για παράδειγμα ένα ψηφιακό σήμα που έχει διάρκεια πέντε
(5) δευτερόλεπτα και καταγράφηκε από συσκευή που είχε συχνότητα
καταγραφής 20 $\en{Hertz}$ ένας παράγοντας 101 προφανώς δεν θα άφηνε κανένα
δείγμα στο νέο ψηφιακό σήμα. Επιπρόσθετα το όριο για να αποφύγουμε την
αλλοίωση απαιτεί το τελικό αποτέλεσμα των διαδικασιών είναι τα 10
δείγματα ανά δευτερόλεπτο (10 $\en{Hz}$). Επομένως θέτοντας τον παράγοντα
αποδεκατισμού 51 θα παρείχε ένα σήμα που θα ήταν αλλοιωμένο.Όταν η
διαδικασία αυτή εφαρμόζεται σωστά σε μια αλληλουχία δειγμάτων ενός σήματος
ή μιας συνεχούς συνάρτησης, παράγεται μια προσομοίωση του καταγεγραμμένου
με μικρότερη συχνότητα.
*** Ένα φίλτρο ως παράδειγμα
Όταν το φίλτρο κατά της αλλοίωσης είναι σχεδιασμένο με πρότυπο $\en{IIR}$, τα
οποία θα αναλυθούν παρακάτω, η διαδικασία βασίζεται στην ανάδραση της
εξόδου στην είσοδο του φίλτρου πριν την έναρξη του δεύτερου στάδιου. Για
το πρότυπο σχεδιασμού $\en{FIR}$ είναι εύκολο να υπολογιστεί για κάθε Μ εξόδου.
Ο υπολογισμός που γίνεται από ένα τέτοιο φίλτρο αποδεκατισμού για κάθε
νιοστή έξοδο δείγματος φαίνεται παρακάτω.

\begin{equation}
y[n]=\sum_{k=0}^{K-1}x[nM-k] \cdot h[k],
\end{equation}


Όπου η ακολουθία $\en{h}$[•] είναι η απόκριση του κρουστικού παλμού ($\en{impulse\ response}$)
, και K είναι το μήκος. Η $\en{x}$[•] αντιπροσωπεύει το σήμα εισόδου
εξαγόμενο από το φίλτρο με λιγότερα δείγματα.
Σε επεξεργαστές γενικής χρήσης μετά τον υπολογισμό της παραπάνω εξίσωσης
για κάποιον αριθμό $\en{n}$, ο ευκολότερος τρόπος να υπολογιστεί το $\en{y[n+1]}$
είναι η καθυστέρηση της αρχής της ακολουθίας $\en{x}$[•] κατά Μ, και να λυθεί
το παραπάνω άθροισμα ξανά. Άν ο παράγοντας Μ=2, η συνάρτηση $\en{h}$[•] μπορεί
να αντιπροσωπεύει ενα φίλτρο μισών συχνοτήτων, όπου σχεδόν το μισό πλήθος
των δειγμάτων του αρχικού σήματος θα είναι μηδενικής ισχύος ($\en{amplitute}$)
και δεν θα συμπεριληφθούν στο προϊόν πολλαπλασιασμού.
Οι *τιμές* της απόκρισης του παλμού κατά διαστήματα Μ δημιουργούν
υποαληλλουχίες, πλήθους Μ περιπλεγμένες μεταξύ τους.Το παράγογο του
πολλαπλασιασμού είναι η πρόσθεση των προϊόντων από τον πολλαπλασιασμό
κάθε υποαληλλουχίας με το καταγεγραμμένο σήμα $\en{x}$[•]. Επιπρόσθετα λόγω
της μειώσης του πλήθους των δειγμάτων στο σήμα κατά Μ, κάθε σήμα που
χρησιμοποιήθηκε στον προηγούμενο υπολογισμό κάποιου Μ προϊόντος δεν θα
επαναληφθεί σε επόμενο υπολογισμό. Αυτός είναι και ο λόγος που τα φίλτρα
μικρής τάξης Μ $\en{FIR}$ φιλτράρουν μια από τις αλληλουχίες της εισόδου κάθε
φορά και τα Μ προϊόντα προσθέτονται για να κατασκευαστεί το σήμα εξόδου.
Αυτή η μέθοδος εφαρμόζεται σε συστήματα πολλαπλών επεξεργαστών, όπου ένα
σήμα χωρίζεται σε φάσεις και φιλτράρεται ξεχωριστά από Μ αριθμό φίλτρων
και τελικά προσθέτονται για την δημιουργία του σήματος εξόδου. Τα παραπάνω
φίλτρα ονομάζονται και πολυφασικά.

Για εγκυκλοπαιδικούς λόγους αξίζει να σημειωθεί πως είναι πιθανό σε κάθε
φάση του υπολογισμού να αντικαθιστούμε τις τιμές της προηγούμενης φάσης
με μηδενικές τιμές, σε ένα αντίγραφο της αλληλουχίας $\en{h}$[•], επεξεργάζοντας
το αρχικό σήμα στην συχνότητα εισόδου (πολλαπλασιάζοντας με 0) και
αποδεκατίζοντας την έξοδο κατά έναν παράγοντα Μ. Η παραπάνω διαδικασία
ονομάστηκε στα αγγλικά $\en{the\ first\ Noble\ identity}$ και εφαρμόζεται σε
διαφοροποιημένες πολυφασικές μεθόδους.
* Σχεδιασμός Φίλτρων
** Κατηγορίες
Λόγω των πολλών εφαρμογών που έχουν και την εκθετική αύξηση της χρήσης
ηλεκτρονικών συσκευών στην καθημερινότητα, οι δυνατότητες επεξεργασίας
ψηφιακών σημάτων αποτελεί πρακτικά απαραίτητη προϋπόθεση. Έτσι η ανάγκη
για την ανάπτυξη διαφόρων τύπων φίλτρων π.χ. το φίλτρο μέσης τρέχουσας
τιμής ($\en{F.I.R.}$), το φίλτρο άπειρης κρουστικής απόκρισης ($\en{I.I.R.}$) και το μεσιανό
φίλτρο \((median\ filters)\) έγινε εμφανής από το στάδιο ακόμα της ανάπτυξης
του ραδιοφώνου. Στην συνέχεια θα αναφερθούμε και στις τρεις αυτές
κατηγορίες αναφέροντας παραδείγματα από τις μεθόδους που χρησιμοποιήθηκαν
στην ανάλυση των δεδομένων από την *εργαστηριακή εγκατάσταση* ? ...
Η γενική διαφοροποίηση που γίνεται αρχικά είναι ως προς το εύρος
συχνοτήτων που επηρεάζουν. Έτσι αν απορρίπτονται οι ύψηλες συχνότητες, το
φίλτρο ονομάζεται διέλευσης χαμηλών συχνοτήτων ($\en{low-pass\ filter}$)
ενώ το αντίστροφο ονομάζεται φίλτρο διέλευσης υψηλών συχνοτήτων ($\en{high-pass\ filter}$).
Αν το φίλτρο επηρεάζει μία περιοχή ή *φάσμα* συχνοτήτων και
απορρίπτει όσες βρίσκονται πριν και μετά, ονομάζεται φίλτρο απόρριψης
εύρους συχνοτήτων ($\en{band-pass\ filter}$).
** Φίλτρο μέσης τρέχουσας τιμής
Στα προηγούμενα κεφάλαια επικεντρωθήκαμε περισσότερο στην μαθηματική αναπαράσταση
των σημάτων με μια μικρή αναφορά στα γραμμικά συστήματα. Τα φίλτρα αποτελούν γραμμικά
συστήματα και ως εκ τούτου αντιμετωπίζονται λαμβάνοντας υπόψη τις ανάλογες ιδιότητες
και συμπεριφορές. Σκοπός σχεδιασμού αυτών των συστημάτων αποτελεί η αφαίρεση στοιχείων
από κάποιο σήμα, ή η τροποποίηση προκαθορισμένων χαρακτηριστικών του. Εδώ θα αναφερθούμε
στην κατηγορία των συστημάτων πεπερασμένης κρουστικής απόκρισης, ή όπως θα αποκαλούνται
στην συνέχεια για συντομία \(F.I.R.\). Για αρχή μπορούμε να φανταστούμε πως η έξοδος του
φίλτρου παράγεται αθροίζοντας ένα πεπερασμένο αριθμό δειγμάτων όπου εφαρμόζουμε κάποιο
"βάρος στάθμισης". Στόχος των επόμενων ενοτήτων είναι ο προσδιορισμός των βασικών αρχών
πού διέπουν τα διακριτά συστήματα και την εφαρμογή τους στον σχεδιασμό των \(F.I.R.\). Θα
επανέλθουμε στον όρο της γραμμικότητας και θα αναφερθούμε και στην χρονική αμεταβλητότητα
που συνδυασμένες καλύπτουν ένα ευρύ φάσμα της εν' λόγω κατηγορίας.
*** Μέση τρέχουσα τιμή και σχεδιασμός συστήματος
Ένας από τους πιο διαδεδομένους τρόπους μετασχηματισμού σημάτων είναι ο υπολογισμός
της μέσης τιμής για δύο ή παραπάνω δειγμάτων, με σκοπό την αφαίρεση έντονων στιγμιαίων
διακυμάνσεων του σήματος γύρω από κάποια επιθυμητή τιμή. Λόγω της πλειθώρας αλγόριθμων
για των υπολογισμό μέσης τιμής ακολουθιών είναι από τις πιο συχνά εφαρμοσμένες τεχνικές
στον τομέα της οικονομικής επιστήμης και πιο συγκεκριμένα στην μακροχρόνια ανάλυση των
τιμών μετοχής σε χρηματιστήριο. Με απλά λόγια αν κάποιος επιθυμεί να εξετάσει την
ανοδική ή καθοδική πορεία μιας μετοχής δεν τον αφορά η αυξομείωση της τιμής ανά ημέρα,
πόσο μάλλον ανά δευτερόλεπτο. Τα τελευταία δεκαδικά όμως αλλάζουν κάθε δευτερόλεπτο, σε
πραγματικό χρόνο και επομένως εφαρμόζεται ένα φίλτρο μέσης τρέχουσας τιμής στις τιμές
ώστε να είναι δυνατή η αξιοποίηση της πληροφορίας των μεταβολών με μικρότερη απόκλιση,
από την μέση τιμή.

Για να γίνει πιο κατανοητό ας υποθέσουμε πως ένα ψηφιακό σήμα μπορεί να αναπαρασταθεί
ως \(in[z]\). Εφαρμόζεται ένα σύστημα φίλτρου όπως το παραπάνω υπολογίζοντας τον μέσο όρο από
πέντε δείγματα την φορά. Τότε για κάθε δείγμα της ακολουθίας εξόδου του συστήματος θα
ισχύει ότι:
\begin{equation}
\begin{align}
out[n] = \frac{1}{k} \cdot \sum_{z}^{{k-1}}in[n+z], k=5 \\
\end{align}
\end{equation}
Η σχέση (7.1) ονομάζεται και σχέση διαφορών και αποτελεί πλήρη περιγραφή ενός *συστήματος
\(F.I.R\)*, δίνοντας την δυνατότητα στον χρήστη να εξάγει πληροφορία για κάθε τιμή του σήματος
εισόδου \(in[n]\). Όσο για τον προσδιορισμό της αρχικής τιμής της μεταβλητής \(z\) τις περισσότερες
φορές επιλέγεται η τιμή μηδέν με σκοπό να συμπεριλάβουμε το πρώτο δείγμα της εισόδου
στο οποίο αναφερόμαστε εδώ και στην συνέχεια ώς \(in[0]\). Το δείγμα που λαμβάνεται σαν "αρχικό",
για \(n = 1,\ 2,\ 3,\ ... \) μπορούμε να το χαρακτηρίσουμε και ως το παρόν του σήματος. Αντίστοιχα τα
δείγματα που έπονται αυτού, και χρησιμοποιούνται στο παραπάνω σύστημα για τον υπολογισμό
της εξόδου συνθηκολογόντας αναφέρονται στην βιβλιογραφία ως μέλλον του σήματος. Η
συγκεκριμένη οπτική εντάσει την έννοια των "παραθύρων" καθώς ένα συρόμενο παράθυρο, πέντε
τιμών συνεχίζοντας το παράδειγμα, θα ορίσει τις επιλεγμένες τιμές για τον υπολογισμό του
σήματος εξόδου \(out[n]\).
*** Σχεδιασμός και εφαρμογή φίλτρων
Ένα \(F.I.R.\) φίλτρο κατασκευάζεται από την γενική εξίσωση διαφορών που θα δούμε παρακάτω,
όμως αξίζει να αναφέρουμε ένα χαρακτηριστικό. Τα που φίλτρα κατασκευάζονται χρησιμοποιόντας
στοιχεία του παρελθόντος από το σήμα εισόδου για τον υπολογισμό της μέσης τιμής και
έχει επικρατήσει η ονομασία αιτιατό φίλτρο. Με την συγκεκριμένη έκφραση εννοούμε πως
η αιτία που καθορίζει το αποτέλεσμα δεν προηγείται αυτού. Αντίστοιχα τα φίλτρα που
βασίζονται σε στοιχεία που προπορεύονται του εξεταζόμενου στοιχείου ονομάζονται μη
αιτιατά. Ας δούμε την γενική εξίσωση που καθορίζει ένα φίλτρο όπως ορίστηκε παραπάνω,
για κάποιο αιτιατό φίλτρο μέσης τρέχουσας τιμής.
\begin{equation}
\begin{align}
out[x] = \sum_{z=0}^{{T}} a_{z} in[x-z] \\
\end{align}
\end{equation}

Γίνεται λοιπόν αντιληπτό πως λόγω του πεπερασμένου πεδίου ορισμού του σήματος εισόδου,
λόγω της διακριτότητας του φάσματός του, θα υπάρχουν στοιχεία κατά τον υπολογισμό των
αρχικών δειγμάτων εξόδου σε ένα παράθυρο αντίστοιχο εκείνο του αριθμού Τ που βασίζονται
σε λιγότερα από πέντε στοιχεία. Αυτό στις εφαρμογές των φίλτρων προβλέπεται και κατ'
επέκταση δίνεται η δυνατότητα ο δείκτης \(z\) να λάβει αρνητικές τιμές. Στην αρχή μοιάζει
παράδοξο καθώς δεν μπορεί στην φύση να υπάρξει αρνητικός αριθμός δειγμάτων, όμως μας
δίνει την δυνατότητα να εφαρμόζουμε σχετικά μεγάλα παράθυρα, χωρίς τον φόβο διαστρεύλωσης
της εξόδου.

Ένα φίλτρο για να οριστεί πλήρως είναι απαραίτητο να γνωρίζουμε με σαφήνεια όλες τις
τιμές των συντελεστών του, δηλαδή των \(a_{z}\) στο παράδειγμα που ορίστηκε το αιτιατό φίλτρο.
Υποθέτοντας τις παρακάτω τιμές για το σύνολο αυτό μπορούμε να γνωρίζουμε την εξίσωση
που περιγράφει το ανάλογο φίλτρο, π.χ.:
\begin{equation}
\begin{align}
\{a_{z}\} = \{5,\ -7,\ 2,\ 1,\ 9\} \Rightarrow \\
out[x] &= \sum_{z=0}^{4}a_{z}in[x-z] \\
&= 5in[x] - 7in[x-1] + 2in[x-2] + in[x-3] +9in[x-4]
\end{align}
\end{equation}
Όπως φαίνεται είμαστε σε θέση να υπολογίσουμε το σήμα εξόδου για κάθε τιμή της εισόδου.
Ο αριθμός Τ ονομάζεται τάξη του φίλτρου ενώ το πλήθος των συντελεστών ονομάζεται μήκος ή
μέγεθος. Οι έννοιες αυτές προέρχονται από τον μετασχηματισμό \(z\), μέθοδος η οποία  ξεπερνά
το πλαίσιο της παρούσας εργασίας, όμως ας συνδέσουμε το μήκος με την ταχύτητα υπολογισμού
του φίλτρου ενώ την τάξη με την μεταβολή της ταχύτητας κατακρημνισμού της εξίσωσης του
φίλτρου ή όπως ονομάζεται στα περισσότερα όργανα ηλεκτρονικής μουσικής \(release\ value\).
*** notes :noexport:
convolution sum == αθροισμα συνέλιξης
- να προστεθεί
  [[file:../books/ScienceDirect_articles_18Feb2023_15-57-03.874/6---Finite-impulse-response-filter-des_2003_Practical-Digital-Signal-Process.pdf][fir intro]]
- output sequence

  \begin{equation}
  \begin{align}
  y(n)=\sum_{m=0}^{M}x(m)h(n-m)
  \end{align}
  \end{equation}
** Φίλτρο άπειρης κρουστικής απόκρισης
Τα φίλτρα άπειρης κρουστικής απόκρισης είναι όπως προδίδει και το όνομά τους
ακριβώς το αντίθετο από εκείνα της πεπερασμένης . Πρακτικά αυτό σημαίνει
πως η διάρκεια της κρουστικής απόκρισης είναι άπειρη. Αυτό συμβαίνει καθώς ο
υπολογισμός γίνεται χρησιμοποιώντας την μέθοδο της ανάδρασης, αξιοποιώντας την
έξοδο του φίλτρου για την επανατροφοδότηση της εισόδου. Η γενική εξίσωση της
παρούσας κατηγορίας έχει την μορφή:
\begin{equation}
\begin{align}
out[z] = \sum_{f=0}^{\infty}u(f)in(z-f) \\
\end{align}
\end{equation}

Όπως είναι φανερό η διαφορά εδώ είναι πως το άνω όριο της πρόσθεσης προσεγγίζει
το άπειρο, σε θεωρητικό επίπεδο τουλάχιστον. Αυτό συμβαίνει γιατί η απόκριση
της ακολουθίας \(u\) διαθέτει άπειρη διάρκεια. Έτσι όπως θα δειχθεί αμέσως μετά,
ο υπολογισμός με την μέθοδο της συνέλιξης καθίσταται μη πρακτικός και εφαρμόζεται
αναδρομή. Για να γίνει πιο κατανοητή η έννοια της αναδρομής ας δούμε ένα
παράδειγμα που, κατά την σωστή εφαρμογή του, απαιτούνται I+T+1
πολλαπλασιασμοί και I+T αθροίσεις για τον υπολογισμό της απόκρισης του φίλτρου.
\begin{equation}
\begin{align}
out[z] = - \sum_{f=1}^{T}c(f)out(z-f) + \sum_{f=0}^{I}d(f)in(z-f) \\
\end{align}
\end{equation}

Σημαντικό μειονέκτημα των \(IIR\) φίλτρων είναι η διαφορά φάσης που έχει το σήμα
εξόδου. Αν είναι ζωτικής σημασίας, τότε υπερτερούν τα \(FIR\), αφού ο υπολογισμός
της απόκρισης των συστημάτων απειροστού μεγέθους απαιτεί μη γραμμική ανάλυση.
Στην αντίθετη περίπτωση η τάξη (\(order\)) του φίλτρου, για την απόρριψη του ίδιου
φάσματος συχνοτήτων ενός σήματος θα είναι πολύ μικρότερη κάνοντας χρήση της
αναδρομικής ιδιότητας των \(IIR\). Στην επόμενη ενότητα φαίνονται κάποια παραδείγματα
με τον αντίστοιχο κώδικα σε \(python\) για την δημιουργία δειγμάτων των βασικών
τύπων παραθύρων. Αρχικά φαίνονται έντονες διαφορές στην απόκριση που παρέχουν
όμως όλα υπολογίζονται με την χρήση των παραπάνω εξισώσεων. Εξαίρεση απαιτεί
το φίλτρο \(butterworth\) που λεπτομέρειες θα αναφέρουμε στην συνέχεια.

*** notes :noexport:
- να προστεθεί
  [[file:../books/ScienceDirect_articles_18Feb2023_15-57-03.874/7---Infinite-impulse-response--IIR--filte_2003_Practical-Digital-Signal-Proc.pdf][iir intro]]
*** Παραδείγματα με κώδικα
\selectlanguage{greek}
Εδώ φαίνονται μερικά από τα βασικότερα φίλτρα άπειρης κρουστικής απόκρισης, που
από εδώ και πέρα θα αναφερόμαστε σε αυτά ως \(IIR\). Οι τύποι των παρακάτω φίλτρων
αποτελούν τα πιο διαδεδομένα και εύχρηστα, για την προσομοίωση φυσικών εφαρμογών
σε προγραμματιστικό περιβάλλον. Δεν είναι άλλωστε τυχαίο πως οι περισσότερες
γλώσσες προγραμματισμού παρέχουν μια ή και περισσότερες βιβλιοθήκες για τον
σχεδιασμό και τη χρήση τους.

Το φίλτρο \(butterworth\) αποτελεί την καλύτερη δυνατή λύση για έξοδο με την μικρότερη
ενίσχυση καθώς όπως φαίνεται και στο γράφημα δεν παρουσιάζει ταλαντωτικές
συμπεριφορές στις συχνότητες διέλευσης και απόρριψης. Αυτό επιτυγχάνεται
μειώνοντας την ταχύτητα μεταβολής της ισχύος του σήματος, αποκτώντας έτσι μια
περιοχή μετάβασης όπου οι συχνότητες δεν απορρίπτονται όμως απομειώνονται σε
σημαντικό βαθμό ώστε να μην αλλοιώνεται η έξοδος του.

Το \(chebyshev\) ενώ εκ πρώτης όψης φαίνεται να επηρεάζει το σήμα σε μη
αποδεκτό βαθμό, προνόμιό του αποτελεί η ταχύτητα που προσφέρει αποτελέσματα.
Αυτό οφείλεται στην μέθοδο της αναδρομής που χρησιμοποιείται κατά την επεξεργασία
με το συγκεκριμένο φίλτρο. Τα περισσότερα χρησιμοποιούν την μέθοδο της συνέλιξης.

Παρακάτω φαίνεται η κατασκευή ενός πρότυπου φίλτρου τύπου \(butterworth\) με την χρήση
της βιβλιοθήκης \(scipy\). Αντίστοιχα παραδείγματα θα προστεθούν για κάθε γράφημα
πρότυπου φίλτρου.

\selectlanguage{english}
#+begin_src jupyter-python :session py :async yes :results drawer :exports code
# 4TH ORDER BUTTERWORTH FILTER WITH A GAIN DROP OF 1/sqrt(2)
# AT 0.4 CYCLES/SAMPLE
bb, ab  = signal.butter (4, 0.8, 'low', analog=False,output='ba')
wb, hb = signal.freqz(bb, ab)
wb = wb/(2*math.pi)

plt.plot(wb, abs(np.array(hb)))
plt.title('Butterworth filter frequency response')
plt.xlabel('Frequency [cycles/sample]')
plt.ylabel('Amplitute [dB]')
plt.margins(0, 0.1)
plt.grid(which = 'both', axis='both')
#+end_src

#+RESULTS:
:results:
[[file:./.ob-jupyter/5bb4def52422622a5ab7040b172016614c6a9241.png]]
:end:

#+CAPTION:Butterworth filter frequency response

[[file:./Butterworth Filter Freq Response.png]]


#+begin_src jupyter-python :session py :async yes :results drawer :exports code
# 4TH ORDER BESSEL FILTER WITH A GAIN DROP OF 1/sqrt(2)
# AT 0.4 CYCLES/SAMPLE
bb, ab = signal.bessel (4, 0.8, 'low', analog=False, output='ba')
wb, hb = signal.freqz(bb, ab)
wb = wb/(2*math.pi)

plt.plot(wb, abs(np.array(hb)))
plt.title('Bessel filter frequency response')
plt.xlabel('Frequency [cycles/sample]')
plt.ylabel('Amplitute [dB]')
plt.margins(0, 0.1)
plt.grid(which= 'both', axis= 'both')
#+end_src

#+RESULTS:
:results:
[[file:./.ob-jupyter/e1f64950fceed31362ef11f5bdc7ac10d4585ced.png]]
:end:

[[file:./Bessel Filter Freq Response.png]]

#+begin_src jupyter-python :session py :async yes :results drawer :exports code
#4TH ORDER CHEBYSHEV FILTER TYPE 1 (ONLY IN PASSBAND RIPPLES)
# WITH MAX RIPPLES=2 AND THE GAIN DROP AT 1.5 CYCLES/SAMPLE
bb, ab = signal.cheby1 (4, 2, 0.3, 'low', analog=False, output='ba')
wb, hb = signal.freqz(bb, ab)
wb = wb/(2*math.pi)

plt.plot(wb, abs(np.array(hb)))
plt.title('Chebyshev filter frequency response')
plt.xlabel('Frequency [cycles/sample]')
plt.ylabel('Amplitute [dB]')
plt.margins(0, 0.1)
plt.grid(which= 'both', axis= 'both')
#+end_src

#+RESULTS:
:results:
[[file:./.ob-jupyter/2e07bf529bdce8d69449f8042475c67d2e54b5a8.png]]
:end:

[[file:./Chebyshev Filter Freq Response.png]]

#+begin_src jupyter-python :session py :async yes :results drawer :exports code
# 4TH ORDER ELLIPTIC FILTER WITH MAX RIPPLES =2dB IN PASSBAND,
# MIN ATTENUATION =8dB IN STOP BAND AT 0.25 CYCLES/SAMPLE
bb, ab = signal.ellip (4, 2, 8, 0.5, 'low', analog=False, output='ba')
wb, hb = signal.freqz(bb, ab)
wb = wb/(2*math.pi)

plt.plot(wb, abs(np.array(hb)))
plt.title('Elliptic filter frequency response')
plt.xlabel('Frequency [cycles/sample]')
plt.ylabel('Amplitute [dB]')
plt.margins(0, 0.1)
plt.grid(which= 'both', axis= 'both')
#+end_src

#+RESULTS:
:results:
[[file:./.ob-jupyter/f9b1e796b52b2de02812320798379a2f75a0e03d.png]]
:end:

[[file:./Elliptic Filter Freq Response.png]]

\selectlanguage{greek}
Παρατηρούμε πως όλα τα παραπάνω παραδείγματα εφαρμόζονται για το ίδιο φάσμα
συχνοτήτων, όμως επηρεάζουν τις συχνότητες διέλευσης και κατά συνέπια το
σήμα εξόδου με διαφορετικό τρόπο. Ανάλογα με τις εκάστοτε προϋποθέσεις και
περιορισμούς του συστήματος επεξεργασίας που διαθέτουμε μπορεί να προτιμηθεί
κάποια από τις περιπτώσεις που προαναφέρθηκαν εδώ. Η πολυπλοκότητα και το εύρος
των σημάτων που διαχειριζόμαστε σε βιομηχανικές εγκαταστάσεις αλλά και στην
καθημερινή αλληλεπίδραση με τα τεχνολογικά μέσα έχουν εξειδικεύσει αυτές τις
κατηγορίες περεταίρω, με την χρήση αλγορίθμων βελτιστοποίησης, όμως στο πλαίσιο
της παρούσας εργασίας δεν θα σχολιαστούν τέτοιες μέθοδοι.

Αξίζει εδώ να σχολιαστεί ότι τα συγκεκριμένα πρότυπα φίλτρων τυποποιήθηκαν
από το λογισμικό υπολογισμών και προγραμματισμού \(Matlab\) και στην συνέχεια
πολλές γλώσσες προγραμματισμού τα συμπεριέλαβαν σε βιβλιοθήκες για επεξεργασία
σημάτων. Η \(python\) θεωρείται από τις γλώσσες με τις αναλυτικότερες βιβλιοθήκες
για την κατασκευή φίλτρων, λόγω των πολλών επιλογών σε τύπους αλλά ειδικά στην
πλειθώρα χαρακτηριστικών που μπορεί ο χρήστης να καθορίσει για τη συμπεριφορά
και απόκριση των φίλτρων.
* Μεθοδολογία επεξεργασίας και εγκατάσταση εργαστηρίου
** Εγκατάσταση εργαστηρίου
    Η εγκατάσταση που χρησιμοποιήθηκε για την συλλογή των δεδομένων
αποτελείται από μία αεροσύραγγα την οποία τροφοδοτεί με σταθερή ταχύτητα
αέρα ένας ηλεκτροκινητήρας προσδεδεμένος σε έναν έλικα. Στην μέση της
σήραγγας υπάρχει ένα πλέγμα διάχυσης ώστε η ροή του αέρα να γίνεται όσο
το δυνατόν πιο ομοιόμορφα στην έξοδο όπου βρίσκεται και το αισθητήριο
όργανο για την καταγραφή της ταχύτητας του ανέμου. Παρακάτω φαίνεται μια
εικόνα της εγκατάστασης σε σχηματικό διάγραμμα.

#+attr_latex:  :width 420px
#+attr_latex:  :height 250px
#+attr_latex:  :center t
#+ATTR_LATEX: :caption \caption{Θάλαμος ομοιόμορφης παροχής ανέμου στο αισθητήριο όργανο όπου τοποθετείται στο σημείο \textbf{Α}. Στο σημείο  \textbf{\(A_{s}\)}, βρίσκεται ένα πλέγμα διάσπασης της ροής που μας επιτρέπει την ομαλή ταχύτητα στο σημείο εξόδου \textbf{A}.}
[[file:./Wind_Tunnel_setup_lab.png]]
** Μεθοδολογία επεξεργασίας
    Ένας λόγος που δεν χρησιμοποιήθηκε επεξεργασία σε πραγματικό χρόνο είναι
ότι η εγκατάσταση "που χρησιμοποιήθηκε για την συλλογή των δεδομένων"
κατασκευάστηκε με σκοπό την σύνδεσή του σε κεντρική μονάδα επικοινωνίας
και από εκεί πραγματοποιείται σύνδεση μέσω σειριακής θύρας $\en{USB}$ με Η/Υ,
όπου και καταγράφεται το σήμα του αισθητήριου οργάνου ($\en{pitot-tube}$). Ένας
δεύτερος λόγος ήταν η ανάγκη να δοκιμαστούν διαφορετικές μέθοδοι
αφαίρεσης του θορύβου και προφανώς αυτό θα ήταν πιο δύσκολο εάν έπρεπε
να γίνει σε πραγματικό χρόνο αλλάζοντας τις απαραίτητες παραμέτρους για
την ρύθμιση του φίλτρου. Θα έπρεπε λοιπόν να εγκατασταθεί ανάλογη
συσκευή, όπως ένας μικροεπεξεργαστής, που θα είχε την δυνατότητα για
υψηλές ταχύτητες δειγματοληψίας καθώς η καταγραφή έγινε στα 100 $\en{kHz}$.
Αυτό θα αύξανε πολύ το κόστος της κατασκευής και θα απαιτούσε
βαθμονόμιση του φίλτρου για να μην προστεθεί περαιτέρω σφάλμα στην
μέτρηση. Παρακάτω φαίνεται ένα διάγραμμα της συνδεσμολογίας και του τρόπου
καταγραφής του σήματος.

#+begin_src dot :file ./flowcharts/test-first.png :results file :exports results :session dot :tangle ./graphviz/lab-struct.gv
digraph regexp  {
    // size= "4,6!"
    "Pitot-tube" ->
    "H/Y" ->
    "Αρχείο δεδομένων" ->
    "Αρχικό σήμα πρoς επεξεργασία" ->
    "Περιπτώσεις πειράματος" ->
    {"Συμπιεσμένος αέρας"  "Αεροσύραγκα" } [color=red]

    "Συμπιεσμένος αέρας" -> "5, 10 m/s" [color=forestgreen]

    "Αεροσύραγκα" -> "5, 10, 15, 20 m/s" [color=magenta]

    {"5, 10, 15, 20 m/s" "5, 10 m/s" }
    -> {"Ανοιχτός Inverter" "Κλειστός Inverter"}[color = blueviolet,
                                                 arrowhead = diamond,
                                                 arrowsize = 1.4 ]

    "Pitot-tube" -> "Αρχικό σήμα πρoς επεξεργασία"
}

#+end_src

#+attr_latex:  :width 420px
#+attr_latex:  :height 550px
#+attr_latex:  :center t
#+RESULTS:
[[file:./flowcharts/test-first.png]]

Για την επεξεργασία των δεδομένων έπρεπε αρχικά να σιγουρευτούμε πως οι
μετρήσεις δεν υπέφεραν από το φαινόμενο της αλλοίωσης. Έτσι καθίσταται
αναγκαία η εφαρμογή της μεθόδου μείωσης αριθμού δειγμάτων, ώστε να εξεταστεί
το μέγεθος αλλοίωσης του σήματος. Στην συνέχεια έπρεπε να γίνει η μετατροπή
του σήματος στο πεδίο των συχνοτήτων για να αναγνωριστεί το φάσμα συχνοτήτων
που εμπεριέχουν τον θόρυβο και να σχεδιαστεί το κατάλληλο φίλτρο. Για τον σκοπό
αυτό εφαρμόστηκε ο ταχύς μετασχηματισμός \(Fourier\) από την βιβλιοθήκη \(numpy\) και
φάνηκε ξεκάθαρα μια περιοχή συχνοτήτων στα σήματα από τα 2000 \(Hz\).
Εδώ φαίνονται δύο από τα διαγράμματα της ανάλυσης των φίλτρων που
χρησιμοποιήθηκαν στην σύγκριση των μεθόδων απόρριψης του θορύβου.

Η εύρεση της μέσης τιμής για κάθε στοιχείο του
σήματος με την συνάρτηση \(average()\) για την ανάλυση του σήματος στο πεδίο του
χρόνου. Μας δίνει την πληροφορία της ισχύς του σήματος γύρω από την ενδιάμεση
τιμή, ή αλλιώς *άξονας ισορροποίας ταλάντωσης!!>>!>!>!>!*. Επιπρόσθετα η
μέθοδος που εφαρμόζεται για την εξέταση των φίλτρων και των άλλων διεργασιών
που εφαρμόζονται στο σήμα βασίζεται στην τεχνική του \(Welch\) για την εκτίμηση
της πυκνότητας συχνοτικού φάσματος.

Έτσι για την εκλογή των συμπερασμάτων θα παρατεθούν στη συνέχεια διαγράμματα
με το αρχικό σημά και το επεξεργασμένο στο πεδίο των συχνοτήτων καθώς είναι
πιο εύκολο να διακρίνουμε την επηροή των φίλτρων στο σήμα εξόδου. Όπως έχει
αναφερθεί και παραπάνω κατά την απόρριψη του μή αποδεκτού θορύβου, τα φίλτρα
εντάσουν αμελητέες καταστρεπτικές συμπεριφόρες στο σύστημα που αν δεν ληφθούν υπ'
όψη ενδέχεται να επιρρεάσουν το σήμα εξόδου.


#+begin_src latex
\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
\centering
\includegraphics[width=.8 \linewidth]{./fir-200.png}
\caption{\(F.I.R.\) φίλτρο}
\label{fig:sub1}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
\centering
\includegraphics[width=.8 \linewidth]{./iir-butter-200.png}
\caption{\(I.I.R.\) φίλτρο}
\label{fig:sub2}
\end{subfigure}
\caption{Διαφορετικά φίλτρα διέλευσης χαμηλών συχνοτήτων}
\label{fig:test}
\end{figure}
#+end_src

#+RESULTS:
#+begin_export latex
\begin{figure}
\centering
\begin{subfigure}{.5\textwidth}
\centering
\includegraphics[width=.8 \linewidth]{./fir-200.png}
\caption{\(F.I.R.\) φίλτρο}
\label{fig:sub1}
\end{subfigure}%
\begin{subfigure}{.5\textwidth}
\centering
\includegraphics[width=.8 \linewidth]{./iir-butter-200.png}
\caption{\(I.I.R.\) φίλτρο}
\label{fig:sub2}
\end{subfigure}
\caption{Διαφορετικά φίλτρα διέλευσης χαμηλών συχνοτήτων}
\label{fig:test}
\end{figure}
#+end_export

#+begin_src dot :file ./flowcharts/proc-meth.png :results file :exports results :session dot :tangle ./graphviz/proc-methods.gv

digraph processing {
    // root of operations
    root [label="Επεξεργασία σήματος με θόρυβο" ]
    filt [label="Απομείωση θορυβου"]
    aliasing [label="Έλεγχος \n αλλοίωσης"]
    averg [label="Υπολογισμός \n μέσης τιμής \n σήματος"]

    // filter related
    fir [label="FIR"]
    iir [label="IIR"]
    apply [label="Εφαρμογή φίλτρων"]
    filterconst [label="Κατασκευή \n φίλτρων"]
    filt_type [label="Διέλευσης χαμηλών \n συχνοτήτων \n (low-pass)"]

    // aliasing
    decimop [label="Αποδεκατισμός \n ανά 5 και 50 δείγματα \n (decimation)"]
    timedom [label="Επεξεργασία στο πεδίο \n του χρόνου"]

    //general bubbles
    graphs [label="Γραφήματα"]
    fftmethod [label= "Πεδίο συνχότητας \n (fft algorithm)" ]
    choosfilt [label="Επιλογή επιθυμητών \n συχνοτήτων \n(cutoff frequency)"]
    results [label="Σύγκριση αποτελεσμάτων"]
    avrged [label="average(signal, fs) \n \n Ανάλογα με την \n συχνότητα \n καταγραφής, fs"]
    welch [label="Μέθοδος Welch \n (Spectral density)"]

    {rank=same; apply filt_type }
    {rank=same; filt timedom }
    {rank=same; fftmethod aliasing averg}
    {rank=same; decimop filterconst avrged}

    // start the graph at last 🫠
    root -> {filt timedom}

    // filtering path
    filt ->
    fftmethod ->
    choosfilt ->
    filterconst -> {fir iir} ->
    filt_type ->
    apply ->
    welch ->
    graphs [style=bold, color=red]

    // aliasing path
    timedom ->
    aliasing ->
    decimop ->
    apply ->
    graphs[color=blueviolet , style=bold]

    // aliasing path
    timedom ->
    averg ->
    avrged ->
    apply ->
    graphs [color=magenta]

    graphs -> results [color=forestgreen, style=bold]
}
#+end_src

#+attr_latex:  :width 420px
#+attr_latex:  :height 699px
#+attr_latex:  :center t
#+RESULTS:
[[file:./flowcharts/proc-meth.png]]
\clearpage
** Σύγκριση αποτελεσμάτων φίλτρων
Για να συγκρίνουμε τις δυο διαφορετικές διαδικασίες είναι προφανές ότι δεν
ωφελεί να επικεντρωθούμε στην ταχύτητα έκδοσης αποτελεσμάτων. Θα πρέπει λοιπόν
να εξετάσουμε τις διαστρεβλώσεις σε χαμηλές συχνότητες που εντάσσει η κάθε
κατηγορία αλλά και η διαφορά φάσης της εξόδου κάθε διαδικασίας. Εύλογα έχουν
γίνει προσπάθειες για την εξάλειψη της καθυστέρησης που προκύπτει και οι
περισσότερες βιβλιοθήκες με σκοπό την επεξεργασία σημάτων έχουν λύσει σε
τέτοιο βαθμό το πρόβλημα που σχεδόν δεν απασχολεί τον ερευνητή πέρα από την
επιλογή κατάλληλης συνάρτησης. Για την επεξεργασία των δεδομένων έχουν ληφθεί
δύο μέτρα προς την κατεύθυνση αυτή. Το πρώτο αφορά την αποφυγή της συνάρτησης
\(lfilter\) που όπως μπορούμε εύκολα να δείξουμε εντάσσει μεγάλη διαφορά φάσης μεταξύ
της εξόδου και της εισόδου του συστήματος.

#+CAPTION: Σύγκριση συναρτήσεων εφαρμογής του ίδιου φίλτρου της βιβλιοθήκης \(signal\).
[[file:./.ob-jupyter/de30286eca09801df0f7706ea755eda07a1ed450.png]]

Ο έλεγχος των αποτελεσμάτων γίνεται με την χρήση της τυπικής απόκλησης. Κατά
την εφαρμογή οποιουδήποτε φίλτρου θα πρέπει η τυπική απόκληση του σήματος να
μειώνεται, λογικό παράγογο της διαδικασίας καθαρισμού σημάτων από θόρυβο, αφού
η απομάκρυνση από την μέση τιμή θα πρέπει να μειώνεται. Αν η τυπική απόκληση
αυξάνεται, το σύστημα επηρεάζεται καταστρεπτικά από την διεργασία που
εφαρμόζεται σε αυτό. Παρατηρήθηκε αντοίστοιχη συμπεριφορά αυξάνοντας την τάξη
του φίλτρου πέραν του αναγκαίου κατα πολλές τάξεις μεγέθους.
*** DONE Phase delay problem :noexport:
CLOSED: [2023-04-07 Παρ 20:09]
:LOGBOOK:
- CLOSING NOTE [2023-04-07 Παρ 20:09] \\
  done and demonstrated bellow
:END:

**** the phase problem with python
#+begin_src jupyter-python :session py :async yes :results raw drawer :exports none
import numpy as np
import scipy.signal

np.random.seed(42)  # for reproducibility
fs = 30  # sampling rate, Hz
ts = np.arange(0, 5, 1.0 / fs)  # time vector - 5 seconds
ys = np.sin(2*np.pi * 1.0 * ts)  # signal @ 1.0 Hz, without noise
yerr = 0.5 * np.random.normal(size=len(ts))  # Gaussian noise
yraw = ys + yerr

b, a = scipy.signal.iirfilter(4, Wn=2.5, fs=fs, btype="low", ftype="butter")
print(b, a, sep="\n")
y_lfilter = scipy.signal.lfilter(b, a, yraw)

#+end_src

#+RESULTS:
:results:
: [0.00257643 0.01030574 0.01545861 0.01030574 0.00257643]
: [ 1.         -2.63862774  2.76930979 -1.33928076  0.24982167]
:end:

#+begin_src jupyter-python :session py :async yes :results raw drawer :exports none
plt.tight_layout()
# plt.savefig("simple-lowpass-lfilter.png", dpi=100)

# apply filter forward and backward using filtfilt
y_filtfilt = scipy.signal.filtfilt(b, a, yraw)

plt.figure(figsize=[6.4, 2.4])
plt.plot(ts, yraw, label="Raw signal")
plt.plot(ts, y_lfilter, alpha=0.5, lw=3, label="SciPy lfilter")
plt.plot(ts, y_filtfilt, alpha=0.8, lw=3, label="SciPy filtfilt")
plt.legend(loc="lower center", bbox_to_anchor=[0.5, 1], ncol=3,
           fontsize="smaller")
plt.xlabel("Time / s")
plt.ylabel("Amplitude")

plt.tight_layout()
# plt.savefig("lowpass-filtfilt.png", dpi=100)
plt.show()

#+end_src

#+RESULTS:
:results:
: <Figure size 432x288 with 0 Axes>
[[file:./.ob-jupyter/de30286eca09801df0f7706ea755eda07a1ed450.png]]
:end:

[[https://www.samproell.io/posts/yarppg/digital-filters-python/][reference]]
** Επεξεργασία δεδομένων ανέμου
Όπως φαίνεται και στο παραπάνω διάγραμμα ροής για την ικανοποιητική σύγκριση
της επιρροής του φίλτρου στο σήμα που καταγράφηκε από τον αισθητήρα μέτρησης
της ταχύτητας ανέμου, προέχει ο έλεγχος της αλλοίωσης λόγω ανεπαρκούς
συχνότητας της κάρτας ΝΙ (\(Native\ Instruments\)) καταγραφής. Ο τρόπος που επιλέχθηκε
εδώ ήταν η χρήση της τυπικής απόκλισης της κυματομορφής και να ελεγχθεί η
τυχών αύξησή της μετά την επεξεργασία. Από την αρχή μπορούμε να
παρατηρήσουμε πως όταν ο μετασχηματιστής που ευθύνεται για τις παρεμβολές,
είναι εμφανής η αύξηση της τυπικής απόκλισης κατά 2 τάξεις μεγέθους. Επίσης
κατά την διαδικασία βελτιστοποίησης της τάξης του φίλτρου, λόγω βασικών
διαφορών στα \(FIR\) και \(IIR\) συστήματα, χρησιμοποιήθηκε ώστε να αποφευχθεί η
κατασκευή διαγραμμάτων κάθε φορά που πειραματιζόμασταν με διάφορα
χαρακτηριστικά του εκάστοτε φίλτρου.

#+begin_src jupyter-python :session py :async yes :results raw drawer :exports results
from tabulate import tabulate
table = [[f'{dfi_i0_w0.description.replace("Inverter Off", "Μετ. κλειστός").replace("WS", "Ταχ. αν.").replace("100kHz", "")}',
          "{:.4f}".format(np.std(df_tdms_0_0.data)),
          "{:.4f}".format(np.std(dfi_i0_w0.data))],

         [f'{dfi_i1_w0.description.replace("Inverter On", "Μετ. ανοιχτός").replace("WS", "Ταχ. αν.").replace("100kHz", "")}',
          "{:.4f}".format(np.std(df_tdms_1_0.data)),
          "{:.4f}".format(np.std(dfi_i1_w0.data))],
         [f'{dfi_i1_w5.description.replace("Inverter On", "Μετ. ανοιχτός").replace("WS", "Ταχ. αν.").replace("100kHz", "")}',
          "{:.4f}".format(np.std(df_tdms_1_5.data)),
          "{:.4f}".format(np.std(dfi_i1_w5.data))],
         [f'{dfi_i1_w10.description.replace("Inverter On", "Μετ. ανοιχτός").replace("WS", "Ταχ. αν.").replace("100kHz", "")}',
          "{:.4f}".format(np.std(df_tdms_1_10.data)),
          "{:.4f}".format(np.std(dfi_i1_w10.data))],

         [f'{dfi_i1_w15.description.replace("Inverter On", "Μετ. ανοιχτός").replace("WS", "Ταχ. αν.").replace("100kHz", "")}',
          "{:.4f}".format(0),
          "{:.4f}".format(np.std(dfi_i1_w15.data))],
         [f'{dfi_i1_w20.description.replace("Inverter On", "Μετ. ανοιχτός").replace("WS", "Ταχ. αν.").replace("100kHz", "")}',
          "{:.4f}".format(0),
          "{:.4f}".format(np.std(dfi_i1_w20.data))],
         ]

print(tabulate(table, headers=["Ταχύτητα ανέμου και μετασχηματιστής",
                               "Συμπιεσμένος αέρας",
                               "Αεροσύραγγα"]))

#+end_src

#+RESULTS:
:results:
: Ταχύτητα ανέμου και μετασχηματιστής      Συμπιεσμένος αέρας    Αεροσύραγγα
: -------------------------------------  --------------------  -------------
: Μετ. κλειστός, Ταχ. αν.=0,                           0.0062         0.0076
: Μετ. ανοιχτός, Ταχ. αν.=0,                           0.0364         0.0392
: Μετ. ανοιχτός, Ταχ. αν.=5,                           0.0434         0.0385
: Μετ. ανοιχτός, Ταχ. αν.=10,                          0.0841         0.04
: Μετ. ανοιχτός, Ταχ. αν.=15,                          0              0.0421
: Μετ. ανοιχτός, Ταχ. αν.=20,                          0              0.0566
:end:
Πίνακας τυπικής απόκλησης αρχικών σημάτων.

** Εφαρμογή φίλτρων
Για την παρεμβολή που επηρεάζει το σήμα του αισθητήρα θα εφαρμοστεί ένα φίλτρο
διέλευσης χαμηλών συχνοτήτων. Είμαστε σε θέση να γνωρίζουμε πως οι χαμηλές
συχνότητες του σήματος εμπεριέχουν όλο το ποσό της πληροφορίας που αποτελεί
την μέτρηση. Οι μετρήσεις που καταγράφηκαν για μηδενικές ταχύτητες, με τον
μετασχηματιστή κλειστό και ανοιχτό, χρησιμοποιήθηκαν για να βρεθεί η
ονομαστική τάση του αισθητήρα. Οσο για την επιλογή του κατάλληλου φίλτρου,
ως καταλληλότερα κρίθηκαν το \(butterworth\) από την κατηγορία των \(IIR\) για την
ελάχιστη διαστρεύλωση που αποφέρει κατα την εφαρμογή του στις συχνότητες
διέλευσης. Για την εύκολη σύγκριση των δύο μεθόδων, τα φίλτρα \(FIR\) έπρεπε να
μετατραπούν από την μορφή της εξίσωσης μεταφοράς σε δευτέρας τάξης "κομμάτια"
της αναπαράστασης της εξίσωσης μεταφοράς που χαρακτηρίζει το φίλτρο. Για τις
κατηγορίες που θα δούμε παρακάτω, οι βασικοί τύποι των \(FIR\) φίλτρων που θα
παρουσιαστούν αναφέρονται στην ευρύτερη βιβλιογραφία ως τύπου \(I\) και τύπου \(II\).
Η διαφορά είναι πως τα πρώτα παρουσιάζουν θετική συμμετρία και έχουν τάξη
ακαίρεου περιττού αριθμού. Τα τύπου \(II\) εμφανίζουν την ίδια συμμετρία, όμως
η τάξη του φίλτρου είναι άρτιος αριθμός.

Υπάρχουν άλλες δύο κατηγορίες που εμφανίζουν αρνητική συμμετρία, όμως η
διαφορά στις τάξεις των φίλτρων τύπου \(III,\ IV\) είναι ανάλογες με των προηγούμενων
δύο τύπων.

Στην παρούσα εργασία ασχοληθήκαμε μόνο με φίλτρα από τους πρώτους 2 τύπους,
όμως αργότερα θα μπορούσαν να ερευνηθούν και περισσότεροι τύποι και
κατηγορίες παραθύρων. Όλες οι παραπάνω κατηγορίες συμπεριλαμβανομένων και
των \(IIR\), στην έξοδό τους, το σήμα παραμορφώνεται εμφανίζοντας διαφορά φάσης
με το σήμα εξόδου. Έτσι, όπως αναφέρθηκε και νωρίτερα στην ενότητα 6.3,
επιλέγοντας την σωστή συνάρτηση από την κατάλληλη βιβλιοθήκη μπορούμε να
μειώσουμε το σφάλμα της αλλοίωσης και την πρόσθεση διαφοράς φάσης, σε
αποδεκτό βαθμό. Στην συνέχεια θα συγκριθούν τα διαγράμματα της πυκνώτητας
ισχύος του σήματος με την μέθοδο του \(Welch\), ώστε να εκλεγεί το κατάλληλο
προς εφαρμογή φίλτρο.
** Αποτελέσματα επεξεργασίας
Για κάθε σήμα που καταγράφηκε εφαρμόστηκαν και οι δύο μέθοδοι και φάνηκε πως
ενώ για τα φίλτρα \(IIR\) είχαμε αποδεκτό βαθμό αλλοίωσης, ελέγχοντας την
τυπική απόκληση του σήματος εξόδου με εκείνη της εισόδου, τα \(FIR\)
φίλτρα παρέχουν καλύτερα αποτελέσματα. Ο τύπος του θορύβου που επηρεάζει το
σήμα του αισθητήρα εμφανίζεται κυρίως σε συχνότητες που καταλαμβάνουν
ηλεκτρομαγνητικά κύματα ξεκινώντας από την περιοχή των 10-100 \(kHz\).
Καταγράφηκαν και σήματα με συχνότητα δειγματοληψίας 500 \(kHz\) και ο θόρυβος
παραμένει, επομένως κρίθηκε πως πρόκειται για σήμα μεγαλύτερης συχνότητας
από τις δυνατότητες καταγραφής του συστήματος που διαθέτουμε.
*** Αποδεκατισμός σήματος
Η τεχνική του αποδεκατισμού εφαρμόστηκε κυρίως στην αρχή της επεξεργασίας
για να ελεγχθεί η διαδικασία καταγραφής. Κατέστη αναγκαίο να μπορέσουμε
να διασταυρώσουμε τον βαθμό που το αρχικό σήμα υπέστει αλλοίωση από την
καταγραφή του. Επίσης σημαντικό ήταν να διασφαλιστεί πως κάθε μέθοδος
απόρριψης συχνοτήτων θα μπορούσε να εφαρμοστεί σε μειωμένο αριθμό
δειγμάτων. Λόγω υψηλής συχνότητας καταγραφής μετά τα δέκα δευτερόλεπτα
διάρκειας σήματος, για την ολοκλήρωση των διαδικασιών που εφαρμόζονται, θα
χρειαζόμασταν πολύ χρόνο. Στα παρακάτω διαγράμματα αποτυπώνεται ο τρόπος
που επηρεάζει το σήμα η διαδικασία αυτή.

- [ ] *Εδώ πρεπει να μπουν διαγράμματα απο decimation*
- [-] Να πω και μερικά πραγματα μαζι με τα αποτελέσματα.
- [X] Έχω ήδη κάποια από τα αρχεία για το paper
- [X] Να τσεκαριστούν για να είμαι σίγουρος
*** TODO decimation for noise code
**** Directories
#+begin_src jupyter-python :session py :async yes :results raw drawer :exports none

ca_meas_dir = FOLDER_FOR_DATA / 'compressed air'

data_CA_inv_1_WS_0 = 'ca1_0.1'
# contains the following channels
# [<TdmsChannel with path /'Wind Measurement'/'Torque'>,
#  <TdmsChannel with path /'Wind Measurement'/'Drag'>,
#  <TdmsChannel with path /'Wind Measurement'/'Wind1'>,
#  <TdmsChannel with path /'Wind Measurement'/'Wind2'>]

path_ca_meas = ca_meas_dir / f'{data_CA_inv_1_WS_0}' / TDMS_FNAME

tdms_raw_WT =TdmsFile(path_ca_meas)

ca1_0 = WT_NoiseChannelProc.from_tdms(tdms_raw_WT[GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter On, WS=0, 500kHz')
#%%


# Decimation folder measurments
dec_meas_dir = FOLDER_FOR_DATA / 'Decimation'
dec_at_50_kHz = 'de50.1'
dec_at_5_kHz = 'de5.1'
path_dec_meas_50_kHz = dec_meas_dir / f'{dec_at_50_kHz}' / TDMS_FNAME

path_dec_meas_5_kHz = FOLDER_FOR_DATA / dec_meas_dir / f'{dec_at_5_kHz}' / TDMS_FNAME

tdms_raw_WT_50kHz =TdmsFile(path_dec_meas_50_kHz)
tdms_raw_WT_5kHz =TdmsFile(path_dec_meas_5_kHz)


dec_50kHz = WT_NoiseChannelProc.from_tdms(tdms_raw_WT_50kHz[GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter On, WS=0, 50kHz')
dec_5kHz = WT_NoiseChannelProc.from_tdms(tdms_raw_WT_5kHz[GROUP_NAME][CHAN_NAME]
                , desc= 'Inverter On, WS=0, 5kHz')


#+end_src

#+RESULTS:
:results:
:end:
**** plots for different sampling rates
#+begin_src jupyter-python :session py :async yes :results raw drawer :exports both

NPERSEG=1024<<6
FIGSIZE = (15,10)
medec = 100

print(len(ca1_0.decimate(dec=medec, offset=0).data))
y = signal.decimate(ca1_0.data, medec, ftype='fir')
z, f = signal.welch(y,
                    fs=ca1_0.fs_Hz/medec,
                    window='flattop',
                    nperseg=NPERSEG/medec,
                    scaling='density')
print(len(y))
sign = Graph_data_container(x=z,
                            y=f,
                            label="dec factor 100")

plot_spect_comb2([
    ca1_0.decimate(dec=1,offset=0).set_desc('500 kHz origin').calc_spectrum( nperseg=NPERSEG, scaling='density'),
    ca1_0.decimate(dec=medec,offset=0).set_desc('5 kHz (dec=10)').calc_spectrum( nperseg=NPERSEG/medec, scaling='density'),
    dec_5kHz.set_desc('5 kHz origin').calc_spectrum(nperseg=NPERSEG/100, scaling='density')
],
                 title='Decimation without antialiasing filter',
                 xlim=[1e0,1e6], ylim = [1e-5,0.5e-2],
                 figsize = FIGSIZE,
                 draw_lines=True
                 )
plt.savefig(f'./decimation/with_aliasing.png',facecolor='white', transparent=False)
plot_spect_comb2([
    ca1_0.decimate(dec=1,offset=0).set_desc('500 kHz origin').calc_spectrum( nperseg=NPERSEG/1, scaling='density'),
    sign,
    dec_5kHz.set_desc('5 kHz origin').calc_spectrum(nperseg=NPERSEG/100, scaling='density')
],
                 title='Decimation with antialiasing FIR filter',
                 xlim=[1e0,1e6], ylim = [1e-5,0.5e-2],
                 figsize = FIGSIZE,
                 draw_lines=True
                 )
plt.savefig(f'./decimation/anti_aliasing_fir.png',facecolor='white', transparent=False)
#+end_src

#+RESULTS:
:results:
: 31000
: 31000
[[file:./.ob-jupyter/a3d20fded563310c6e4dc7f72d8fcfe3bb569e41.png]]
[[file:./.ob-jupyter/9500a1fe15f65520b7d4998b7da115abaeb418cb.png]]
:end:

#+begin_src jupyter-python :session py :async yes :results raw drawer :exports none
tablexydec=[["X axis length",
             len(ca1_0.decimate(dec=1, offset=0).calc_spectrum( nperseg=NPERSEG).x),
             len(ca1_0.decimate(dec=10, offset=0).calc_spectrum( nperseg=NPERSEG/10).x),
             len(ca1_0.decimate(dec=100, offset=0).calc_spectrum( nperseg=NPERSEG/100).x)
             ],
            ["Y axis length",
             len(ca1_0.decimate(dec=1, offset=0).calc_spectrum( nperseg=NPERSEG).y),
             len(ca1_0.decimate(dec=10, offset=0).calc_spectrum( nperseg=NPERSEG/10).y),
             len(ca1_0.decimate(dec=100, offset=0).calc_spectrum( nperseg=NPERSEG/100).y)
             ]]

tablexyrec=[["X axis length",
             0,
             len(dec_50kHz.calc_spectrum(nperseg=NPERSEG/10).x),
             len(dec_5kHz.calc_spectrum(nperseg=NPERSEG/100).x),
             ],
            ["Y axis length",
             0,
             len(dec_50kHz.calc_spectrum(nperseg=NPERSEG/10).y),
             len(dec_5kHz.calc_spectrum(nperseg=NPERSEG/100).y),
             ]]
print(tabulate(tablexydec, headers=["custom decimation", "no dec", "50kHz", "5kHz"]))
print(tabulate(tablexyrec, headers=["record decimation", "no dec", "50kHz", "5kHz"]))
#+end_src

#+RESULTS:
:results:
: custom decimation      no dec    50kHz    5kHz
: -------------------  --------  -------  ------
: X axis length           32769     3277     328
: Y axis length           32769     3277     328
: record decimation      no dec    50kHz    5kHz
: -------------------  --------  -------  ------
: X axis length               0     3277     328
: Y axis length               0     3277     328
:end:
**** [#A] WHAT IS LOADED TO JUPYTER KERNEL :noexport:
#+begin_src jupyter-python :session py :async yes :results raw drawer
%whos
#+end_src

#+RESULTS:
:results:
#+begin_example
Variable               Type                   Data/Info
-------------------------------------------------------
Axis_titles            type                   <class 'pros_noisefilteri<...>n_functions.Axis_titles'>
CHAN_NAME              str                    Wind2
FIGSIZE                tuple                  n=2
FIGSIZE_STD            tuple                  n=2
FOLDER_FOR_DATA        PosixPath              /mnt/data_folder/measurem<...>2/new_record_prop_channel
Fft_Plot_info          type                   <class 'pros_noisefilteri<...>functions.Fft_Plot_info'>
GROUP_NAME             str                    Wind Measurement
Graph_data_container   type                   <class 'pros_noisefilteri<...>er.Graph_data_container'>
NPERSEG                int                    65536
Path                   type                   <class 'pathlib.Path'>
Signals_for_fft_plot   type                   <class 'pros_noisefilteri<...>ns.Signals_for_fft_plot'>
TDMS_FNAME             str                    Data.tdms
TdmsFile               type                   <class 'nptdms.tdms.TdmsFile'>
WT_NoiseChannelProc    type                   <class 'pros_noisefilteri<...>roc.WT_NoiseChannelProc'>
ca1_0                  WT_NoiseChannelProc    <pros_noisefiltering.WT_N<...>object at 0x7f8772a778b0>
ca_meas_dir            PosixPath              /mnt/data_folder/measurem<...>op_channel/compressed air
comp_air_dir           str                    compressed air
data_CA_inv_0_WS_0     str                    ca0_0.1
data_CA_inv_0_WS_11    str                    ca0_10.1
data_CA_inv_0_WS_5     str                    ca0_5.1
data_CA_inv_1_WS_0     str                    ca1_0.1
data_CA_inv_1_WS_10    str                    ca1_10.1
data_CA_inv_1_WS_5     str                    ca1_5.1
data_inv_inv_0_WS_0    str                    in0_0.1
data_inv_inv_1_WS10    str                    in1_10.1
data_inv_inv_1_WS15    str                    in1_15.1
data_inv_inv_1_WS_0    str                    in1_0.1
data_inv_inv_1_WS_20   str                    in1_20.1
data_inv_inv_1_WS_5    str                    in1_5.1
dec_50kHz              WT_NoiseChannelProc    <pros_noisefiltering.WT_N<...>object at 0x7f8779409210>
dec_5kHz               WT_NoiseChannelProc    <pros_noisefiltering.WT_N<...>object at 0x7f8779409420>
dec_at_50_kHz          str                    de50.1
dec_at_5_kHz           str                    de5.1
dec_meas_dir           PosixPath              /mnt/data_folder/measurem<...>d_prop_channel/Decimation
df_tdms_0_0            WT_NoiseChannelProc    <pros_noisefiltering.WT_N<...>object at 0x7f8772a770d0>
df_tdms_0_10           WT_NoiseChannelProc    <pros_noisefiltering.WT_N<...>object at 0x7f8772a77100>
df_tdms_0_5            WT_NoiseChannelProc    <pros_noisefiltering.WT_N<...>object at 0x7f8772a8d480>
df_tdms_1_0            WT_NoiseChannelProc    <pros_noisefiltering.WT_N<...>object at 0x7f8772a77160>
df_tdms_1_10           WT_NoiseChannelProc    <pros_noisefiltering.WT_N<...>object at 0x7f8772a5d870>
df_tdms_1_5            WT_NoiseChannelProc    <pros_noisefiltering.WT_N<...>object at 0x7f8772a5f310>
dfi_i0_w0              WT_NoiseChannelProc    <pros_noisefiltering.WT_N<...>object at 0x7f87aa7b3520>
dfi_i1_w0              WT_NoiseChannelProc    <pros_noisefiltering.WT_N<...>object at 0x7f8772a8d360>
dfi_i1_w10             WT_NoiseChannelProc    <pros_noisefiltering.WT_N<...>object at 0x7f8772a5db70>
dfi_i1_w15             WT_NoiseChannelProc    <pros_noisefiltering.WT_N<...>object at 0x7f8772970dc0>
dfi_i1_w20             WT_NoiseChannelProc    <pros_noisefiltering.WT_N<...>object at 0x7f87729714e0>
dfi_i1_w5              WT_NoiseChannelProc    <pros_noisefiltering.WT_N<...>object at 0x7f8772a5de10>
fft                    function               <function fft at 0x7f879807d900>
fft_calc_sig           type                   <class 'pros_noisefilteri<...>_functions.fft_calc_sig'>
fft_sig                function               <function fft_sig at 0x7f8772a37250>
ifft                   function               <function ifft at 0x7f879807da20>
inv_meas_dir           str                    inverter
item                   str                    in1_20.1
l_tdms_CA              list                   n=6
l_tdms_Inv             list                   n=6
math                   module                 <module 'math' from '/usr<...>310-x86_64-linux-gnu.so'>
np                     module                 <module 'numpy' from '/us<...>kages/numpy/__init__.py'>
nptdms                 module                 <module 'nptdms' from '/u<...>ages/nptdms/__init__.py'>
path_ca_meas           PosixPath              /mnt/data_folder/measurem<...>sed air/ca1_0.1/Data.tdms
path_comp              PosixPath              /mnt/data_folder/measurem<...>ord_prop_channel/inverter
path_dec_meas_50_kHz   PosixPath              /mnt/data_folder/measurem<...>cimation/de50.1/Data.tdms
path_dec_meas_5_kHz    PosixPath              /mnt/data_folder/measurem<...>ecimation/de5.1/Data.tdms
pd                     module                 <module 'pandas' from '/u<...>ages/pandas/__init__.py'>
plot_FFT               function               <function plot_FFT at 0x7f8772a37400>
plot_spect_comb2       function               <function plot_spect_comb2 at 0x7f8772a36dd0>
plt                    module                 <module 'matplotlib.pyplo<...>es/matplotlib/pyplot.py'>
pnf                    module                 <module 'pros_noisefilter<...>sefiltering/__init__.py'>
raw_signal_CA          list                   n=6
signal                 module                 <module 'scipy.signal' fr<...>cipy/signal/__init__.py'>
spect                  function               <function spect at 0x7f8772a36cb0>
tdms_raw_WT            TdmsFile               <nptdms.tdms.TdmsFile object at 0x7f8772a777c0>
tdms_raw_WT_50kHz      TdmsFile               <nptdms.tdms.TdmsFile object at 0x7f8772a77850>
tdms_raw_WT_5kHz       TdmsFile               <nptdms.tdms.TdmsFile object at 0x7f87726d3b20>
x                      TdmsFile               <nptdms.tdms.TdmsFile object at 0x7f8772970460>
#+end_example
:end:
**** plots for decimated signals from same origin
#+begin_src jupyter-python :session py :async yes :results raw drawer :exports none


#%% [markdown]
# ## Comparing compressed air with other measurements with less sampling frequency
# comparing the signal
# when different filters are applied and averaging occurs
#

plot_spect_comb2([ca1_0.set_desc('500 kHz').calc_spectrum( nperseg=NPERSEG),
                  dec_50kHz.set_desc('50 kHz').calc_spectrum( nperseg=NPERSEG/10),
                  dec_5kHz.set_desc('5 kHz').calc_spectrum( nperseg=NPERSEG/100)
                  ],
                title='Comparison of signals with different sampling rates',
                xlim=[1e1,2.5e5], ylim = [1e-5,0.5e-2],
                figsize = FIGSIZE
                , draw_lines=True
                )


#+end_src

#+RESULTS:
:results:
[[file:./.ob-jupyter/9a155e0b01d643dd26037e911f51dea7d30ac4fb.png]]
:end:
**** time histories
#+begin_src jupyter-python :session py :async yes :results raw drawer :exports none
in1_0_av100 = ca1_0.average(100)
print(ca1_0.operations)
print(in1_0_av100.operations)
print(ca1_0.decimate(1).operations)
print(ca1_0.decimate(1).average(100).operations)
print(ca1_0.filter(fc_hz=100).average(100).operations)
#+end_src
*** Απομείωση θορύβου
- [ ] *Εδώ πρεπει να μπουν διαγράμματα απο filters and welch*
- [ ] *Να φέρω τα αναγκαία εδώ σε code blocks*
- [X] Τα έχω ήδη από τα τους φακέλους με τα φίλτρα
- [X] Να τσεκαριστούν για να είμαι σίγουρος
*** TODO code :noexport:
* Συμπεράσματα
\clearpage
* Βιβλιογραφία
\selectlanguage{english}
#+bibliography: ./diss_bibliography.bib
[cite/n:@SULAIMAN20223117]
[cite/n:@auto-fir-from-analog]
[cite/n:@iir-survey]
[cite/n:@SMITH2003333]
[cite/n:@pitot-standards]
[cite/n:@LAI200314]
[cite/n:@LAI200350]
[cite/n:@LAI200361]
[cite/n:@LAI200398]
[cite/n:@Re-on-pitot]
[cite/n:@sig-proc-first]
[cite/n:@oppenheim99]
#+print_bibliography:
* Source blocks :noexport:
** FFT

#+begin_src jupyter-python :session none  :async yes :results drawer

class FftNew:
    """# Better approach to fft.

    Here is an example of how the calculation of fft for a given
    signal is implemented.

    Main function
    ----------
    >>>def fft_calc_and_plot(self):
    >>>    num_samp = len(self.time_sec)
    >>>    # compute fft
    >>>    fhat = fft(self.sig, num_samp)
    >>>    # Power spectrum (power/freq)
    >>>    psd = fhat * np.conj(fhat) / num_samp
    >>>    # create x-axis (frequencies)
    >>>    freq = (1/(self.time_interv * num_samp)) * np.arange(num_samp)
    >>>    # plot only first half (possitive)
    >>>    plt_pos = np.arange(1, np.floor(num_samp/2), dtype=int)

    Usage
    ----------
    >>>FftNew(df_tdms_1_0.decimate(dec=5, offset=0),
    >>>     title='Decimation number 5 CA INV ON').fft_calc_and_plot()

    Reference
    ----------
    http://databookuw.com/
    """

    def __init__(self, sign, title):
        """# Object initialize.

        This function constructs an object for a given signal
        which will be plotted in the frequency domain.
        """
        self.plt_title = title
        self.samp_rate = sign.fs_Hz
        self.sig = sign.data
        self.ind = sign.data_as_Series.index
        self.time_interv = 1 / int(self.samp_rate)
        self.time_sec = self.ind * self.time_interv

    def fft_calc_and_plot(self):
        """# FFT calculation and plotting.

        This function is used to calculate and plot a signal in the
        frequency domain using the fft library from numpy.
        """
        num_samp = len(self.time_sec)
        # compute fft
        fhat = fft(self.sig, num_samp)
        # Power spectrum (power/freq)
        psd = fhat * np.conj(fhat) / num_samp
        # create x-axis (frequencies)
        freq = (1/(self.time_interv * num_samp)) * np.arange(num_samp)
        # plot only first half (possitive)
        plt_pos = np.arange(1, np.floor(num_samp/2), dtype=int)

        fig, axs = plt.subplots(2, 1)

        plt.sca(axs[0])
        plt.grid(True, which='both')
        plt.title(self.plt_title)
        plt.xlabel('Time [s]')
        plt.ylabel('Amplitute (Voltage)')
        plt.plot(self.time_sec, self.sig)
        # plt.loglog(freq[plt_pos],(PSD[plt_pos]))

        plt.sca(axs[1])
        plt.loglog(freq[plt_pos], abs(psd[plt_pos]))
        plt.title('Frequency domain')
        plt.xlabel('Frequencies [Hz]')
        plt.ylabel('Power/Freq')
        plt.grid(True, which='both')


#+end_src
* GO BUTTONS :noexport:
# <(agenda)> file:~/org/agenda.org
# <(code)>
# <(diss-notes)>
# <(edit latex headers file)>
# <(apa citation file)>
# <(go to presentation)>
